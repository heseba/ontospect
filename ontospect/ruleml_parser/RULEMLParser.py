# Generated from D:/OneDrive/ontoproject/ontospect/ruleml_parser/ruleml_grammar\RULEMLParser.g4 by ANTLR 4.8
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\u00b0")
        buf.write("\u0502\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t")
        buf.write("&\4\'\t\'\4(\t(\4)\t)\4*\t*\4+\t+\4,\t,\4-\t-\4.\t.\4")
        buf.write("/\t/\4\60\t\60\4\61\t\61\4\62\t\62\4\63\t\63\4\64\t\64")
        buf.write("\4\65\t\65\4\66\t\66\4\67\t\67\48\t8\49\t9\4:\t:\4;\t")
        buf.write(";\4<\t<\4=\t=\4>\t>\4?\t?\4@\t@\4A\tA\4B\tB\4C\tC\4D\t")
        buf.write("D\4E\tE\4F\tF\4G\tG\4H\tH\4I\tI\4J\tJ\4K\tK\4L\tL\4M\t")
        buf.write("M\4N\tN\4O\tO\4P\tP\4Q\tQ\4R\tR\4S\tS\4T\tT\4U\tU\4V\t")
        buf.write("V\4W\tW\4X\tX\4Y\tY\4Z\tZ\4[\t[\4\\\t\\\4]\t]\4^\t^\4")
        buf.write("_\t_\4`\t`\4a\ta\4b\tb\4c\tc\4d\td\4e\te\4f\tf\4g\tg\4")
        buf.write("h\th\4i\ti\4j\tj\4k\tk\4l\tl\4m\tm\4n\tn\4o\to\4p\tp\4")
        buf.write("q\tq\4r\tr\4s\ts\4t\tt\4u\tu\4v\tv\4w\tw\4x\tx\4y\ty\4")
        buf.write("z\tz\4{\t{\4|\t|\4}\t}\4~\t~\4\177\t\177\4\u0080\t\u0080")
        buf.write("\4\u0081\t\u0081\4\u0082\t\u0082\4\u0083\t\u0083\4\u0084")
        buf.write("\t\u0084\4\u0085\t\u0085\4\u0086\t\u0086\4\u0087\t\u0087")
        buf.write("\4\u0088\t\u0088\4\u0089\t\u0089\4\u008a\t\u008a\4\u008b")
        buf.write("\t\u008b\4\u008c\t\u008c\4\u008d\t\u008d\4\u008e\t\u008e")
        buf.write("\4\u008f\t\u008f\4\u0090\t\u0090\4\u0091\t\u0091\4\u0092")
        buf.write("\t\u0092\4\u0093\t\u0093\4\u0094\t\u0094\4\u0095\t\u0095")
        buf.write("\4\u0096\t\u0096\4\u0097\t\u0097\4\u0098\t\u0098\4\u0099")
        buf.write("\t\u0099\4\u009a\t\u009a\4\u009b\t\u009b\3\2\7\2\u0138")
        buf.write("\n\2\f\2\16\2\u013b\13\2\3\2\3\2\7\2\u013f\n\2\f\2\16")
        buf.write("\2\u0142\13\2\3\2\7\2\u0145\n\2\f\2\16\2\u0148\13\2\3")
        buf.write("\2\3\2\3\3\7\3\u014d\n\3\f\3\16\3\u0150\13\3\3\3\3\3\7")
        buf.write("\3\u0154\n\3\f\3\16\3\u0157\13\3\3\3\3\3\7\3\u015b\n\3")
        buf.write("\f\3\16\3\u015e\13\3\3\3\3\3\7\3\u0162\n\3\f\3\16\3\u0165")
        buf.write("\13\3\3\3\3\3\7\3\u0169\n\3\f\3\16\3\u016c\13\3\3\3\3")
        buf.write("\3\7\3\u0170\n\3\f\3\16\3\u0173\13\3\3\3\3\3\7\3\u0177")
        buf.write("\n\3\f\3\16\3\u017a\13\3\3\4\7\4\u017d\n\4\f\4\16\4\u0180")
        buf.write("\13\4\3\4\3\4\7\4\u0184\n\4\f\4\16\4\u0187\13\4\3\4\3")
        buf.write("\4\7\4\u018b\n\4\f\4\16\4\u018e\13\4\3\4\3\4\7\4\u0192")
        buf.write("\n\4\f\4\16\4\u0195\13\4\3\4\3\4\7\4\u0199\n\4\f\4\16")
        buf.write("\4\u019c\13\4\3\4\3\4\7\4\u01a0\n\4\f\4\16\4\u01a3\13")
        buf.write("\4\3\4\3\4\7\4\u01a7\n\4\f\4\16\4\u01aa\13\4\3\5\3\5\3")
        buf.write("\6\3\6\3\6\3\6\3\7\3\7\3\7\3\7\3\b\3\b\3\b\3\b\3\t\3\t")
        buf.write("\3\n\3\n\3\n\3\n\3\13\3\13\3\13\3\13\3\13\3\13\3\13\3")
        buf.write("\f\3\f\3\f\7\f\u01ca\n\f\f\f\16\f\u01cd\13\f\5\f\u01cf")
        buf.write("\n\f\3\r\3\r\3\r\3\r\3\r\3\r\7\r\u01d7\n\r\f\r\16\r\u01da")
        buf.write("\13\r\5\r\u01dc\n\r\3\16\3\16\3\16\3\16\3\16\3\16\3\16")
        buf.write("\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16")
        buf.write("\3\16\3\16\3\16\5\16\u01f3\n\16\3\17\3\17\3\17\3\17\3")
        buf.write("\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17")
        buf.write("\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17")
        buf.write("\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17")
        buf.write("\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17")
        buf.write("\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17")
        buf.write("\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17")
        buf.write("\3\17\3\17\3\17\3\17\5\17\u023f\n\17\3\20\3\20\3\20\3")
        buf.write("\20\3\20\3\21\7\21\u0247\n\21\f\21\16\21\u024a\13\21\3")
        buf.write("\21\6\21\u024d\n\21\r\21\16\21\u024e\3\21\5\21\u0252\n")
        buf.write("\21\3\21\7\21\u0255\n\21\f\21\16\21\u0258\13\21\3\21\3")
        buf.write("\21\5\21\u025c\n\21\3\22\3\22\6\22\u0260\n\22\r\22\16")
        buf.write("\22\u0261\3\23\3\23\7\23\u0266\n\23\f\23\16\23\u0269\13")
        buf.write("\23\3\23\3\23\3\24\3\24\3\25\3\25\3\26\3\26\3\27\3\27")
        buf.write("\3\30\3\30\3\31\3\31\3\32\3\32\3\33\3\33\3\34\3\34\3\35")
        buf.write("\3\35\3\36\3\36\3\37\3\37\3 \3 \3!\3!\3\"\3\"\3#\3#\3")
        buf.write("$\3$\3%\3%\3&\3&\3\'\3\'\3(\3(\3)\3)\3*\3*\3+\3+\3,\3")
        buf.write(",\3-\3-\3.\3.\3/\3/\3\60\3\60\3\61\3\61\3\62\3\62\3\63")
        buf.write("\3\63\3\64\3\64\3\65\3\65\3\66\3\66\3\67\3\67\38\38\3")
        buf.write("9\39\3:\3:\3;\3;\3<\3<\3=\3=\3>\3>\3?\3?\3@\3@\3A\3A\3")
        buf.write("B\3B\3C\3C\3D\3D\3E\3E\3F\3F\3G\3G\3H\3H\3I\3I\3J\3J\3")
        buf.write("K\3K\3L\3L\3M\3M\3N\3N\3O\3O\3P\3P\3Q\3Q\3R\3R\3S\3S\3")
        buf.write("T\3T\3U\3U\3V\3V\3W\3W\3X\3X\3Y\3Y\3Z\3Z\3[\3[\3\\\3\\")
        buf.write("\3]\3]\3^\3^\3_\3_\3`\3`\3a\3a\3b\3b\3c\3c\3d\3d\3e\3")
        buf.write("e\3f\3f\3g\3g\3h\3h\3i\3i\3j\3j\3k\3k\3l\3l\3m\3m\3n\3")
        buf.write("n\3o\3o\3p\3p\3q\3q\3r\3r\3s\3s\3s\3s\3s\5s\u0330\ns\3")
        buf.write("s\3s\5s\u0334\ns\3t\3t\3t\3t\3t\3t\3t\5t\u033d\nt\3u\3")
        buf.write("u\5u\u0341\nu\3v\3v\3v\3v\3v\5v\u0348\nv\3w\3w\3w\5w\u034d")
        buf.write("\nw\3w\3w\5w\u0351\nw\3x\3x\3x\3x\3x\3x\3x\5x\u035a\n")
        buf.write("x\3y\3y\3y\5y\u035f\ny\3y\3y\3y\5y\u0364\ny\3z\3z\3z\3")
        buf.write("z\7z\u036a\nz\fz\16z\u036d\13z\3{\3{\3{\5{\u0372\n{\3")
        buf.write("|\3|\3|\7|\u0377\n|\f|\16|\u037a\13|\3}\3}\3}\3}\3}\5")
        buf.write("}\u0381\n}\3~\3~\7~\u0385\n~\f~\16~\u0388\13~\3\177\3")
        buf.write("\177\3\177\3\177\7\177\u038e\n\177\f\177\16\177\u0391")
        buf.write("\13\177\5\177\u0393\n\177\3\u0080\3\u0080\3\u0080\7\u0080")
        buf.write("\u0398\n\u0080\f\u0080\16\u0080\u039b\13\u0080\3\u0081")
        buf.write("\3\u0081\3\u0081\7\u0081\u03a0\n\u0081\f\u0081\16\u0081")
        buf.write("\u03a3\13\u0081\3\u0082\3\u0082\3\u0083\7\u0083\u03a8")
        buf.write("\n\u0083\f\u0083\16\u0083\u03ab\13\u0083\3\u0084\6\u0084")
        buf.write("\u03ae\n\u0084\r\u0084\16\u0084\u03af\3\u0085\3\u0085")
        buf.write("\3\u0085\3\u0085\6\u0085\u03b6\n\u0085\r\u0085\16\u0085")
        buf.write("\u03b7\3\u0086\3\u0086\3\u0086\3\u0086\5\u0086\u03be\n")
        buf.write("\u0086\3\u0087\3\u0087\7\u0087\u03c2\n\u0087\f\u0087\16")
        buf.write("\u0087\u03c5\13\u0087\3\u0088\3\u0088\7\u0088\u03c9\n")
        buf.write("\u0088\f\u0088\16\u0088\u03cc\13\u0088\3\u0089\3\u0089")
        buf.write("\3\u0089\5\u0089\u03d1\n\u0089\3\u008a\3\u008a\3\u008a")
        buf.write("\3\u008a\7\u008a\u03d7\n\u008a\f\u008a\16\u008a\u03da")
        buf.write("\13\u008a\3\u008b\7\u008b\u03dd\n\u008b\f\u008b\16\u008b")
        buf.write("\u03e0\13\u008b\3\u008c\3\u008c\3\u008c\5\u008c\u03e5")
        buf.write("\n\u008c\3\u008c\3\u008c\3\u008d\3\u008d\6\u008d\u03eb")
        buf.write("\n\u008d\r\u008d\16\u008d\u03ec\3\u008d\3\u008d\3\u008d")
        buf.write("\3\u008d\6\u008d\u03f3\n\u008d\r\u008d\16\u008d\u03f4")
        buf.write("\3\u008e\3\u008e\3\u008e\3\u008e\3\u008e\3\u008e\3\u008e")
        buf.write("\3\u008e\3\u008e\3\u008e\3\u008e\3\u008e\3\u008e\3\u008e")
        buf.write("\3\u008e\3\u008e\3\u008e\3\u008e\3\u008e\3\u008e\3\u008e")
        buf.write("\3\u008e\3\u008e\3\u008e\3\u008e\3\u008e\3\u008e\3\u008e")
        buf.write("\5\u008e\u0413\n\u008e\3\u008e\3\u008e\3\u008e\3\u008e")
        buf.write("\3\u008e\3\u008e\3\u008e\3\u008e\3\u008e\3\u008e\3\u008e")
        buf.write("\3\u008e\3\u008e\3\u008e\5\u008e\u0423\n\u008e\3\u008e")
        buf.write("\5\u008e\u0426\n\u008e\3\u008e\3\u008e\3\u008e\3\u008e")
        buf.write("\3\u008e\3\u008e\3\u008e\3\u008e\3\u008e\3\u008e\3\u008e")
        buf.write("\3\u008e\5\u008e\u0434\n\u008e\3\u008e\3\u008e\3\u008e")
        buf.write("\5\u008e\u0439\n\u008e\3\u008e\5\u008e\u043c\n\u008e\3")
        buf.write("\u008e\3\u008e\3\u008e\3\u008e\3\u008e\3\u008e\3\u008e")
        buf.write("\3\u008e\3\u008e\3\u008e\5\u008e\u0448\n\u008e\3\u008e")
        buf.write("\3\u008e\3\u008e\5\u008e\u044d\n\u008e\3\u008e\3\u008e")
        buf.write("\3\u008e\5\u008e\u0452\n\u008e\3\u008e\5\u008e\u0455\n")
        buf.write("\u008e\3\u008e\3\u008e\3\u008e\3\u008e\3\u008e\3\u008e")
        buf.write("\3\u008e\3\u008e\5\u008e\u045f\n\u008e\3\u008e\3\u008e")
        buf.write("\3\u008e\5\u008e\u0464\n\u008e\3\u008e\3\u008e\3\u008e")
        buf.write("\5\u008e\u0469\n\u008e\3\u008e\3\u008e\3\u008e\5\u008e")
        buf.write("\u046e\n\u008e\3\u008e\5\u008e\u0471\n\u008e\3\u008e\3")
        buf.write("\u008e\3\u008e\3\u008e\3\u008e\5\u008e\u0478\n\u008e\3")
        buf.write("\u008e\3\u008e\3\u008e\5\u008e\u047d\n\u008e\3\u008e\3")
        buf.write("\u008e\3\u008e\5\u008e\u0482\n\u008e\3\u008e\3\u008e\3")
        buf.write("\u008e\5\u008e\u0487\n\u008e\3\u008e\3\u008e\3\u008e\5")
        buf.write("\u008e\u048c\n\u008e\3\u008e\5\u008e\u048f\n\u008e\3\u008e")
        buf.write("\3\u008e\3\u008e\3\u008e\3\u008e\5\u008e\u0496\n\u008e")
        buf.write("\3\u008e\3\u008e\3\u008e\5\u008e\u049b\n\u008e\3\u008e")
        buf.write("\3\u008e\3\u008e\5\u008e\u04a0\n\u008e\3\u008e\3\u008e")
        buf.write("\3\u008e\5\u008e\u04a5\n\u008e\3\u008e\3\u008e\3\u008e")
        buf.write("\5\u008e\u04aa\n\u008e\3\u008e\3\u008e\3\u008e\5\u008e")
        buf.write("\u04af\n\u008e\3\u008e\5\u008e\u04b2\n\u008e\3\u008e\5")
        buf.write("\u008e\u04b5\n\u008e\3\u008f\3\u008f\3\u008f\3\u008f\3")
        buf.write("\u008f\3\u008f\3\u008f\3\u008f\3\u008f\3\u008f\3\u008f")
        buf.write("\3\u008f\3\u008f\5\u008f\u04c4\n\u008f\3\u0090\3\u0090")
        buf.write("\3\u0090\3\u0090\3\u0090\5\u0090\u04cb\n\u0090\3\u0091")
        buf.write("\3\u0091\3\u0091\3\u0091\3\u0091\3\u0091\3\u0091\3\u0091")
        buf.write("\3\u0092\3\u0092\3\u0092\3\u0092\3\u0092\3\u0092\3\u0092")
        buf.write("\3\u0092\3\u0092\3\u0092\3\u0092\3\u0092\3\u0092\3\u0092")
        buf.write("\5\u0092\u04e3\n\u0092\3\u0093\3\u0093\3\u0093\3\u0093")
        buf.write("\3\u0094\3\u0094\3\u0094\5\u0094\u04ec\n\u0094\3\u0095")
        buf.write("\3\u0095\5\u0095\u04f0\n\u0095\3\u0096\3\u0096\3\u0097")
        buf.write("\3\u0097\3\u0098\3\u0098\3\u0099\3\u0099\5\u0099\u04fa")
        buf.write("\n\u0099\3\u009a\3\u009a\5\u009a\u04fe\n\u009a\3\u009b")
        buf.write("\3\u009b\3\u009b\3\u0267\2\u009c\2\4\6\b\n\f\16\20\22")
        buf.write("\24\26\30\32\34\36 \"$&(*,.\60\62\64\668:<>@BDFHJLNPR")
        buf.write("TVXZ\\^`bdfhjlnprtvxz|~\u0080\u0082\u0084\u0086\u0088")
        buf.write("\u008a\u008c\u008e\u0090\u0092\u0094\u0096\u0098\u009a")
        buf.write("\u009c\u009e\u00a0\u00a2\u00a4\u00a6\u00a8\u00aa\u00ac")
        buf.write("\u00ae\u00b0\u00b2\u00b4\u00b6\u00b8\u00ba\u00bc\u00be")
        buf.write("\u00c0\u00c2\u00c4\u00c6\u00c8\u00ca\u00cc\u00ce\u00d0")
        buf.write("\u00d2\u00d4\u00d6\u00d8\u00da\u00dc\u00de\u00e0\u00e2")
        buf.write("\u00e4\u00e6\u00e8\u00ea\u00ec\u00ee\u00f0\u00f2\u00f4")
        buf.write("\u00f6\u00f8\u00fa\u00fc\u00fe\u0100\u0102\u0104\u0106")
        buf.write("\u0108\u010a\u010c\u010e\u0110\u0112\u0114\u0116\u0118")
        buf.write("\u011a\u011c\u011e\u0120\u0122\u0124\u0126\u0128\u012a")
        buf.write("\u012c\u012e\u0130\u0132\u0134\2\20\4\2\u0099\u0099\u00a4")
        buf.write("\u00a4\4\2\u0096\u0096\u00ae\u00ae\4\2pp\u00a9\u00aa\3")
        buf.write("\2\u00a9\u00aa\5\2oo\u0097\u0097\u0099\u009b\5\2\u0097")
        buf.write("\u0097\u0099\u0099\u00a4\u00a4\3\2qu\3\2qv\4\2\u0097\u0097")
        buf.write("\u0099\u009b\4\2\u0096\u0096\u00a9\u00ae\4\2\u009c\u009f")
        buf.write("\u00a1\u00a7\3\2{\u0094\3\2{\u0080\3\2rz\2\u0550\2\u0139")
        buf.write("\3\2\2\2\4\u014e\3\2\2\2\6\u017e\3\2\2\2\b\u01ab\3\2\2")
        buf.write("\2\n\u01ad\3\2\2\2\f\u01b1\3\2\2\2\16\u01b5\3\2\2\2\20")
        buf.write("\u01b9\3\2\2\2\22\u01bb\3\2\2\2\24\u01bf\3\2\2\2\26\u01ce")
        buf.write("\3\2\2\2\30\u01db\3\2\2\2\32\u01f2\3\2\2\2\34\u023e\3")
        buf.write("\2\2\2\36\u0240\3\2\2\2 \u025b\3\2\2\2\"\u025d\3\2\2\2")
        buf.write("$\u0263\3\2\2\2&\u026c\3\2\2\2(\u026e\3\2\2\2*\u0270\3")
        buf.write("\2\2\2,\u0272\3\2\2\2.\u0274\3\2\2\2\60\u0276\3\2\2\2")
        buf.write("\62\u0278\3\2\2\2\64\u027a\3\2\2\2\66\u027c\3\2\2\28\u027e")
        buf.write("\3\2\2\2:\u0280\3\2\2\2<\u0282\3\2\2\2>\u0284\3\2\2\2")
        buf.write("@\u0286\3\2\2\2B\u0288\3\2\2\2D\u028a\3\2\2\2F\u028c\3")
        buf.write("\2\2\2H\u028e\3\2\2\2J\u0290\3\2\2\2L\u0292\3\2\2\2N\u0294")
        buf.write("\3\2\2\2P\u0296\3\2\2\2R\u0298\3\2\2\2T\u029a\3\2\2\2")
        buf.write("V\u029c\3\2\2\2X\u029e\3\2\2\2Z\u02a0\3\2\2\2\\\u02a2")
        buf.write("\3\2\2\2^\u02a4\3\2\2\2`\u02a6\3\2\2\2b\u02a8\3\2\2\2")
        buf.write("d\u02aa\3\2\2\2f\u02ac\3\2\2\2h\u02ae\3\2\2\2j\u02b0\3")
        buf.write("\2\2\2l\u02b2\3\2\2\2n\u02b4\3\2\2\2p\u02b6\3\2\2\2r\u02b8")
        buf.write("\3\2\2\2t\u02ba\3\2\2\2v\u02bc\3\2\2\2x\u02be\3\2\2\2")
        buf.write("z\u02c0\3\2\2\2|\u02c2\3\2\2\2~\u02c4\3\2\2\2\u0080\u02c6")
        buf.write("\3\2\2\2\u0082\u02c8\3\2\2\2\u0084\u02ca\3\2\2\2\u0086")
        buf.write("\u02cc\3\2\2\2\u0088\u02ce\3\2\2\2\u008a\u02d0\3\2\2\2")
        buf.write("\u008c\u02d2\3\2\2\2\u008e\u02d4\3\2\2\2\u0090\u02d6\3")
        buf.write("\2\2\2\u0092\u02d8\3\2\2\2\u0094\u02da\3\2\2\2\u0096\u02dc")
        buf.write("\3\2\2\2\u0098\u02de\3\2\2\2\u009a\u02e0\3\2\2\2\u009c")
        buf.write("\u02e2\3\2\2\2\u009e\u02e4\3\2\2\2\u00a0\u02e6\3\2\2\2")
        buf.write("\u00a2\u02e8\3\2\2\2\u00a4\u02ea\3\2\2\2\u00a6\u02ec\3")
        buf.write("\2\2\2\u00a8\u02ee\3\2\2\2\u00aa\u02f0\3\2\2\2\u00ac\u02f2")
        buf.write("\3\2\2\2\u00ae\u02f4\3\2\2\2\u00b0\u02f6\3\2\2\2\u00b2")
        buf.write("\u02f8\3\2\2\2\u00b4\u02fa\3\2\2\2\u00b6\u02fc\3\2\2\2")
        buf.write("\u00b8\u02fe\3\2\2\2\u00ba\u0300\3\2\2\2\u00bc\u0302\3")
        buf.write("\2\2\2\u00be\u0304\3\2\2\2\u00c0\u0306\3\2\2\2\u00c2\u0308")
        buf.write("\3\2\2\2\u00c4\u030a\3\2\2\2\u00c6\u030c\3\2\2\2\u00c8")
        buf.write("\u030e\3\2\2\2\u00ca\u0310\3\2\2\2\u00cc\u0312\3\2\2\2")
        buf.write("\u00ce\u0314\3\2\2\2\u00d0\u0316\3\2\2\2\u00d2\u0318\3")
        buf.write("\2\2\2\u00d4\u031a\3\2\2\2\u00d6\u031c\3\2\2\2\u00d8\u031e")
        buf.write("\3\2\2\2\u00da\u0320\3\2\2\2\u00dc\u0322\3\2\2\2\u00de")
        buf.write("\u0324\3\2\2\2\u00e0\u0326\3\2\2\2\u00e2\u0328\3\2\2\2")
        buf.write("\u00e4\u032a\3\2\2\2\u00e6\u033c\3\2\2\2\u00e8\u0340\3")
        buf.write("\2\2\2\u00ea\u0342\3\2\2\2\u00ec\u0349\3\2\2\2\u00ee\u0359")
        buf.write("\3\2\2\2\u00f0\u035e\3\2\2\2\u00f2\u036b\3\2\2\2\u00f4")
        buf.write("\u0371\3\2\2\2\u00f6\u0378\3\2\2\2\u00f8\u0380\3\2\2\2")
        buf.write("\u00fa\u0386\3\2\2\2\u00fc\u0389\3\2\2\2\u00fe\u0394\3")
        buf.write("\2\2\2\u0100\u039c\3\2\2\2\u0102\u03a4\3\2\2\2\u0104\u03a9")
        buf.write("\3\2\2\2\u0106\u03ad\3\2\2\2\u0108\u03b5\3\2\2\2\u010a")
        buf.write("\u03bd\3\2\2\2\u010c\u03c3\3\2\2\2\u010e\u03ca\3\2\2\2")
        buf.write("\u0110\u03d0\3\2\2\2\u0112\u03d2\3\2\2\2\u0114\u03de\3")
        buf.write("\2\2\2\u0116\u03e1\3\2\2\2\u0118\u03e8\3\2\2\2\u011a\u04b4")
        buf.write("\3\2\2\2\u011c\u04c3\3\2\2\2\u011e\u04ca\3\2\2\2\u0120")
        buf.write("\u04cc\3\2\2\2\u0122\u04e2\3\2\2\2\u0124\u04e4\3\2\2\2")
        buf.write("\u0126\u04eb\3\2\2\2\u0128\u04ef\3\2\2\2\u012a\u04f1\3")
        buf.write("\2\2\2\u012c\u04f3\3\2\2\2\u012e\u04f5\3\2\2\2\u0130\u04f9")
        buf.write("\3\2\2\2\u0132\u04fd\3\2\2\2\u0134\u04ff\3\2\2\2\u0136")
        buf.write("\u0138\5\20\t\2\u0137\u0136\3\2\2\2\u0138\u013b\3\2\2")
        buf.write("\2\u0139\u0137\3\2\2\2\u0139\u013a\3\2\2\2\u013a\u0140")
        buf.write("\3\2\2\2\u013b\u0139\3\2\2\2\u013c\u013f\5\4\3\2\u013d")
        buf.write("\u013f\5\6\4\2\u013e\u013c\3\2\2\2\u013e\u013d\3\2\2\2")
        buf.write("\u013f\u0142\3\2\2\2\u0140\u013e\3\2\2\2\u0140\u0141\3")
        buf.write("\2\2\2\u0141\u0146\3\2\2\2\u0142\u0140\3\2\2\2\u0143\u0145")
        buf.write("\5\20\t\2\u0144\u0143\3\2\2\2\u0145\u0148\3\2\2\2\u0146")
        buf.write("\u0144\3\2\2\2\u0146\u0147\3\2\2\2\u0147\u0149\3\2\2\2")
        buf.write("\u0148\u0146\3\2\2\2\u0149\u014a\7\2\2\3\u014a\3\3\2\2")
        buf.write("\2\u014b\u014d\5\20\t\2\u014c\u014b\3\2\2\2\u014d\u0150")
        buf.write("\3\2\2\2\u014e\u014c\3\2\2\2\u014e\u014f\3\2\2\2\u014f")
        buf.write("\u0151\3\2\2\2\u0150\u014e\3\2\2\2\u0151\u0155\7\4\2\2")
        buf.write("\u0152\u0154\5\20\t\2\u0153\u0152\3\2\2\2\u0154\u0157")
        buf.write("\3\2\2\2\u0155\u0153\3\2\2\2\u0155\u0156\3\2\2\2\u0156")
        buf.write("\u0158\3\2\2\2\u0157\u0155\3\2\2\2\u0158\u015c\5\b\5\2")
        buf.write("\u0159\u015b\5\20\t\2\u015a\u0159\3\2\2\2\u015b\u015e")
        buf.write("\3\2\2\2\u015c\u015a\3\2\2\2\u015c\u015d\3\2\2\2\u015d")
        buf.write("\u015f\3\2\2\2\u015e\u015c\3\2\2\2\u015f\u0163\5\n\6\2")
        buf.write("\u0160\u0162\5\20\t\2\u0161\u0160\3\2\2\2\u0162\u0165")
        buf.write("\3\2\2\2\u0163\u0161\3\2\2\2\u0163\u0164\3\2\2\2\u0164")
        buf.write("\u0166\3\2\2\2\u0165\u0163\3\2\2\2\u0166\u016a\5\f\7\2")
        buf.write("\u0167\u0169\5\20\t\2\u0168\u0167\3\2\2\2\u0169\u016c")
        buf.write("\3\2\2\2\u016a\u0168\3\2\2\2\u016a\u016b\3\2\2\2\u016b")
        buf.write("\u016d\3\2\2\2\u016c\u016a\3\2\2\2\u016d\u0171\5\16\b")
        buf.write("\2\u016e\u0170\5\20\t\2\u016f\u016e\3\2\2\2\u0170\u0173")
        buf.write("\3\2\2\2\u0171\u016f\3\2\2\2\u0171\u0172\3\2\2\2\u0172")
        buf.write("\u0174\3\2\2\2\u0173\u0171\3\2\2\2\u0174\u0178\7\5\2\2")
        buf.write("\u0175\u0177\5\20\t\2\u0176\u0175\3\2\2\2\u0177\u017a")
        buf.write("\3\2\2\2\u0178\u0176\3\2\2\2\u0178\u0179\3\2\2\2\u0179")
        buf.write("\5\3\2\2\2\u017a\u0178\3\2\2\2\u017b\u017d\5\20\t\2\u017c")
        buf.write("\u017b\3\2\2\2\u017d\u0180\3\2\2\2\u017e\u017c\3\2\2\2")
        buf.write("\u017e\u017f\3\2\2\2\u017f\u0181\3\2\2\2\u0180\u017e\3")
        buf.write("\2\2\2\u0181\u0185\7\4\2\2\u0182\u0184\5\20\t\2\u0183")
        buf.write("\u0182\3\2\2\2\u0184\u0187\3\2\2\2\u0185\u0183\3\2\2\2")
        buf.write("\u0185\u0186\3\2\2\2\u0186\u0188\3\2\2\2\u0187\u0185\3")
        buf.write("\2\2\2\u0188\u018c\5\b\5\2\u0189\u018b\5\20\t\2\u018a")
        buf.write("\u0189\3\2\2\2\u018b\u018e\3\2\2\2\u018c\u018a\3\2\2\2")
        buf.write("\u018c\u018d\3\2\2\2\u018d\u018f\3\2\2\2\u018e\u018c\3")
        buf.write("\2\2\2\u018f\u0193\5\n\6\2\u0190\u0192\5\20\t\2\u0191")
        buf.write("\u0190\3\2\2\2\u0192\u0195\3\2\2\2\u0193\u0191\3\2\2\2")
        buf.write("\u0193\u0194\3\2\2\2\u0194\u0196\3\2\2\2\u0195\u0193\3")
        buf.write("\2\2\2\u0196\u019a\5\22\n\2\u0197\u0199\5\20\t\2\u0198")
        buf.write("\u0197\3\2\2\2\u0199\u019c\3\2\2\2\u019a\u0198\3\2\2\2")
        buf.write("\u019a\u019b\3\2\2\2\u019b\u019d\3\2\2\2\u019c\u019a\3")
        buf.write("\2\2\2\u019d\u01a1\5$\23\2\u019e\u01a0\5\20\t\2\u019f")
        buf.write("\u019e\3\2\2\2\u01a0\u01a3\3\2\2\2\u01a1\u019f\3\2\2\2")
        buf.write("\u01a1\u01a2\3\2\2\2\u01a2\u01a4\3\2\2\2\u01a3\u01a1\3")
        buf.write("\2\2\2\u01a4\u01a8\7\5\2\2\u01a5\u01a7\5\20\t\2\u01a6")
        buf.write("\u01a5\3\2\2\2\u01a7\u01aa\3\2\2\2\u01a8\u01a6\3\2\2\2")
        buf.write("\u01a8\u01a9\3\2\2\2\u01a9\7\3\2\2\2\u01aa\u01a8\3\2\2")
        buf.write("\2\u01ab\u01ac\7\13\2\2\u01ac\t\3\2\2\2\u01ad\u01ae\7")
        buf.write("\b\2\2\u01ae\u01af\5\26\f\2\u01af\u01b0\7\t\2\2\u01b0")
        buf.write("\13\3\2\2\2\u01b1\u01b2\7\b\2\2\u01b2\u01b3\5\34\17\2")
        buf.write("\u01b3\u01b4\7\t\2\2\u01b4\r\3\2\2\2\u01b5\u01b6\7\b\2")
        buf.write("\2\u01b6\u01b7\5\30\r\2\u01b7\u01b8\7\t\2\2\u01b8\17\3")
        buf.write("\2\2\2\u01b9\u01ba\7\3\2\2\u01ba\21\3\2\2\2\u01bb\u01bc")
        buf.write("\7\b\2\2\u01bc\u01bd\5\32\16\2\u01bd\u01be\7\t\2\2\u01be")
        buf.write("\23\3\2\2\2\u01bf\u01c0\7\u0088\2\2\u01c0\u01c1\5\u0132")
        buf.write("\u009a\2\u01c1\u01c2\5\u0132\u009a\2\u01c2\u01c3\5\u0132")
        buf.write("\u009a\2\u01c3\u01c4\5\u0132\u009a\2\u01c4\u01c5\5\u0132")
        buf.write("\u009a\2\u01c5\25\3\2\2\2\u01c6\u01cf\5\u00e4s\2\u01c7")
        buf.write("\u01cf\5\24\13\2\u01c8\u01ca\5\u0126\u0094\2\u01c9\u01c8")
        buf.write("\3\2\2\2\u01ca\u01cd\3\2\2\2\u01cb\u01c9\3\2\2\2\u01cb")
        buf.write("\u01cc\3\2\2\2\u01cc\u01cf\3\2\2\2\u01cd\u01cb\3\2\2\2")
        buf.write("\u01ce\u01c6\3\2\2\2\u01ce\u01c7\3\2\2\2\u01ce\u01cb\3")
        buf.write("\2\2\2\u01cf\27\3\2\2\2\u01d0\u01dc\5\u00e4s\2\u01d1\u01dc")
        buf.write("\5\24\13\2\u01d2\u01dc\5\34\17\2\u01d3\u01dc\5\36\20\2")
        buf.write("\u01d4\u01dc\5p9\2\u01d5\u01d7\5\u0126\u0094\2\u01d6\u01d5")
        buf.write("\3\2\2\2\u01d7\u01da\3\2\2\2\u01d8\u01d6\3\2\2\2\u01d8")
        buf.write("\u01d9\3\2\2\2\u01d9\u01dc\3\2\2\2\u01da\u01d8\3\2\2\2")
        buf.write("\u01db\u01d0\3\2\2\2\u01db\u01d1\3\2\2\2\u01db\u01d2\3")
        buf.write("\2\2\2\u01db\u01d3\3\2\2\2\u01db\u01d4\3\2\2\2\u01db\u01d8")
        buf.write("\3\2\2\2\u01dc\31\3\2\2\2\u01dd\u01f3\5&\24\2\u01de\u01f3")
        buf.write("\5(\25\2\u01df\u01f3\5*\26\2\u01e0\u01f3\5,\27\2\u01e1")
        buf.write("\u01f3\5.\30\2\u01e2\u01f3\5\60\31\2\u01e3\u01f3\5\62")
        buf.write("\32\2\u01e4\u01f3\5\64\33\2\u01e5\u01f3\5\66\34\2\u01e6")
        buf.write("\u01f3\58\35\2\u01e7\u01f3\5:\36\2\u01e8\u01f3\5<\37\2")
        buf.write("\u01e9\u01f3\5> \2\u01ea\u01f3\5@!\2\u01eb\u01f3\5B\"")
        buf.write("\2\u01ec\u01f3\5D#\2\u01ed\u01f3\5F$\2\u01ee\u01f3\5H")
        buf.write("%\2\u01ef\u01f3\5J&\2\u01f0\u01f3\5L\'\2\u01f1\u01f3\5")
        buf.write("N(\2\u01f2\u01dd\3\2\2\2\u01f2\u01de\3\2\2\2\u01f2\u01df")
        buf.write("\3\2\2\2\u01f2\u01e0\3\2\2\2\u01f2\u01e1\3\2\2\2\u01f2")
        buf.write("\u01e2\3\2\2\2\u01f2\u01e3\3\2\2\2\u01f2\u01e4\3\2\2\2")
        buf.write("\u01f2\u01e5\3\2\2\2\u01f2\u01e6\3\2\2\2\u01f2\u01e7\3")
        buf.write("\2\2\2\u01f2\u01e8\3\2\2\2\u01f2\u01e9\3\2\2\2\u01f2\u01ea")
        buf.write("\3\2\2\2\u01f2\u01eb\3\2\2\2\u01f2\u01ec\3\2\2\2\u01f2")
        buf.write("\u01ed\3\2\2\2\u01f2\u01ee\3\2\2\2\u01f2\u01ef\3\2\2\2")
        buf.write("\u01f2\u01f0\3\2\2\2\u01f2\u01f1\3\2\2\2\u01f3\33\3\2")
        buf.write("\2\2\u01f4\u023f\5T+\2\u01f5\u023f\5V,\2\u01f6\u023f\5")
        buf.write("X-\2\u01f7\u023f\5Z.\2\u01f8\u023f\5P)\2\u01f9\u023f\5")
        buf.write("R*\2\u01fa\u023f\5\\/\2\u01fb\u023f\5^\60\2\u01fc\u023f")
        buf.write("\5`\61\2\u01fd\u023f\5b\62\2\u01fe\u023f\5d\63\2\u01ff")
        buf.write("\u023f\5f\64\2\u0200\u023f\5h\65\2\u0201\u023f\5j\66\2")
        buf.write("\u0202\u023f\5r:\2\u0203\u023f\5l\67\2\u0204\u023f\5n")
        buf.write("8\2\u0205\u023f\5\"\22\2\u0206\u023f\5t;\2\u0207\u023f")
        buf.write("\5x=\2\u0208\u023f\5v<\2\u0209\u023f\5z>\2\u020a\u023f")
        buf.write("\5|?\2\u020b\u023f\5~@\2\u020c\u023f\5\u0080A\2\u020d")
        buf.write("\u023f\5\u0082B\2\u020e\u023f\5\u0084C\2\u020f\u023f\5")
        buf.write("\u0086D\2\u0210\u023f\5\u0088E\2\u0211\u023f\5\u008aF")
        buf.write("\2\u0212\u023f\5\u008cG\2\u0213\u023f\5\u008eH\2\u0214")
        buf.write("\u023f\5\u0090I\2\u0215\u023f\5\u0092J\2\u0216\u023f\5")
        buf.write("\u0094K\2\u0217\u023f\5\u0096L\2\u0218\u023f\5\u0098M")
        buf.write("\2\u0219\u023f\5\u009aN\2\u021a\u023f\5\u009cO\2\u021b")
        buf.write("\u023f\5\u009eP\2\u021c\u023f\5\u00a0Q\2\u021d\u023f\5")
        buf.write("\u00a2R\2\u021e\u023f\5\u00a4S\2\u021f\u023f\5\u00a6T")
        buf.write("\2\u0220\u023f\5\u00a8U\2\u0221\u023f\5\u00aaV\2\u0222")
        buf.write("\u023f\5\u00acW\2\u0223\u023f\5\u00aeX\2\u0224\u023f\5")
        buf.write("\u00b0Y\2\u0225\u023f\5\u00b2Z\2\u0226\u023f\5\u00b4[")
        buf.write("\2\u0227\u023f\5\u00b6\\\2\u0228\u023f\5\u00b8]\2\u0229")
        buf.write("\u023f\5\u00ba^\2\u022a\u023f\5\u00bc_\2\u022b\u023f\5")
        buf.write("\u00be`\2\u022c\u023f\5\u00c0a\2\u022d\u023f\5\u00c2b")
        buf.write("\2\u022e\u023f\5\u00c4c\2\u022f\u023f\5\u00c6d\2\u0230")
        buf.write("\u023f\5\u00c8e\2\u0231\u023f\5\u00caf\2\u0232\u023f\5")
        buf.write("\u00ccg\2\u0233\u023f\5\u00ceh\2\u0234\u023f\5\u00d0i")
        buf.write("\2\u0235\u023f\5\u00d2j\2\u0236\u023f\5\u00d4k\2\u0237")
        buf.write("\u023f\5\u00d6l\2\u0238\u023f\5\u00d8m\2\u0239\u023f\5")
        buf.write("\u00dan\2\u023a\u023f\5\u00dco\2\u023b\u023f\5\u00dep")
        buf.write("\2\u023c\u023f\5\u00e0q\2\u023d\u023f\5\u00e2r\2\u023e")
        buf.write("\u01f4\3\2\2\2\u023e\u01f5\3\2\2\2\u023e\u01f6\3\2\2\2")
        buf.write("\u023e\u01f7\3\2\2\2\u023e\u01f8\3\2\2\2\u023e\u01f9\3")
        buf.write("\2\2\2\u023e\u01fa\3\2\2\2\u023e\u01fb\3\2\2\2\u023e\u01fc")
        buf.write("\3\2\2\2\u023e\u01fd\3\2\2\2\u023e\u01fe\3\2\2\2\u023e")
        buf.write("\u01ff\3\2\2\2\u023e\u0200\3\2\2\2\u023e\u0201\3\2\2\2")
        buf.write("\u023e\u0202\3\2\2\2\u023e\u0203\3\2\2\2\u023e\u0204\3")
        buf.write("\2\2\2\u023e\u0205\3\2\2\2\u023e\u0206\3\2\2\2\u023e\u0207")
        buf.write("\3\2\2\2\u023e\u0208\3\2\2\2\u023e\u0209\3\2\2\2\u023e")
        buf.write("\u020a\3\2\2\2\u023e\u020b\3\2\2\2\u023e\u020c\3\2\2\2")
        buf.write("\u023e\u020d\3\2\2\2\u023e\u020e\3\2\2\2\u023e\u020f\3")
        buf.write("\2\2\2\u023e\u0210\3\2\2\2\u023e\u0211\3\2\2\2\u023e\u0212")
        buf.write("\3\2\2\2\u023e\u0213\3\2\2\2\u023e\u0214\3\2\2\2\u023e")
        buf.write("\u0215\3\2\2\2\u023e\u0216\3\2\2\2\u023e\u0217\3\2\2\2")
        buf.write("\u023e\u0218\3\2\2\2\u023e\u0219\3\2\2\2\u023e\u021a\3")
        buf.write("\2\2\2\u023e\u021b\3\2\2\2\u023e\u021c\3\2\2\2\u023e\u021d")
        buf.write("\3\2\2\2\u023e\u021e\3\2\2\2\u023e\u021f\3\2\2\2\u023e")
        buf.write("\u0220\3\2\2\2\u023e\u0221\3\2\2\2\u023e\u0222\3\2\2\2")
        buf.write("\u023e\u0223\3\2\2\2\u023e\u0224\3\2\2\2\u023e\u0225\3")
        buf.write("\2\2\2\u023e\u0226\3\2\2\2\u023e\u0227\3\2\2\2\u023e\u0228")
        buf.write("\3\2\2\2\u023e\u0229\3\2\2\2\u023e\u022a\3\2\2\2\u023e")
        buf.write("\u022b\3\2\2\2\u023e\u022c\3\2\2\2\u023e\u022d\3\2\2\2")
        buf.write("\u023e\u022e\3\2\2\2\u023e\u022f\3\2\2\2\u023e\u0230\3")
        buf.write("\2\2\2\u023e\u0231\3\2\2\2\u023e\u0232\3\2\2\2\u023e\u0233")
        buf.write("\3\2\2\2\u023e\u0234\3\2\2\2\u023e\u0235\3\2\2\2\u023e")
        buf.write("\u0236\3\2\2\2\u023e\u0237\3\2\2\2\u023e\u0238\3\2\2\2")
        buf.write("\u023e\u0239\3\2\2\2\u023e\u023a\3\2\2\2\u023e\u023b\3")
        buf.write("\2\2\2\u023e\u023c\3\2\2\2\u023e\u023d\3\2\2\2\u023f\35")
        buf.write("\3\2\2\2\u0240\u0241\5 \21\2\u0241\u0242\7n\2\2\u0242")
        buf.write("\u0243\7n\2\2\u0243\u0244\5\"\22\2\u0244\37\3\2\2\2\u0245")
        buf.write("\u0247\t\2\2\2\u0246\u0245\3\2\2\2\u0247\u024a\3\2\2\2")
        buf.write("\u0248\u0246\3\2\2\2\u0248\u0249\3\2\2\2\u0249\u024c\3")
        buf.write("\2\2\2\u024a\u0248\3\2\2\2\u024b\u024d\5\u0132\u009a\2")
        buf.write("\u024c\u024b\3\2\2\2\u024d\u024e\3\2\2\2\u024e\u024c\3")
        buf.write("\2\2\2\u024e\u024f\3\2\2\2\u024f\u0251\3\2\2\2\u0250\u0252")
        buf.write("\7\u0097\2\2\u0251\u0250\3\2\2\2\u0251\u0252\3\2\2\2\u0252")
        buf.write("\u0256\3\2\2\2\u0253\u0255\5\u0132\u009a\2\u0254\u0253")
        buf.write("\3\2\2\2\u0255\u0258\3\2\2\2\u0256\u0254\3\2\2\2\u0256")
        buf.write("\u0257\3\2\2\2\u0257\u025c\3\2\2\2\u0258\u0256\3\2\2\2")
        buf.write("\u0259\u025c\7;\2\2\u025a\u025c\7<\2\2\u025b\u0248\3\2")
        buf.write("\2\2\u025b\u0259\3\2\2\2\u025b\u025a\3\2\2\2\u025c!\3")
        buf.write("\2\2\2\u025d\u025f\7#\2\2\u025e\u0260\5\u012e\u0098\2")
        buf.write("\u025f\u025e\3\2\2\2\u0260\u0261\3\2\2\2\u0261\u025f\3")
        buf.write("\2\2\2\u0261\u0262\3\2\2\2\u0262#\3\2\2\2\u0263\u0267")
        buf.write("\7\b\2\2\u0264\u0266\13\2\2\2\u0265\u0264\3\2\2\2\u0266")
        buf.write("\u0269\3\2\2\2\u0267\u0268\3\2\2\2\u0267\u0265\3\2\2\2")
        buf.write("\u0268\u026a\3\2\2\2\u0269\u0267\3\2\2\2\u026a\u026b\7")
        buf.write("\t\2\2\u026b%\3\2\2\2\u026c\u026d\7\35\2\2\u026d\'\3\2")
        buf.write("\2\2\u026e\u026f\7\36\2\2\u026f)\3\2\2\2\u0270\u0271\7")
        buf.write("\37\2\2\u0271+\3\2\2\2\u0272\u0273\7\f\2\2\u0273-\3\2")
        buf.write("\2\2\u0274\u0275\7\34\2\2\u0275/\3\2\2\2\u0276\u0277\7")
        buf.write("+\2\2\u0277\61\3\2\2\2\u0278\u0279\7\66\2\2\u0279\63\3")
        buf.write("\2\2\2\u027a\u027b\7\67\2\2\u027b\65\3\2\2\2\u027c\u027d")
        buf.write("\78\2\2\u027d\67\3\2\2\2\u027e\u027f\79\2\2\u027f9\3\2")
        buf.write("\2\2\u0280\u0281\7:\2\2\u0281;\3\2\2\2\u0282\u0283\7^")
        buf.write("\2\2\u0283=\3\2\2\2\u0284\u0285\7_\2\2\u0285?\3\2\2\2")
        buf.write("\u0286\u0287\7`\2\2\u0287A\3\2\2\2\u0288\u0289\7b\2\2")
        buf.write("\u0289C\3\2\2\2\u028a\u028b\7c\2\2\u028bE\3\2\2\2\u028c")
        buf.write("\u028d\7d\2\2\u028dG\3\2\2\2\u028e\u028f\7e\2\2\u028f")
        buf.write("I\3\2\2\2\u0290\u0291\7f\2\2\u0291K\3\2\2\2\u0292\u0293")
        buf.write("\7g\2\2\u0293M\3\2\2\2\u0294\u0295\7 \2\2\u0295O\3\2\2")
        buf.write("\2\u0296\u0297\7\31\2\2\u0297Q\3\2\2\2\u0298\u0299\7\24")
        buf.write("\2\2\u0299S\3\2\2\2\u029a\u029b\7\r\2\2\u029bU\3\2\2\2")
        buf.write("\u029c\u029d\7\16\2\2\u029dW\3\2\2\2\u029e\u029f\7\17")
        buf.write("\2\2\u029fY\3\2\2\2\u02a0\u02a1\7\20\2\2\u02a1[\3\2\2")
        buf.write("\2\u02a2\u02a3\7\21\2\2\u02a3]\3\2\2\2\u02a4\u02a5\7\22")
        buf.write("\2\2\u02a5_\3\2\2\2\u02a6\u02a7\7\23\2\2\u02a7a\3\2\2")
        buf.write("\2\u02a8\u02a9\7\25\2\2\u02a9c\3\2\2\2\u02aa\u02ab\7\26")
        buf.write("\2\2\u02abe\3\2\2\2\u02ac\u02ad\7\27\2\2\u02adg\3\2\2")
        buf.write("\2\u02ae\u02af\7\30\2\2\u02afi\3\2\2\2\u02b0\u02b1\7\32")
        buf.write("\2\2\u02b1k\3\2\2\2\u02b2\u02b3\7!\2\2\u02b3m\3\2\2\2")
        buf.write("\u02b4\u02b5\7\"\2\2\u02b5o\3\2\2\2\u02b6\u02b7\7$\2\2")
        buf.write("\u02b7q\3\2\2\2\u02b8\u02b9\7%\2\2\u02b9s\3\2\2\2\u02ba")
        buf.write("\u02bb\7&\2\2\u02bbu\3\2\2\2\u02bc\u02bd\7(\2\2\u02bd")
        buf.write("w\3\2\2\2\u02be\u02bf\7\'\2\2\u02bfy\3\2\2\2\u02c0\u02c1")
        buf.write("\7)\2\2\u02c1{\3\2\2\2\u02c2\u02c3\7*\2\2\u02c3}\3\2\2")
        buf.write("\2\u02c4\u02c5\7,\2\2\u02c5\177\3\2\2\2\u02c6\u02c7\7")
        buf.write("-\2\2\u02c7\u0081\3\2\2\2\u02c8\u02c9\7.\2\2\u02c9\u0083")
        buf.write("\3\2\2\2\u02ca\u02cb\7\33\2\2\u02cb\u0085\3\2\2\2\u02cc")
        buf.write("\u02cd\7/\2\2\u02cd\u0087\3\2\2\2\u02ce\u02cf\7\60\2\2")
        buf.write("\u02cf\u0089\3\2\2\2\u02d0\u02d1\7\61\2\2\u02d1\u008b")
        buf.write("\3\2\2\2\u02d2\u02d3\7\62\2\2\u02d3\u008d\3\2\2\2\u02d4")
        buf.write("\u02d5\7\63\2\2\u02d5\u008f\3\2\2\2\u02d6\u02d7\7\64\2")
        buf.write("\2\u02d7\u0091\3\2\2\2\u02d8\u02d9\7\65\2\2\u02d9\u0093")
        buf.write("\3\2\2\2\u02da\u02db\7=\2\2\u02db\u0095\3\2\2\2\u02dc")
        buf.write("\u02dd\7>\2\2\u02dd\u0097\3\2\2\2\u02de\u02df\7?\2\2\u02df")
        buf.write("\u0099\3\2\2\2\u02e0\u02e1\7@\2\2\u02e1\u009b\3\2\2\2")
        buf.write("\u02e2\u02e3\7A\2\2\u02e3\u009d\3\2\2\2\u02e4\u02e5\7")
        buf.write("B\2\2\u02e5\u009f\3\2\2\2\u02e6\u02e7\7C\2\2\u02e7\u00a1")
        buf.write("\3\2\2\2\u02e8\u02e9\7D\2\2\u02e9\u00a3\3\2\2\2\u02ea")
        buf.write("\u02eb\7E\2\2\u02eb\u00a5\3\2\2\2\u02ec\u02ed\7F\2\2\u02ed")
        buf.write("\u00a7\3\2\2\2\u02ee\u02ef\7G\2\2\u02ef\u00a9\3\2\2\2")
        buf.write("\u02f0\u02f1\7H\2\2\u02f1\u00ab\3\2\2\2\u02f2\u02f3\7")
        buf.write("I\2\2\u02f3\u00ad\3\2\2\2\u02f4\u02f5\7J\2\2\u02f5\u00af")
        buf.write("\3\2\2\2\u02f6\u02f7\7K\2\2\u02f7\u00b1\3\2\2\2\u02f8")
        buf.write("\u02f9\7L\2\2\u02f9\u00b3\3\2\2\2\u02fa\u02fb\7M\2\2\u02fb")
        buf.write("\u00b5\3\2\2\2\u02fc\u02fd\7N\2\2\u02fd\u00b7\3\2\2\2")
        buf.write("\u02fe\u02ff\7O\2\2\u02ff\u00b9\3\2\2\2\u0300\u0301\7")
        buf.write("P\2\2\u0301\u00bb\3\2\2\2\u0302\u0303\7Q\2\2\u0303\u00bd")
        buf.write("\3\2\2\2\u0304\u0305\7R\2\2\u0305\u00bf\3\2\2\2\u0306")
        buf.write("\u0307\7S\2\2\u0307\u00c1\3\2\2\2\u0308\u0309\7T\2\2\u0309")
        buf.write("\u00c3\3\2\2\2\u030a\u030b\7U\2\2\u030b\u00c5\3\2\2\2")
        buf.write("\u030c\u030d\7V\2\2\u030d\u00c7\3\2\2\2\u030e\u030f\7")
        buf.write("W\2\2\u030f\u00c9\3\2\2\2\u0310\u0311\7X\2\2\u0311\u00cb")
        buf.write("\3\2\2\2\u0312\u0313\7Y\2\2\u0313\u00cd\3\2\2\2\u0314")
        buf.write("\u0315\7Z\2\2\u0315\u00cf\3\2\2\2\u0316\u0317\7[\2\2\u0317")
        buf.write("\u00d1\3\2\2\2\u0318\u0319\7\\\2\2\u0319\u00d3\3\2\2\2")
        buf.write("\u031a\u031b\7]\2\2\u031b\u00d5\3\2\2\2\u031c\u031d\7")
        buf.write("a\2\2\u031d\u00d7\3\2\2\2\u031e\u031f\7h\2\2\u031f\u00d9")
        buf.write("\3\2\2\2\u0320\u0321\7i\2\2\u0321\u00db\3\2\2\2\u0322")
        buf.write("\u0323\7j\2\2\u0323\u00dd\3\2\2\2\u0324\u0325\7k\2\2\u0325")
        buf.write("\u00df\3\2\2\2\u0326\u0327\7l\2\2\u0327\u00e1\3\2\2\2")
        buf.write("\u0328\u0329\7m\2\2\u0329\u00e3\3\2\2\2\u032a\u032b\5")
        buf.write("\u0112\u008a\2\u032b\u032c\7\u0096\2\2\u032c\u032f\5\u00e6")
        buf.write("t\2\u032d\u032e\7\u00aa\2\2\u032e\u0330\5\u010c\u0087")
        buf.write("\2\u032f\u032d\3\2\2\2\u032f\u0330\3\2\2\2\u0330\u0333")
        buf.write("\3\2\2\2\u0331\u0332\7\u00ab\2\2\u0332\u0334\5\u010e\u0088")
        buf.write("\2\u0333\u0331\3\2\2\2\u0333\u0334\3\2\2\2\u0334\u00e5")
        buf.write("\3\2\2\2\u0335\u0336\7\u00a8\2\2\u0336\u0337\5\u00f0y")
        buf.write("\2\u0337\u0338\5\u00fa~\2\u0338\u033d\3\2\2\2\u0339\u033d")
        buf.write("\5\u00fc\177\2\u033a\u033d\5\u0100\u0081\2\u033b\u033d")
        buf.write("\5\u0102\u0082\2\u033c\u0335\3\2\2\2\u033c\u0339\3\2\2")
        buf.write("\2\u033c\u033a\3\2\2\2\u033c\u033b\3\2\2\2\u033d\u00e7")
        buf.write("\3\2\2\2\u033e\u0341\5\u00e4s\2\u033f\u0341\5\u00ecw\2")
        buf.write("\u0340\u033e\3\2\2\2\u0340\u033f\3\2\2\2\u0341\u00e9\3")
        buf.write("\2\2\2\u0342\u0343\5\u0112\u008a\2\u0343\u0344\7\u0096")
        buf.write("\2\2\u0344\u0347\5\u00e6t\2\u0345\u0346\7\u00aa\2\2\u0346")
        buf.write("\u0348\5\u010c\u0087\2\u0347\u0345\3\2\2\2\u0347\u0348")
        buf.write("\3\2\2\2\u0348\u00eb\3\2\2\2\u0349\u034c\5\u00eex\2\u034a")
        buf.write("\u034b\7\u00aa\2\2\u034b\u034d\5\u010c\u0087\2\u034c\u034a")
        buf.write("\3\2\2\2\u034c\u034d\3\2\2\2\u034d\u0350\3\2\2\2\u034e")
        buf.write("\u034f\7\u00ab\2\2\u034f\u0351\5\u010e\u0088\2\u0350\u034e")
        buf.write("\3\2\2\2\u0350\u0351\3\2\2\2\u0351\u00ed\3\2\2\2\u0352")
        buf.write("\u0353\7\u00a8\2\2\u0353\u0354\5\u00f0y\2\u0354\u0355")
        buf.write("\5\u00fa~\2\u0355\u035a\3\2\2\2\u0356\u035a\5\u00fc\177")
        buf.write("\2\u0357\u035a\5\u00fe\u0080\2\u0358\u035a\5\u0102\u0082")
        buf.write("\2\u0359\u0352\3\2\2\2\u0359\u0356\3\2\2\2\u0359\u0357")
        buf.write("\3\2\2\2\u0359\u0358\3\2\2\2\u035a\u00ef\3\2\2\2\u035b")
        buf.write("\u035c\5\u00f2z\2\u035c\u035d\7\u00ae\2\2\u035d\u035f")
        buf.write("\3\2\2\2\u035e\u035b\3\2\2\2\u035e\u035f\3\2\2\2\u035f")
        buf.write("\u0360\3\2\2\2\u0360\u0363\5\u00f4{\2\u0361\u0362\7\u0096")
        buf.write("\2\2\u0362\u0364\5\u0114\u008b\2\u0363\u0361\3\2\2\2\u0363")
        buf.write("\u0364\3\2\2\2\u0364\u00f1\3\2\2\2\u0365\u036a\5\u0110")
        buf.write("\u0089\2\u0366\u036a\5\u0124\u0093\2\u0367\u036a\5\u012c")
        buf.write("\u0097\2\u0368\u036a\7\u0096\2\2\u0369\u0365\3\2\2\2\u0369")
        buf.write("\u0366\3\2\2\2\u0369\u0367\3\2\2\2\u0369\u0368\3\2\2\2")
        buf.write("\u036a\u036d\3\2\2\2\u036b\u0369\3\2\2\2\u036b\u036c\3")
        buf.write("\2\2\2\u036c\u00f3\3\2\2\2\u036d\u036b\3\2\2\2\u036e\u0372")
        buf.write("\5\u0116\u008c\2\u036f\u0372\5\u0120\u0091\2\u0370\u0372")
        buf.write("\5\u00f6|\2\u0371\u036e\3\2\2\2\u0371\u036f\3\2\2\2\u0371")
        buf.write("\u0370\3\2\2\2\u0372\u00f5\3\2\2\2\u0373\u0377\5\u0110")
        buf.write("\u0089\2\u0374\u0377\5\u0124\u0093\2\u0375\u0377\5\u012c")
        buf.write("\u0097\2\u0376\u0373\3\2\2\2\u0376\u0374\3\2\2\2\u0376")
        buf.write("\u0375\3\2\2\2\u0377\u037a\3\2\2\2\u0378\u0376\3\2\2\2")
        buf.write("\u0378\u0379\3\2\2\2\u0379\u00f7\3\2\2\2\u037a\u0378\3")
        buf.write("\2\2\2\u037b\u0381\5\u00fa~\2\u037c\u0381\5\u00fc\177")
        buf.write("\2\u037d\u0381\5\u00fe\u0080\2\u037e\u0381\5\u0100\u0081")
        buf.write("\2\u037f\u0381\5\u0102\u0082\2\u0380\u037b\3\2\2\2\u0380")
        buf.write("\u037c\3\2\2\2\u0380\u037d\3\2\2\2\u0380\u037e\3\2\2\2")
        buf.write("\u0380\u037f\3\2\2\2\u0381\u00f9\3\2\2\2\u0382\u0383\7")
        buf.write("\u00a9\2\2\u0383\u0385\5\u0104\u0083\2\u0384\u0382\3\2")
        buf.write("\2\2\u0385\u0388\3\2\2\2\u0386\u0384\3\2\2\2\u0386\u0387")
        buf.write("\3\2\2\2\u0387\u00fb\3\2\2\2\u0388\u0386\3\2\2\2\u0389")
        buf.write("\u0392\7\u00a9\2\2\u038a\u038f\5\u0106\u0084\2\u038b\u038c")
        buf.write("\7\u00a9\2\2\u038c\u038e\5\u0104\u0083\2\u038d\u038b\3")
        buf.write("\2\2\2\u038e\u0391\3\2\2\2\u038f\u038d\3\2\2\2\u038f\u0390")
        buf.write("\3\2\2\2\u0390\u0393\3\2\2\2\u0391\u038f\3\2\2\2\u0392")
        buf.write("\u038a\3\2\2\2\u0392\u0393\3\2\2\2\u0393\u00fd\3\2\2\2")
        buf.write("\u0394\u0399\5\u0108\u0085\2\u0395\u0396\7\u00a9\2\2\u0396")
        buf.write("\u0398\5\u0104\u0083\2\u0397\u0395\3\2\2\2\u0398\u039b")
        buf.write("\3\2\2\2\u0399\u0397\3\2\2\2\u0399\u039a\3\2\2\2\u039a")
        buf.write("\u00ff\3\2\2\2\u039b\u0399\3\2\2\2\u039c\u03a1\5\u0106")
        buf.write("\u0084\2\u039d\u039e\7\u00a9\2\2\u039e\u03a0\5\u0104\u0083")
        buf.write("\2\u039f\u039d\3\2\2\2\u03a0\u03a3\3\2\2\2\u03a1\u039f")
        buf.write("\3\2\2\2\u03a1\u03a2\3\2\2\2\u03a2\u0101\3\2\2\2\u03a3")
        buf.write("\u03a1\3\2\2\2\u03a4\u03a5\3\2\2\2\u03a5\u0103\3\2\2\2")
        buf.write("\u03a6\u03a8\5\u010a\u0086\2\u03a7\u03a6\3\2\2\2\u03a8")
        buf.write("\u03ab\3\2\2\2\u03a9\u03a7\3\2\2\2\u03a9\u03aa\3\2\2\2")
        buf.write("\u03aa\u0105\3\2\2\2\u03ab\u03a9\3\2\2\2\u03ac\u03ae\5")
        buf.write("\u010a\u0086\2\u03ad\u03ac\3\2\2\2\u03ae\u03af\3\2\2\2")
        buf.write("\u03af\u03ad\3\2\2\2\u03af\u03b0\3\2\2\2\u03b0\u0107\3")
        buf.write("\2\2\2\u03b1\u03b6\5\u0110\u0089\2\u03b2\u03b6\5\u0124")
        buf.write("\u0093\2\u03b3\u03b6\5\u012c\u0097\2\u03b4\u03b6\7\u00ae")
        buf.write("\2\2\u03b5\u03b1\3\2\2\2\u03b5\u03b2\3\2\2\2\u03b5\u03b3")
        buf.write("\3\2\2\2\u03b5\u03b4\3\2\2\2\u03b6\u03b7\3\2\2\2\u03b7")
        buf.write("\u03b5\3\2\2\2\u03b7\u03b8\3\2\2\2\u03b8\u0109\3\2\2\2")
        buf.write("\u03b9\u03be\5\u0110\u0089\2\u03ba\u03be\5\u0124\u0093")
        buf.write("\2\u03bb\u03be\5\u012c\u0097\2\u03bc\u03be\t\3\2\2\u03bd")
        buf.write("\u03b9\3\2\2\2\u03bd\u03ba\3\2\2\2\u03bd\u03bb\3\2\2\2")
        buf.write("\u03bd\u03bc\3\2\2\2\u03be\u010b\3\2\2\2\u03bf\u03c2\5")
        buf.write("\u010a\u0086\2\u03c0\u03c2\t\4\2\2\u03c1\u03bf\3\2\2\2")
        buf.write("\u03c1\u03c0\3\2\2\2\u03c2\u03c5\3\2\2\2\u03c3\u03c1\3")
        buf.write("\2\2\2\u03c3\u03c4\3\2\2\2\u03c4\u010d\3\2\2\2\u03c5\u03c3")
        buf.write("\3\2\2\2\u03c6\u03c9\5\u010a\u0086\2\u03c7\u03c9\t\5\2")
        buf.write("\2\u03c8\u03c6\3\2\2\2\u03c8\u03c7\3\2\2\2\u03c9\u03cc")
        buf.write("\3\2\2\2\u03ca\u03c8\3\2\2\2\u03ca\u03cb\3\2\2\2\u03cb")
        buf.write("\u010f\3\2\2\2\u03cc\u03ca\3\2\2\2\u03cd\u03d1\5\u012e")
        buf.write("\u0098\2\u03ce\u03d1\5\u0132\u009a\2\u03cf\u03d1\t\6\2")
        buf.write("\2\u03d0\u03cd\3\2\2\2\u03d0\u03ce\3\2\2\2\u03d0\u03cf")
        buf.write("\3\2\2\2\u03d1\u0111\3\2\2\2\u03d2\u03d8\5\u012e\u0098")
        buf.write("\2\u03d3\u03d7\5\u012e\u0098\2\u03d4\u03d7\5\u0132\u009a")
        buf.write("\2\u03d5\u03d7\t\7\2\2\u03d6\u03d3\3\2\2\2\u03d6\u03d4")
        buf.write("\3\2\2\2\u03d6\u03d5\3\2\2\2\u03d7\u03da\3\2\2\2\u03d8")
        buf.write("\u03d6\3\2\2\2\u03d8\u03d9\3\2\2\2\u03d9\u0113\3\2\2\2")
        buf.write("\u03da\u03d8\3\2\2\2\u03db\u03dd\5\u0132\u009a\2\u03dc")
        buf.write("\u03db\3\2\2\2\u03dd\u03e0\3\2\2\2\u03de\u03dc\3\2\2\2")
        buf.write("\u03de\u03df\3\2\2\2\u03df\u0115\3\2\2\2\u03e0\u03de\3")
        buf.write("\2\2\2\u03e1\u03e4\7\u00ac\2\2\u03e2\u03e5\5\u011a\u008e")
        buf.write("\2\u03e3\u03e5\5\u0118\u008d\2\u03e4\u03e2\3\2\2\2\u03e4")
        buf.write("\u03e3\3\2\2\2\u03e5\u03e6\3\2\2\2\u03e6\u03e7\7\u00ad")
        buf.write("\2\2\u03e7\u0117\3\2\2\2\u03e8\u03ea\7\u0090\2\2\u03e9")
        buf.write("\u03eb\5\u0130\u0099\2\u03ea\u03e9\3\2\2\2\u03eb\u03ec")
        buf.write("\3\2\2\2\u03ec\u03ea\3\2\2\2\u03ec\u03ed\3\2\2\2\u03ed")
        buf.write("\u03ee\3\2\2\2\u03ee\u03f2\7\u0097\2\2\u03ef\u03f3\5\u0126")
        buf.write("\u0094\2\u03f0\u03f3\5\u012c\u0097\2\u03f1\u03f3\7\u0096")
        buf.write("\2\2\u03f2\u03ef\3\2\2\2\u03f2\u03f0\3\2\2\2\u03f2\u03f1")
        buf.write("\3\2\2\2\u03f3\u03f4\3\2\2\2\u03f4\u03f2\3\2\2\2\u03f4")
        buf.write("\u03f5\3\2\2\2\u03f5\u0119\3\2\2\2\u03f6\u03f7\5\u011c")
        buf.write("\u008f\2\u03f7\u03f8\7\u0096\2\2\u03f8\u03f9\5\u011c\u008f")
        buf.write("\2\u03f9\u03fa\7\u0096\2\2\u03fa\u03fb\5\u011c\u008f\2")
        buf.write("\u03fb\u03fc\7\u0096\2\2\u03fc\u03fd\5\u011c\u008f\2\u03fd")
        buf.write("\u03fe\7\u0096\2\2\u03fe\u03ff\5\u011c\u008f\2\u03ff\u0400")
        buf.write("\7\u0096\2\2\u0400\u0401\5\u011c\u008f\2\u0401\u0402\7")
        buf.write("\u0096\2\2\u0402\u0403\5\u011e\u0090\2\u0403\u04b5\3\2")
        buf.write("\2\2\u0404\u0405\7\u0095\2\2\u0405\u0406\5\u011c\u008f")
        buf.write("\2\u0406\u0407\7\u0096\2\2\u0407\u0408\5\u011c\u008f\2")
        buf.write("\u0408\u0409\7\u0096\2\2\u0409\u040a\5\u011c\u008f\2\u040a")
        buf.write("\u040b\7\u0096\2\2\u040b\u040c\5\u011c\u008f\2\u040c\u040d")
        buf.write("\7\u0096\2\2\u040d\u040e\5\u011c\u008f\2\u040e\u040f\7")
        buf.write("\u0096\2\2\u040f\u0410\5\u011e\u0090\2\u0410\u04b5\3\2")
        buf.write("\2\2\u0411\u0413\5\u011c\u008f\2\u0412\u0411\3\2\2\2\u0412")
        buf.write("\u0413\3\2\2\2\u0413\u0414\3\2\2\2\u0414\u0415\7\u0095")
        buf.write("\2\2\u0415\u0416\5\u011c\u008f\2\u0416\u0417\7\u0096\2")
        buf.write("\2\u0417\u0418\5\u011c\u008f\2\u0418\u0419\7\u0096\2\2")
        buf.write("\u0419\u041a\5\u011c\u008f\2\u041a\u041b\7\u0096\2\2\u041b")
        buf.write("\u041c\5\u011c\u008f\2\u041c\u041d\7\u0096\2\2\u041d\u041e")
        buf.write("\5\u011e\u0090\2\u041e\u04b5\3\2\2\2\u041f\u0420\5\u011c")
        buf.write("\u008f\2\u0420\u0421\7\u0096\2\2\u0421\u0423\3\2\2\2\u0422")
        buf.write("\u041f\3\2\2\2\u0422\u0423\3\2\2\2\u0423\u0424\3\2\2\2")
        buf.write("\u0424\u0426\5\u011c\u008f\2\u0425\u0422\3\2\2\2\u0425")
        buf.write("\u0426\3\2\2\2\u0426\u0427\3\2\2\2\u0427\u0428\7\u0095")
        buf.write("\2\2\u0428\u0429\5\u011c\u008f\2\u0429\u042a\7\u0096\2")
        buf.write("\2\u042a\u042b\5\u011c\u008f\2\u042b\u042c\7\u0096\2\2")
        buf.write("\u042c\u042d\5\u011c\u008f\2\u042d\u042e\7\u0096\2\2\u042e")
        buf.write("\u042f\5\u011e\u0090\2\u042f\u04b5\3\2\2\2\u0430\u0431")
        buf.write("\5\u011c\u008f\2\u0431\u0432\7\u0096\2\2\u0432\u0434\3")
        buf.write("\2\2\2\u0433\u0430\3\2\2\2\u0433\u0434\3\2\2\2\u0434\u0435")
        buf.write("\3\2\2\2\u0435\u0436\5\u011c\u008f\2\u0436\u0437\7\u0096")
        buf.write("\2\2\u0437\u0439\3\2\2\2\u0438\u0433\3\2\2\2\u0438\u0439")
        buf.write("\3\2\2\2\u0439\u043a\3\2\2\2\u043a\u043c\5\u011c\u008f")
        buf.write("\2\u043b\u0438\3\2\2\2\u043b\u043c\3\2\2\2\u043c\u043d")
        buf.write("\3\2\2\2\u043d\u043e\7\u0095\2\2\u043e\u043f\5\u011c\u008f")
        buf.write("\2\u043f\u0440\7\u0096\2\2\u0440\u0441\5\u011c\u008f\2")
        buf.write("\u0441\u0442\7\u0096\2\2\u0442\u0443\5\u011e\u0090\2\u0443")
        buf.write("\u04b5\3\2\2\2\u0444\u0445\5\u011c\u008f\2\u0445\u0446")
        buf.write("\7\u0096\2\2\u0446\u0448\3\2\2\2\u0447\u0444\3\2\2\2\u0447")
        buf.write("\u0448\3\2\2\2\u0448\u0449\3\2\2\2\u0449\u044a\5\u011c")
        buf.write("\u008f\2\u044a\u044b\7\u0096\2\2\u044b\u044d\3\2\2\2\u044c")
        buf.write("\u0447\3\2\2\2\u044c\u044d\3\2\2\2\u044d\u044e\3\2\2\2")
        buf.write("\u044e\u044f\5\u011c\u008f\2\u044f\u0450\7\u0096\2\2\u0450")
        buf.write("\u0452\3\2\2\2\u0451\u044c\3\2\2\2\u0451\u0452\3\2\2\2")
        buf.write("\u0452\u0453\3\2\2\2\u0453\u0455\5\u011c\u008f\2\u0454")
        buf.write("\u0451\3\2\2\2\u0454\u0455\3\2\2\2\u0455\u0456\3\2\2\2")
        buf.write("\u0456\u0457\7\u0095\2\2\u0457\u0458\5\u011c\u008f\2\u0458")
        buf.write("\u0459\7\u0096\2\2\u0459\u045a\5\u011e\u0090\2\u045a\u04b5")
        buf.write("\3\2\2\2\u045b\u045c\5\u011c\u008f\2\u045c\u045d\7\u0096")
        buf.write("\2\2\u045d\u045f\3\2\2\2\u045e\u045b\3\2\2\2\u045e\u045f")
        buf.write("\3\2\2\2\u045f\u0460\3\2\2\2\u0460\u0461\5\u011c\u008f")
        buf.write("\2\u0461\u0462\7\u0096\2\2\u0462\u0464\3\2\2\2\u0463\u045e")
        buf.write("\3\2\2\2\u0463\u0464\3\2\2\2\u0464\u0465\3\2\2\2\u0465")
        buf.write("\u0466\5\u011c\u008f\2\u0466\u0467\7\u0096\2\2\u0467\u0469")
        buf.write("\3\2\2\2\u0468\u0463\3\2\2\2\u0468\u0469\3\2\2\2\u0469")
        buf.write("\u046a\3\2\2\2\u046a\u046b\5\u011c\u008f\2\u046b\u046c")
        buf.write("\7\u0096\2\2\u046c\u046e\3\2\2\2\u046d\u0468\3\2\2\2\u046d")
        buf.write("\u046e\3\2\2\2\u046e\u046f\3\2\2\2\u046f\u0471\5\u011c")
        buf.write("\u008f\2\u0470\u046d\3\2\2\2\u0470\u0471\3\2\2\2\u0471")
        buf.write("\u0472\3\2\2\2\u0472\u0473\7\u0095\2\2\u0473\u04b5\5\u011e")
        buf.write("\u0090\2\u0474\u0475\5\u011c\u008f\2\u0475\u0476\7\u0096")
        buf.write("\2\2\u0476\u0478\3\2\2\2\u0477\u0474\3\2\2\2\u0477\u0478")
        buf.write("\3\2\2\2\u0478\u0479\3\2\2\2\u0479\u047a\5\u011c\u008f")
        buf.write("\2\u047a\u047b\7\u0096\2\2\u047b\u047d\3\2\2\2\u047c\u0477")
        buf.write("\3\2\2\2\u047c\u047d\3\2\2\2\u047d\u047e\3\2\2\2\u047e")
        buf.write("\u047f\5\u011c\u008f\2\u047f\u0480\7\u0096\2\2\u0480\u0482")
        buf.write("\3\2\2\2\u0481\u047c\3\2\2\2\u0481\u0482\3\2\2\2\u0482")
        buf.write("\u0483\3\2\2\2\u0483\u0484\5\u011c\u008f\2\u0484\u0485")
        buf.write("\7\u0096\2\2\u0485\u0487\3\2\2\2\u0486\u0481\3\2\2\2\u0486")
        buf.write("\u0487\3\2\2\2\u0487\u0488\3\2\2\2\u0488\u0489\5\u011c")
        buf.write("\u008f\2\u0489\u048a\7\u0096\2\2\u048a\u048c\3\2\2\2\u048b")
        buf.write("\u0486\3\2\2\2\u048b\u048c\3\2\2\2\u048c\u048d\3\2\2\2")
        buf.write("\u048d\u048f\5\u011c\u008f\2\u048e\u048b\3\2\2\2\u048e")
        buf.write("\u048f\3\2\2\2\u048f\u0490\3\2\2\2\u0490\u0491\7\u0095")
        buf.write("\2\2\u0491\u04b5\5\u011c\u008f\2\u0492\u0493\5\u011c\u008f")
        buf.write("\2\u0493\u0494\7\u0096\2\2\u0494\u0496\3\2\2\2\u0495\u0492")
        buf.write("\3\2\2\2\u0495\u0496\3\2\2\2\u0496\u0497\3\2\2\2\u0497")
        buf.write("\u0498\5\u011c\u008f\2\u0498\u0499\7\u0096\2\2\u0499\u049b")
        buf.write("\3\2\2\2\u049a\u0495\3\2\2\2\u049a\u049b\3\2\2\2\u049b")
        buf.write("\u049c\3\2\2\2\u049c\u049d\5\u011c\u008f\2\u049d\u049e")
        buf.write("\7\u0096\2\2\u049e\u04a0\3\2\2\2\u049f\u049a\3\2\2\2\u049f")
        buf.write("\u04a0\3\2\2\2\u04a0\u04a1\3\2\2\2\u04a1\u04a2\5\u011c")
        buf.write("\u008f\2\u04a2\u04a3\7\u0096\2\2\u04a3\u04a5\3\2\2\2\u04a4")
        buf.write("\u049f\3\2\2\2\u04a4\u04a5\3\2\2\2\u04a5\u04a6\3\2\2\2")
        buf.write("\u04a6\u04a7\5\u011c\u008f\2\u04a7\u04a8\7\u0096\2\2\u04a8")
        buf.write("\u04aa\3\2\2\2\u04a9\u04a4\3\2\2\2\u04a9\u04aa\3\2\2\2")
        buf.write("\u04aa\u04ab\3\2\2\2\u04ab\u04ac\5\u011c\u008f\2\u04ac")
        buf.write("\u04ad\7\u0096\2\2\u04ad\u04af\3\2\2\2\u04ae\u04a9\3\2")
        buf.write("\2\2\u04ae\u04af\3\2\2\2\u04af\u04b0\3\2\2\2\u04b0\u04b2")
        buf.write("\5\u011c\u008f\2\u04b1\u04ae\3\2\2\2\u04b1\u04b2\3\2\2")
        buf.write("\2\u04b2\u04b3\3\2\2\2\u04b3\u04b5\7\u0095\2\2\u04b4\u03f6")
        buf.write("\3\2\2\2\u04b4\u0404\3\2\2\2\u04b4\u0412\3\2\2\2\u04b4")
        buf.write("\u0425\3\2\2\2\u04b4\u043b\3\2\2\2\u04b4\u0454\3\2\2\2")
        buf.write("\u04b4\u0470\3\2\2\2\u04b4\u048e\3\2\2\2\u04b4\u04b1\3")
        buf.write("\2\2\2\u04b5\u011b\3\2\2\2\u04b6\u04b7\5\u0130\u0099\2")
        buf.write("\u04b7\u04b8\5\u0130\u0099\2\u04b8\u04b9\5\u0130\u0099")
        buf.write("\2\u04b9\u04ba\5\u0130\u0099\2\u04ba\u04c4\3\2\2\2\u04bb")
        buf.write("\u04bc\5\u0130\u0099\2\u04bc\u04bd\5\u0130\u0099\2\u04bd")
        buf.write("\u04be\5\u0130\u0099\2\u04be\u04c4\3\2\2\2\u04bf\u04c0")
        buf.write("\5\u0130\u0099\2\u04c0\u04c1\5\u0130\u0099\2\u04c1\u04c4")
        buf.write("\3\2\2\2\u04c2\u04c4\5\u0130\u0099\2\u04c3\u04b6\3\2\2")
        buf.write("\2\u04c3\u04bb\3\2\2\2\u04c3\u04bf\3\2\2\2\u04c3\u04c2")
        buf.write("\3\2\2\2\u04c4\u011d\3\2\2\2\u04c5\u04c6\5\u011c\u008f")
        buf.write("\2\u04c6\u04c7\7\u0096\2\2\u04c7\u04c8\5\u011c\u008f\2")
        buf.write("\u04c8\u04cb\3\2\2\2\u04c9\u04cb\5\u0120\u0091\2\u04ca")
        buf.write("\u04c5\3\2\2\2\u04ca\u04c9\3\2\2\2\u04cb\u011f\3\2\2\2")
        buf.write("\u04cc\u04cd\5\u0122\u0092\2\u04cd\u04ce\7\u0097\2\2\u04ce")
        buf.write("\u04cf\5\u0122\u0092\2\u04cf\u04d0\7\u0097\2\2\u04d0\u04d1")
        buf.write("\5\u0122\u0092\2\u04d1\u04d2\7\u0097\2\2\u04d2\u04d3\5")
        buf.write("\u0122\u0092\2\u04d3\u0121\3\2\2\2\u04d4\u04e3\5\u0132")
        buf.write("\u009a\2\u04d5\u04d6\5\u0134\u009b\2\u04d6\u04d7\5\u0132")
        buf.write("\u009a\2\u04d7\u04e3\3\2\2\2\u04d8\u04d9\7r\2\2\u04d9")
        buf.write("\u04da\5\u0132\u009a\2\u04da\u04db\5\u0132\u009a\2\u04db")
        buf.write("\u04e3\3\2\2\2\u04dc\u04dd\7s\2\2\u04dd\u04de\t\b\2\2")
        buf.write("\u04de\u04e3\5\u0132\u009a\2\u04df\u04e0\7s\2\2\u04e0")
        buf.write("\u04e1\7v\2\2\u04e1\u04e3\t\t\2\2\u04e2\u04d4\3\2\2\2")
        buf.write("\u04e2\u04d5\3\2\2\2\u04e2\u04d8\3\2\2\2\u04e2\u04dc\3")
        buf.write("\2\2\2\u04e2\u04df\3\2\2\2\u04e3\u0123\3\2\2\2\u04e4\u04e5")
        buf.write("\7\u0098\2\2\u04e5\u04e6\5\u0130\u0099\2\u04e6\u04e7\5")
        buf.write("\u0130\u0099\2\u04e7\u0125\3\2\2\2\u04e8\u04ec\5\u012e")
        buf.write("\u0098\2\u04e9\u04ec\5\u0132\u009a\2\u04ea\u04ec\t\n\2")
        buf.write("\2\u04eb\u04e8\3\2\2\2\u04eb\u04e9\3\2\2\2\u04eb\u04ea")
        buf.write("\3\2\2\2\u04ec\u0127\3\2\2\2\u04ed\u04f0\5\u012a\u0096")
        buf.write("\2\u04ee\u04f0\5\u012c\u0097\2\u04ef\u04ed\3\2\2\2\u04ef")
        buf.write("\u04ee\3\2\2\2\u04f0\u0129\3\2\2\2\u04f1\u04f2\t\13\2")
        buf.write("\2\u04f2\u012b\3\2\2\2\u04f3\u04f4\t\f\2\2\u04f4\u012d")
        buf.write("\3\2\2\2\u04f5\u04f6\t\r\2\2\u04f6\u012f\3\2\2\2\u04f7")
        buf.write("\u04fa\5\u0132\u009a\2\u04f8\u04fa\t\16\2\2\u04f9\u04f7")
        buf.write("\3\2\2\2\u04f9\u04f8\3\2\2\2\u04fa\u0131\3\2\2\2\u04fb")
        buf.write("\u04fe\7q\2\2\u04fc\u04fe\5\u0134\u009b\2\u04fd\u04fb")
        buf.write("\3\2\2\2\u04fd\u04fc\3\2\2\2\u04fe\u0133\3\2\2\2\u04ff")
        buf.write("\u0500\t\17\2\2\u0500\u0135\3\2\2\2k\u0139\u013e\u0140")
        buf.write("\u0146\u014e\u0155\u015c\u0163\u016a\u0171\u0178\u017e")
        buf.write("\u0185\u018c\u0193\u019a\u01a1\u01a8\u01cb\u01ce\u01d8")
        buf.write("\u01db\u01f2\u023e\u0248\u024e\u0251\u0256\u025b\u0261")
        buf.write("\u0267\u032f\u0333\u033c\u0340\u0347\u034c\u0350\u0359")
        buf.write("\u035e\u0363\u0369\u036b\u0371\u0376\u0378\u0380\u0386")
        buf.write("\u038f\u0392\u0399\u03a1\u03a9\u03af\u03b5\u03b7\u03bd")
        buf.write("\u03c1\u03c3\u03c8\u03ca\u03d0\u03d6\u03d8\u03de\u03e4")
        buf.write("\u03ec\u03f2\u03f4\u0412\u0422\u0425\u0433\u0438\u043b")
        buf.write("\u0447\u044c\u0451\u0454\u045e\u0463\u0468\u046d\u0470")
        buf.write("\u0477\u047c\u0481\u0486\u048b\u048e\u0495\u049a\u049f")
        buf.write("\u04a4\u04a9\u04ae\u04b1\u04b4\u04c3\u04ca\u04e2\u04eb")
        buf.write("\u04ef\u04f9\u04fd")
        return buf.getvalue()


class RULEMLParser ( Parser ):

    grammarFileName = "RULEMLParser.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "<INVALID>", "'<Atom>'", "'</Atom>'", 
                     "'<Rel>'", "'</Rel>'", "'<Ind>'", "'</Ind>'", "<INVALID>", 
                     "'<Rel>statement</Rel>'", "'rdf:type'", "'rdfs:subPropertyOf'", 
                     "'rdfs:subClassOf'", "'rdfs:domain'", "'rdfs:range'", 
                     "'owl:equivalentClass'", "'owl:Class'", "'rdf:Description'", 
                     "'owl:withRestrictions'", "'owl:intersectionOf'", "'owl:someValuesFrom'", 
                     "'owl:allValuesFrom'", "'owl:onProperty'", "'owl:onDatatype'", 
                     "'owl:hasValue'", "'owl:hasSelf'", "'rdfs:seeAlso'", 
                     "'rdfs:comment'", "'rdfs:label'", "'dc:description'", 
                     "'dc:source'", "'xsd:minExclusive'", "'xsd:maxExclusive'", 
                     "'xsd:'", "'owl:Restriction'", "'rdfs:Datatype'", "'owl:FunctionalProperty'", 
                     "'owl:onClass'", "'owl:onDataRange'", "'owl:qualifiedCardinality'", 
                     "'owl:ObjectProperty'", "'rdf:rest'", "'rdf:nil'", 
                     "'owl:unionOf'", "'owl:cardinality'", "'owl:maxCardinality'", 
                     "'owl:maxQualifiedCardinality'", "'owl:minCardinality'", 
                     "'owl:minQualifiedCardinality'", "'owl:onProperties'", 
                     "'owl:complementOf'", "'owl:oneOf'", "'skos:definition'", 
                     "'skos:prefLabel'", "'skos:altLabel'", "'skos:hiddenLabel'", 
                     "'skos:notation'", "'true'", "'false'", "'owl:topObjectProperty'", 
                     "'owl:bottomObjectProperty'", "'owl:inverseOf'", "'owl:topDataProperty'", 
                     "'owl:bottomDataProperty'", "'owl:datatypeComplementOf'", 
                     "'owl:disjointWith'", "'owl:AllDisjointClasses'", "'owl:members'", 
                     "'owl:disjointUnionOf'", "'owl:propertyChainAxiom'", 
                     "'owl:equivalentProperty'", "'owl:propertyDisjointWith'", 
                     "'owl:AllDisjointProperties'", "'owl:InverseFunctionalProperty'", 
                     "'owl:ReflexiveProperty'", "'owl:IrreflexiveProperty'", 
                     "'owl:SymmetricProperty'", "'owl:AsymmetricProperty'", 
                     "'owl:TransitiveProperty'", "'owl:sameAs'", "'owl:differentFrom'", 
                     "'owl:AllDifferent'", "'owl:NegativePropertyAssertion'", 
                     "'owl:sourceIndividual'", "'owl:assertionProperty'", 
                     "'owl:targetIndividual'", "'owl:targetValue'", "'owl:hasKey'", 
                     "'owl:DatatypeProperty'", "'owl:AnnotationProperty'", 
                     "'owl:NamedIndividual'", "'owl:Axiom'", "'owl:annotatedSource'", 
                     "'owl:annotatedProperty'", "'owl:annotatedTarget'", 
                     "'owl:Annotation'", "'rdfs:isDefinedBy'", "'owl:versionInfo'", 
                     "'owl:deprecated'", "'owl:backwardCompatibleWith'", 
                     "'owl:incompatibleWith'", "'owl:priorVersion'", "'rdfs:Literal'", 
                     "'owl:rational'", "'owl:real'", "'rdf:PlainLiteral'", 
                     "'rdf:XMLLiteral'", "'rdf:langRange'", "'^'", "<INVALID>", 
                     "<INVALID>", "'0'", "'1'", "'2'", "'3'", "'4'", "'5'", 
                     "'6'", "'7'", "'8'", "'9'", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "'::'", "':'", "'.'", "'%'", "'-'", "'~'", "'_'", "'!'", 
                     "'$'", "'&'", "'''", "'\"'", "'('", "')'", "'*'", "'+'", 
                     "','", "';'", "'='", "'//'", "'/'", "'?'", "'#'", "'['", 
                     "']'", "'@'", "'<'", "'>'" ]

    symbolicNames = [ "<INVALID>", "SEA_WS", "ATOMOPEN", "ATOMCLOSE", "RELOPEN", 
                      "RELCLOSE", "INDOPEN", "INDCLOSE", "WS", "STATEMENT", 
                      "RDFTYPE", "SUBP", "SUBC", "RDFSDOMAIN", "RDFSRANGE", 
                      "EQUICLASS", "OWLCLASS", "RDFDESCRIPTION", "WITHRESTRICTIONS", 
                      "INTERSECTIONOF", "OWLSVF", "OWLAVF", "ONP", "ONDATATYPE", 
                      "HASVALUE", "HASSELF", "SEEALSO", "RDFSCOMMENT", "RDFSLABEL", 
                      "DCDESCRIPTION", "DCSOURCE", "MINEXCLUSIVE", "MAXEXCLUSIVE", 
                      "XSD", "OWLRESTRICTION", "RDFSDATATYPE", "FUNCPROPERTY", 
                      "OWLONCLASS", "OWLONDATARANGE", "OWLQC", "OBJECTPROPERTY", 
                      "RDFREST", "RDFNIL", "UNIONOF", "CARDINALITY", "OWLMAXC", 
                      "OWLMAXQC", "OWLMINC", "OWLMINQC", "ONPROPERTIES", 
                      "COMPLEMENTOF", "ONEOF", "SKOSDEF", "SKOSPREFLABEL", 
                      "SKOSALTLABEL", "SKOSHIDDENLABEL", "SKOSNOTATION", 
                      "TRUE", "FALSE", "TOPOP", "BOTTOMOP", "INVERSEOF", 
                      "TOPDP", "BOTTOMDP", "DATACOMPLEMENTOF", "DISJOINTWITH", 
                      "ALLDISJOINTCLASSES", "OWLMEMBERS", "DISJOINTUNIONOF", 
                      "PROPERTYCHAINAXIOM", "EQUIPROPERTY", "PDISJOINTWITH", 
                      "ALLDISJOINTP", "INVERSEFUNCP", "REFLEXP", "IRREFLEXP", 
                      "SYMMP", "ASYMMP", "TRANSITIVEP", "SAMEAS", "DIFFERENTFROM", 
                      "ALLDIFFERENT", "NEGPASSERT", "SOURCEINDIVIDUAL", 
                      "ASSERTP", "TARGETINDIVIDUAL", "TARGETVALUE", "HASKEY", 
                      "DATATYPEP", "ANNOTATIONP", "NAMEDINDIVIDUAL", "OWLAXIOM", 
                      "ANNOTATEDS", "ANNOTATEDP", "ANNOTATEDT", "OWLANNOTATION", 
                      "ISDEFINEDBY", "VERSIONINFO", "DEPRECATED", "BACKCOMPATWITH", 
                      "INCOMPATWITH", "PRIORVERSION", "RDFSLITERAL", "OWLRATIONAL", 
                      "OWLREAL", "RDFPLAINL", "XMLLITERAL", "RDFLANGRANGE", 
                      "POWER", "UCSCHAR", "IPRIVATE", "D0", "D1", "D2", 
                      "D3", "D4", "D5", "D6", "D7", "D8", "D9", "A", "B", 
                      "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", 
                      "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", 
                      "W", "X", "Y", "Z", "COL2", "COL", "DOT", "PERCENT", 
                      "HYPHEN", "TILDE", "USCORE", "EXCL", "DOLLAR", "AMP", 
                      "SQUOTE", "DQUOTE", "OPAREN", "CPAREN", "STAR", "PLUS", 
                      "COMMA", "SCOL", "EQUALS", "FSLASH2", "FSLASH", "QMARK", 
                      "HASH", "OBRACK", "CBRACK", "AT", "AOBRACK", "ACBRACK" ]

    RULE_ruleMLDoc = 0
    RULE_atom = 1
    RULE_ignoredatom = 2
    RULE_statement = 3
    RULE_subject = 4
    RULE_predicate = 5
    RULE_objekt = 6
    RULE_misc = 7
    RULE_ignoredpred = 8
    RULE_nodeid = 9
    RULE_subjectcontent = 10
    RULE_objektcontent = 11
    RULE_ignoredverb = 12
    RULE_verb = 13
    RULE_xsd = 14
    RULE_xsdvalue = 15
    RULE_xsddatatype = 16
    RULE_unreserved_content = 17
    RULE_rdfscomment = 18
    RULE_rdfslabel = 19
    RULE_dcdescription = 20
    RULE_rdftype = 21
    RULE_seealso = 22
    RULE_rdfrest = 23
    RULE_skosdef = 24
    RULE_skospreflabel = 25
    RULE_skosaltlabel = 26
    RULE_skoshiddenlabel = 27
    RULE_skosnotation = 28
    RULE_annotateds = 29
    RULE_annotatedp = 30
    RULE_annotatedt = 31
    RULE_isdefinedby = 32
    RULE_versioninfo = 33
    RULE_deprecated = 34
    RULE_backcompatwith = 35
    RULE_incompatwith = 36
    RULE_priorversion = 37
    RULE_dcsource = 38
    RULE_ondatatype = 39
    RULE_owlwithrestrictions = 40
    RULE_subpropertyof = 41
    RULE_subclassof = 42
    RULE_rdfsdomain = 43
    RULE_rdfsrange = 44
    RULE_equiclass = 45
    RULE_owlclass = 46
    RULE_rdfdescription = 47
    RULE_intersectionof = 48
    RULE_owlsvf = 49
    RULE_owlavf = 50
    RULE_onproperty = 51
    RULE_hasvalue = 52
    RULE_minexclusive = 53
    RULE_maxexclusive = 54
    RULE_owlrestriction = 55
    RULE_rdfsdatatype = 56
    RULE_funcproperty = 57
    RULE_owlondatarange = 58
    RULE_owlonclass = 59
    RULE_owlqc = 60
    RULE_objectproperty = 61
    RULE_rdfnil = 62
    RULE_unionof = 63
    RULE_cardinality = 64
    RULE_hasself = 65
    RULE_owlmaxc = 66
    RULE_owlmaxqc = 67
    RULE_owlminc = 68
    RULE_owlminqc = 69
    RULE_onproperties = 70
    RULE_complementof = 71
    RULE_oneof = 72
    RULE_topop = 73
    RULE_bottomop = 74
    RULE_inverseof = 75
    RULE_topdp = 76
    RULE_bottomdp = 77
    RULE_datacomplementof = 78
    RULE_disjointwith = 79
    RULE_alldisjointclasses = 80
    RULE_owlmembers = 81
    RULE_disjointunionof = 82
    RULE_propertychainaxiom = 83
    RULE_equiproperty = 84
    RULE_pdisjointwith = 85
    RULE_alldisjointp = 86
    RULE_inversefuncp = 87
    RULE_reflexp = 88
    RULE_irreflexp = 89
    RULE_symmp = 90
    RULE_asymmp = 91
    RULE_transitivep = 92
    RULE_sameas = 93
    RULE_differentfrom = 94
    RULE_alldifferent = 95
    RULE_negpassert = 96
    RULE_sourceindividual = 97
    RULE_assertp = 98
    RULE_targetindividual = 99
    RULE_targetvalue = 100
    RULE_haskey = 101
    RULE_datatypep = 102
    RULE_annotationp = 103
    RULE_namedindividual = 104
    RULE_owlaxiom = 105
    RULE_owlannotation = 106
    RULE_rdfsliteral = 107
    RULE_owlrational = 108
    RULE_owlreal = 109
    RULE_rdfplainl = 110
    RULE_xmlliteral = 111
    RULE_rdflangrange = 112
    RULE_iri = 113
    RULE_ihier_part = 114
    RULE_iri_reference = 115
    RULE_absolute_iri = 116
    RULE_irelative_ref = 117
    RULE_irelative_part = 118
    RULE_iauthority = 119
    RULE_iuserinfo = 120
    RULE_ihost = 121
    RULE_ireg_name = 122
    RULE_ipath = 123
    RULE_ipath_abempty = 124
    RULE_ipath_absolute = 125
    RULE_ipath_noscheme = 126
    RULE_ipath_rootless = 127
    RULE_ipath_empty = 128
    RULE_isegment = 129
    RULE_isegment_nz = 130
    RULE_isegment_nz_nc = 131
    RULE_ipchar = 132
    RULE_iquery = 133
    RULE_ifragment = 134
    RULE_iunreserved = 135
    RULE_scheme = 136
    RULE_port = 137
    RULE_ip_literal = 138
    RULE_ip_v_future = 139
    RULE_ip_v6_address = 140
    RULE_h16 = 141
    RULE_ls32 = 142
    RULE_ip_v4_address = 143
    RULE_dec_octet = 144
    RULE_pct_encoded = 145
    RULE_unreserved = 146
    RULE_reserved = 147
    RULE_gen_delims = 148
    RULE_sub_delims = 149
    RULE_alpha = 150
    RULE_hexdig = 151
    RULE_digit = 152
    RULE_non_zero_digit = 153

    ruleNames =  [ "ruleMLDoc", "atom", "ignoredatom", "statement", "subject", 
                   "predicate", "objekt", "misc", "ignoredpred", "nodeid", 
                   "subjectcontent", "objektcontent", "ignoredverb", "verb", 
                   "xsd", "xsdvalue", "xsddatatype", "unreserved_content", 
                   "rdfscomment", "rdfslabel", "dcdescription", "rdftype", 
                   "seealso", "rdfrest", "skosdef", "skospreflabel", "skosaltlabel", 
                   "skoshiddenlabel", "skosnotation", "annotateds", "annotatedp", 
                   "annotatedt", "isdefinedby", "versioninfo", "deprecated", 
                   "backcompatwith", "incompatwith", "priorversion", "dcsource", 
                   "ondatatype", "owlwithrestrictions", "subpropertyof", 
                   "subclassof", "rdfsdomain", "rdfsrange", "equiclass", 
                   "owlclass", "rdfdescription", "intersectionof", "owlsvf", 
                   "owlavf", "onproperty", "hasvalue", "minexclusive", "maxexclusive", 
                   "owlrestriction", "rdfsdatatype", "funcproperty", "owlondatarange", 
                   "owlonclass", "owlqc", "objectproperty", "rdfnil", "unionof", 
                   "cardinality", "hasself", "owlmaxc", "owlmaxqc", "owlminc", 
                   "owlminqc", "onproperties", "complementof", "oneof", 
                   "topop", "bottomop", "inverseof", "topdp", "bottomdp", 
                   "datacomplementof", "disjointwith", "alldisjointclasses", 
                   "owlmembers", "disjointunionof", "propertychainaxiom", 
                   "equiproperty", "pdisjointwith", "alldisjointp", "inversefuncp", 
                   "reflexp", "irreflexp", "symmp", "asymmp", "transitivep", 
                   "sameas", "differentfrom", "alldifferent", "negpassert", 
                   "sourceindividual", "assertp", "targetindividual", "targetvalue", 
                   "haskey", "datatypep", "annotationp", "namedindividual", 
                   "owlaxiom", "owlannotation", "rdfsliteral", "owlrational", 
                   "owlreal", "rdfplainl", "xmlliteral", "rdflangrange", 
                   "iri", "ihier_part", "iri_reference", "absolute_iri", 
                   "irelative_ref", "irelative_part", "iauthority", "iuserinfo", 
                   "ihost", "ireg_name", "ipath", "ipath_abempty", "ipath_absolute", 
                   "ipath_noscheme", "ipath_rootless", "ipath_empty", "isegment", 
                   "isegment_nz", "isegment_nz_nc", "ipchar", "iquery", 
                   "ifragment", "iunreserved", "scheme", "port", "ip_literal", 
                   "ip_v_future", "ip_v6_address", "h16", "ls32", "ip_v4_address", 
                   "dec_octet", "pct_encoded", "unreserved", "reserved", 
                   "gen_delims", "sub_delims", "alpha", "hexdig", "digit", 
                   "non_zero_digit" ]

    EOF = Token.EOF
    SEA_WS=1
    ATOMOPEN=2
    ATOMCLOSE=3
    RELOPEN=4
    RELCLOSE=5
    INDOPEN=6
    INDCLOSE=7
    WS=8
    STATEMENT=9
    RDFTYPE=10
    SUBP=11
    SUBC=12
    RDFSDOMAIN=13
    RDFSRANGE=14
    EQUICLASS=15
    OWLCLASS=16
    RDFDESCRIPTION=17
    WITHRESTRICTIONS=18
    INTERSECTIONOF=19
    OWLSVF=20
    OWLAVF=21
    ONP=22
    ONDATATYPE=23
    HASVALUE=24
    HASSELF=25
    SEEALSO=26
    RDFSCOMMENT=27
    RDFSLABEL=28
    DCDESCRIPTION=29
    DCSOURCE=30
    MINEXCLUSIVE=31
    MAXEXCLUSIVE=32
    XSD=33
    OWLRESTRICTION=34
    RDFSDATATYPE=35
    FUNCPROPERTY=36
    OWLONCLASS=37
    OWLONDATARANGE=38
    OWLQC=39
    OBJECTPROPERTY=40
    RDFREST=41
    RDFNIL=42
    UNIONOF=43
    CARDINALITY=44
    OWLMAXC=45
    OWLMAXQC=46
    OWLMINC=47
    OWLMINQC=48
    ONPROPERTIES=49
    COMPLEMENTOF=50
    ONEOF=51
    SKOSDEF=52
    SKOSPREFLABEL=53
    SKOSALTLABEL=54
    SKOSHIDDENLABEL=55
    SKOSNOTATION=56
    TRUE=57
    FALSE=58
    TOPOP=59
    BOTTOMOP=60
    INVERSEOF=61
    TOPDP=62
    BOTTOMDP=63
    DATACOMPLEMENTOF=64
    DISJOINTWITH=65
    ALLDISJOINTCLASSES=66
    OWLMEMBERS=67
    DISJOINTUNIONOF=68
    PROPERTYCHAINAXIOM=69
    EQUIPROPERTY=70
    PDISJOINTWITH=71
    ALLDISJOINTP=72
    INVERSEFUNCP=73
    REFLEXP=74
    IRREFLEXP=75
    SYMMP=76
    ASYMMP=77
    TRANSITIVEP=78
    SAMEAS=79
    DIFFERENTFROM=80
    ALLDIFFERENT=81
    NEGPASSERT=82
    SOURCEINDIVIDUAL=83
    ASSERTP=84
    TARGETINDIVIDUAL=85
    TARGETVALUE=86
    HASKEY=87
    DATATYPEP=88
    ANNOTATIONP=89
    NAMEDINDIVIDUAL=90
    OWLAXIOM=91
    ANNOTATEDS=92
    ANNOTATEDP=93
    ANNOTATEDT=94
    OWLANNOTATION=95
    ISDEFINEDBY=96
    VERSIONINFO=97
    DEPRECATED=98
    BACKCOMPATWITH=99
    INCOMPATWITH=100
    PRIORVERSION=101
    RDFSLITERAL=102
    OWLRATIONAL=103
    OWLREAL=104
    RDFPLAINL=105
    XMLLITERAL=106
    RDFLANGRANGE=107
    POWER=108
    UCSCHAR=109
    IPRIVATE=110
    D0=111
    D1=112
    D2=113
    D3=114
    D4=115
    D5=116
    D6=117
    D7=118
    D8=119
    D9=120
    A=121
    B=122
    C=123
    D=124
    E=125
    F=126
    G=127
    H=128
    I=129
    J=130
    K=131
    L=132
    M=133
    N=134
    O=135
    P=136
    Q=137
    R=138
    S=139
    T=140
    U=141
    V=142
    W=143
    X=144
    Y=145
    Z=146
    COL2=147
    COL=148
    DOT=149
    PERCENT=150
    HYPHEN=151
    TILDE=152
    USCORE=153
    EXCL=154
    DOLLAR=155
    AMP=156
    SQUOTE=157
    DQUOTE=158
    OPAREN=159
    CPAREN=160
    STAR=161
    PLUS=162
    COMMA=163
    SCOL=164
    EQUALS=165
    FSLASH2=166
    FSLASH=167
    QMARK=168
    HASH=169
    OBRACK=170
    CBRACK=171
    AT=172
    AOBRACK=173
    ACBRACK=174

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.8")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class RuleMLDocContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(RULEMLParser.EOF, 0)

        def misc(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RULEMLParser.MiscContext)
            else:
                return self.getTypedRuleContext(RULEMLParser.MiscContext,i)


        def atom(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RULEMLParser.AtomContext)
            else:
                return self.getTypedRuleContext(RULEMLParser.AtomContext,i)


        def ignoredatom(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RULEMLParser.IgnoredatomContext)
            else:
                return self.getTypedRuleContext(RULEMLParser.IgnoredatomContext,i)


        def getRuleIndex(self):
            return RULEMLParser.RULE_ruleMLDoc

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleMLDoc" ):
                listener.enterRuleMLDoc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleMLDoc" ):
                listener.exitRuleMLDoc(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRuleMLDoc" ):
                return visitor.visitRuleMLDoc(self)
            else:
                return visitor.visitChildren(self)




    def ruleMLDoc(self):

        localctx = RULEMLParser.RuleMLDocContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_ruleMLDoc)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 311
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,0,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 308
                    self.misc() 
                self.state = 313
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,0,self._ctx)

            self.state = 318
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,2,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 316
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,1,self._ctx)
                    if la_ == 1:
                        self.state = 314
                        self.atom()
                        pass

                    elif la_ == 2:
                        self.state = 315
                        self.ignoredatom()
                        pass

             
                self.state = 320
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,2,self._ctx)

            self.state = 324
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==RULEMLParser.SEA_WS:
                self.state = 321
                self.misc()
                self.state = 326
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 327
            self.match(RULEMLParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AtomContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ATOMOPEN(self):
            return self.getToken(RULEMLParser.ATOMOPEN, 0)

        def statement(self):
            return self.getTypedRuleContext(RULEMLParser.StatementContext,0)


        def subject(self):
            return self.getTypedRuleContext(RULEMLParser.SubjectContext,0)


        def predicate(self):
            return self.getTypedRuleContext(RULEMLParser.PredicateContext,0)


        def objekt(self):
            return self.getTypedRuleContext(RULEMLParser.ObjektContext,0)


        def ATOMCLOSE(self):
            return self.getToken(RULEMLParser.ATOMCLOSE, 0)

        def misc(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RULEMLParser.MiscContext)
            else:
                return self.getTypedRuleContext(RULEMLParser.MiscContext,i)


        def getRuleIndex(self):
            return RULEMLParser.RULE_atom

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtom" ):
                listener.enterAtom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtom" ):
                listener.exitAtom(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAtom" ):
                return visitor.visitAtom(self)
            else:
                return visitor.visitChildren(self)




    def atom(self):

        localctx = RULEMLParser.AtomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_atom)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 332
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==RULEMLParser.SEA_WS:
                self.state = 329
                self.misc()
                self.state = 334
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 335
            self.match(RULEMLParser.ATOMOPEN)
            self.state = 339
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==RULEMLParser.SEA_WS:
                self.state = 336
                self.misc()
                self.state = 341
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 342
            self.statement()
            self.state = 346
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==RULEMLParser.SEA_WS:
                self.state = 343
                self.misc()
                self.state = 348
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 349
            self.subject()
            self.state = 353
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==RULEMLParser.SEA_WS:
                self.state = 350
                self.misc()
                self.state = 355
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 356
            self.predicate()
            self.state = 360
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==RULEMLParser.SEA_WS:
                self.state = 357
                self.misc()
                self.state = 362
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 363
            self.objekt()
            self.state = 367
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==RULEMLParser.SEA_WS:
                self.state = 364
                self.misc()
                self.state = 369
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 370
            self.match(RULEMLParser.ATOMCLOSE)
            self.state = 374
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,10,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 371
                    self.misc() 
                self.state = 376
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,10,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IgnoredatomContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ATOMOPEN(self):
            return self.getToken(RULEMLParser.ATOMOPEN, 0)

        def statement(self):
            return self.getTypedRuleContext(RULEMLParser.StatementContext,0)


        def subject(self):
            return self.getTypedRuleContext(RULEMLParser.SubjectContext,0)


        def ignoredpred(self):
            return self.getTypedRuleContext(RULEMLParser.IgnoredpredContext,0)


        def unreserved_content(self):
            return self.getTypedRuleContext(RULEMLParser.Unreserved_contentContext,0)


        def ATOMCLOSE(self):
            return self.getToken(RULEMLParser.ATOMCLOSE, 0)

        def misc(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RULEMLParser.MiscContext)
            else:
                return self.getTypedRuleContext(RULEMLParser.MiscContext,i)


        def getRuleIndex(self):
            return RULEMLParser.RULE_ignoredatom

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIgnoredatom" ):
                listener.enterIgnoredatom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIgnoredatom" ):
                listener.exitIgnoredatom(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIgnoredatom" ):
                return visitor.visitIgnoredatom(self)
            else:
                return visitor.visitChildren(self)




    def ignoredatom(self):

        localctx = RULEMLParser.IgnoredatomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_ignoredatom)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 380
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==RULEMLParser.SEA_WS:
                self.state = 377
                self.misc()
                self.state = 382
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 383
            self.match(RULEMLParser.ATOMOPEN)
            self.state = 387
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==RULEMLParser.SEA_WS:
                self.state = 384
                self.misc()
                self.state = 389
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 390
            self.statement()
            self.state = 394
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==RULEMLParser.SEA_WS:
                self.state = 391
                self.misc()
                self.state = 396
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 397
            self.subject()
            self.state = 401
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==RULEMLParser.SEA_WS:
                self.state = 398
                self.misc()
                self.state = 403
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 404
            self.ignoredpred()
            self.state = 408
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==RULEMLParser.SEA_WS:
                self.state = 405
                self.misc()
                self.state = 410
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 411
            self.unreserved_content()
            self.state = 415
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==RULEMLParser.SEA_WS:
                self.state = 412
                self.misc()
                self.state = 417
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 418
            self.match(RULEMLParser.ATOMCLOSE)
            self.state = 422
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,17,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 419
                    self.misc() 
                self.state = 424
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,17,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STATEMENT(self):
            return self.getToken(RULEMLParser.STATEMENT, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatement" ):
                listener.enterStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatement" ):
                listener.exitStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStatement" ):
                return visitor.visitStatement(self)
            else:
                return visitor.visitChildren(self)




    def statement(self):

        localctx = RULEMLParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 425
            self.match(RULEMLParser.STATEMENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubjectContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INDOPEN(self):
            return self.getToken(RULEMLParser.INDOPEN, 0)

        def subjectcontent(self):
            return self.getTypedRuleContext(RULEMLParser.SubjectcontentContext,0)


        def INDCLOSE(self):
            return self.getToken(RULEMLParser.INDCLOSE, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_subject

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubject" ):
                listener.enterSubject(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubject" ):
                listener.exitSubject(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubject" ):
                return visitor.visitSubject(self)
            else:
                return visitor.visitChildren(self)




    def subject(self):

        localctx = RULEMLParser.SubjectContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_subject)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 427
            self.match(RULEMLParser.INDOPEN)
            self.state = 428
            self.subjectcontent()
            self.state = 429
            self.match(RULEMLParser.INDCLOSE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PredicateContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INDOPEN(self):
            return self.getToken(RULEMLParser.INDOPEN, 0)

        def verb(self):
            return self.getTypedRuleContext(RULEMLParser.VerbContext,0)


        def INDCLOSE(self):
            return self.getToken(RULEMLParser.INDCLOSE, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_predicate

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPredicate" ):
                listener.enterPredicate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPredicate" ):
                listener.exitPredicate(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPredicate" ):
                return visitor.visitPredicate(self)
            else:
                return visitor.visitChildren(self)




    def predicate(self):

        localctx = RULEMLParser.PredicateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_predicate)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 431
            self.match(RULEMLParser.INDOPEN)
            self.state = 432
            self.verb()
            self.state = 433
            self.match(RULEMLParser.INDCLOSE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjektContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INDOPEN(self):
            return self.getToken(RULEMLParser.INDOPEN, 0)

        def objektcontent(self):
            return self.getTypedRuleContext(RULEMLParser.ObjektcontentContext,0)


        def INDCLOSE(self):
            return self.getToken(RULEMLParser.INDCLOSE, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_objekt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjekt" ):
                listener.enterObjekt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjekt" ):
                listener.exitObjekt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjekt" ):
                return visitor.visitObjekt(self)
            else:
                return visitor.visitChildren(self)




    def objekt(self):

        localctx = RULEMLParser.ObjektContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_objekt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 435
            self.match(RULEMLParser.INDOPEN)
            self.state = 436
            self.objektcontent()
            self.state = 437
            self.match(RULEMLParser.INDCLOSE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MiscContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SEA_WS(self):
            return self.getToken(RULEMLParser.SEA_WS, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_misc

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMisc" ):
                listener.enterMisc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMisc" ):
                listener.exitMisc(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMisc" ):
                return visitor.visitMisc(self)
            else:
                return visitor.visitChildren(self)




    def misc(self):

        localctx = RULEMLParser.MiscContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_misc)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 439
            self.match(RULEMLParser.SEA_WS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IgnoredpredContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INDOPEN(self):
            return self.getToken(RULEMLParser.INDOPEN, 0)

        def ignoredverb(self):
            return self.getTypedRuleContext(RULEMLParser.IgnoredverbContext,0)


        def INDCLOSE(self):
            return self.getToken(RULEMLParser.INDCLOSE, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_ignoredpred

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIgnoredpred" ):
                listener.enterIgnoredpred(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIgnoredpred" ):
                listener.exitIgnoredpred(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIgnoredpred" ):
                return visitor.visitIgnoredpred(self)
            else:
                return visitor.visitChildren(self)




    def ignoredpred(self):

        localctx = RULEMLParser.IgnoredpredContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_ignoredpred)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 441
            self.match(RULEMLParser.INDOPEN)
            self.state = 442
            self.ignoredverb()
            self.state = 443
            self.match(RULEMLParser.INDCLOSE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NodeidContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def N(self):
            return self.getToken(RULEMLParser.N, 0)

        def digit(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RULEMLParser.DigitContext)
            else:
                return self.getTypedRuleContext(RULEMLParser.DigitContext,i)


        def getRuleIndex(self):
            return RULEMLParser.RULE_nodeid

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNodeid" ):
                listener.enterNodeid(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNodeid" ):
                listener.exitNodeid(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNodeid" ):
                return visitor.visitNodeid(self)
            else:
                return visitor.visitChildren(self)




    def nodeid(self):

        localctx = RULEMLParser.NodeidContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_nodeid)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 445
            self.match(RULEMLParser.N)
            self.state = 446
            self.digit()
            self.state = 447
            self.digit()
            self.state = 448
            self.digit()
            self.state = 449
            self.digit()
            self.state = 450
            self.digit()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubjectcontentContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def iri(self):
            return self.getTypedRuleContext(RULEMLParser.IriContext,0)


        def nodeid(self):
            return self.getTypedRuleContext(RULEMLParser.NodeidContext,0)


        def unreserved(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RULEMLParser.UnreservedContext)
            else:
                return self.getTypedRuleContext(RULEMLParser.UnreservedContext,i)


        def getRuleIndex(self):
            return RULEMLParser.RULE_subjectcontent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubjectcontent" ):
                listener.enterSubjectcontent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubjectcontent" ):
                listener.exitSubjectcontent(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubjectcontent" ):
                return visitor.visitSubjectcontent(self)
            else:
                return visitor.visitChildren(self)




    def subjectcontent(self):

        localctx = RULEMLParser.SubjectcontentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_subjectcontent)
        self._la = 0 # Token type
        try:
            self.state = 460
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,19,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 452
                self.iri()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 453
                self.nodeid()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 457
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while ((((_la - 111)) & ~0x3f) == 0 and ((1 << (_la - 111)) & ((1 << (RULEMLParser.D0 - 111)) | (1 << (RULEMLParser.D1 - 111)) | (1 << (RULEMLParser.D2 - 111)) | (1 << (RULEMLParser.D3 - 111)) | (1 << (RULEMLParser.D4 - 111)) | (1 << (RULEMLParser.D5 - 111)) | (1 << (RULEMLParser.D6 - 111)) | (1 << (RULEMLParser.D7 - 111)) | (1 << (RULEMLParser.D8 - 111)) | (1 << (RULEMLParser.D9 - 111)) | (1 << (RULEMLParser.A - 111)) | (1 << (RULEMLParser.B - 111)) | (1 << (RULEMLParser.C - 111)) | (1 << (RULEMLParser.D - 111)) | (1 << (RULEMLParser.E - 111)) | (1 << (RULEMLParser.F - 111)) | (1 << (RULEMLParser.G - 111)) | (1 << (RULEMLParser.H - 111)) | (1 << (RULEMLParser.I - 111)) | (1 << (RULEMLParser.J - 111)) | (1 << (RULEMLParser.K - 111)) | (1 << (RULEMLParser.L - 111)) | (1 << (RULEMLParser.M - 111)) | (1 << (RULEMLParser.N - 111)) | (1 << (RULEMLParser.O - 111)) | (1 << (RULEMLParser.P - 111)) | (1 << (RULEMLParser.Q - 111)) | (1 << (RULEMLParser.R - 111)) | (1 << (RULEMLParser.S - 111)) | (1 << (RULEMLParser.T - 111)) | (1 << (RULEMLParser.U - 111)) | (1 << (RULEMLParser.V - 111)) | (1 << (RULEMLParser.W - 111)) | (1 << (RULEMLParser.X - 111)) | (1 << (RULEMLParser.Y - 111)) | (1 << (RULEMLParser.Z - 111)) | (1 << (RULEMLParser.DOT - 111)) | (1 << (RULEMLParser.HYPHEN - 111)) | (1 << (RULEMLParser.TILDE - 111)) | (1 << (RULEMLParser.USCORE - 111)))) != 0):
                    self.state = 454
                    self.unreserved()
                    self.state = 459
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjektcontentContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def iri(self):
            return self.getTypedRuleContext(RULEMLParser.IriContext,0)


        def nodeid(self):
            return self.getTypedRuleContext(RULEMLParser.NodeidContext,0)


        def verb(self):
            return self.getTypedRuleContext(RULEMLParser.VerbContext,0)


        def xsd(self):
            return self.getTypedRuleContext(RULEMLParser.XsdContext,0)


        def owlrestriction(self):
            return self.getTypedRuleContext(RULEMLParser.OwlrestrictionContext,0)


        def unreserved(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RULEMLParser.UnreservedContext)
            else:
                return self.getTypedRuleContext(RULEMLParser.UnreservedContext,i)


        def getRuleIndex(self):
            return RULEMLParser.RULE_objektcontent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjektcontent" ):
                listener.enterObjektcontent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjektcontent" ):
                listener.exitObjektcontent(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjektcontent" ):
                return visitor.visitObjektcontent(self)
            else:
                return visitor.visitChildren(self)




    def objektcontent(self):

        localctx = RULEMLParser.ObjektcontentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_objektcontent)
        self._la = 0 # Token type
        try:
            self.state = 473
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,21,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 462
                self.iri()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 463
                self.nodeid()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 464
                self.verb()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 465
                self.xsd()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 466
                self.owlrestriction()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 470
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while ((((_la - 111)) & ~0x3f) == 0 and ((1 << (_la - 111)) & ((1 << (RULEMLParser.D0 - 111)) | (1 << (RULEMLParser.D1 - 111)) | (1 << (RULEMLParser.D2 - 111)) | (1 << (RULEMLParser.D3 - 111)) | (1 << (RULEMLParser.D4 - 111)) | (1 << (RULEMLParser.D5 - 111)) | (1 << (RULEMLParser.D6 - 111)) | (1 << (RULEMLParser.D7 - 111)) | (1 << (RULEMLParser.D8 - 111)) | (1 << (RULEMLParser.D9 - 111)) | (1 << (RULEMLParser.A - 111)) | (1 << (RULEMLParser.B - 111)) | (1 << (RULEMLParser.C - 111)) | (1 << (RULEMLParser.D - 111)) | (1 << (RULEMLParser.E - 111)) | (1 << (RULEMLParser.F - 111)) | (1 << (RULEMLParser.G - 111)) | (1 << (RULEMLParser.H - 111)) | (1 << (RULEMLParser.I - 111)) | (1 << (RULEMLParser.J - 111)) | (1 << (RULEMLParser.K - 111)) | (1 << (RULEMLParser.L - 111)) | (1 << (RULEMLParser.M - 111)) | (1 << (RULEMLParser.N - 111)) | (1 << (RULEMLParser.O - 111)) | (1 << (RULEMLParser.P - 111)) | (1 << (RULEMLParser.Q - 111)) | (1 << (RULEMLParser.R - 111)) | (1 << (RULEMLParser.S - 111)) | (1 << (RULEMLParser.T - 111)) | (1 << (RULEMLParser.U - 111)) | (1 << (RULEMLParser.V - 111)) | (1 << (RULEMLParser.W - 111)) | (1 << (RULEMLParser.X - 111)) | (1 << (RULEMLParser.Y - 111)) | (1 << (RULEMLParser.Z - 111)) | (1 << (RULEMLParser.DOT - 111)) | (1 << (RULEMLParser.HYPHEN - 111)) | (1 << (RULEMLParser.TILDE - 111)) | (1 << (RULEMLParser.USCORE - 111)))) != 0):
                    self.state = 467
                    self.unreserved()
                    self.state = 472
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IgnoredverbContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def rdfscomment(self):
            return self.getTypedRuleContext(RULEMLParser.RdfscommentContext,0)


        def rdfslabel(self):
            return self.getTypedRuleContext(RULEMLParser.RdfslabelContext,0)


        def dcdescription(self):
            return self.getTypedRuleContext(RULEMLParser.DcdescriptionContext,0)


        def rdftype(self):
            return self.getTypedRuleContext(RULEMLParser.RdftypeContext,0)


        def seealso(self):
            return self.getTypedRuleContext(RULEMLParser.SeealsoContext,0)


        def rdfrest(self):
            return self.getTypedRuleContext(RULEMLParser.RdfrestContext,0)


        def skosdef(self):
            return self.getTypedRuleContext(RULEMLParser.SkosdefContext,0)


        def skospreflabel(self):
            return self.getTypedRuleContext(RULEMLParser.SkospreflabelContext,0)


        def skosaltlabel(self):
            return self.getTypedRuleContext(RULEMLParser.SkosaltlabelContext,0)


        def skoshiddenlabel(self):
            return self.getTypedRuleContext(RULEMLParser.SkoshiddenlabelContext,0)


        def skosnotation(self):
            return self.getTypedRuleContext(RULEMLParser.SkosnotationContext,0)


        def annotateds(self):
            return self.getTypedRuleContext(RULEMLParser.AnnotatedsContext,0)


        def annotatedp(self):
            return self.getTypedRuleContext(RULEMLParser.AnnotatedpContext,0)


        def annotatedt(self):
            return self.getTypedRuleContext(RULEMLParser.AnnotatedtContext,0)


        def isdefinedby(self):
            return self.getTypedRuleContext(RULEMLParser.IsdefinedbyContext,0)


        def versioninfo(self):
            return self.getTypedRuleContext(RULEMLParser.VersioninfoContext,0)


        def deprecated(self):
            return self.getTypedRuleContext(RULEMLParser.DeprecatedContext,0)


        def backcompatwith(self):
            return self.getTypedRuleContext(RULEMLParser.BackcompatwithContext,0)


        def incompatwith(self):
            return self.getTypedRuleContext(RULEMLParser.IncompatwithContext,0)


        def priorversion(self):
            return self.getTypedRuleContext(RULEMLParser.PriorversionContext,0)


        def dcsource(self):
            return self.getTypedRuleContext(RULEMLParser.DcsourceContext,0)


        def getRuleIndex(self):
            return RULEMLParser.RULE_ignoredverb

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIgnoredverb" ):
                listener.enterIgnoredverb(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIgnoredverb" ):
                listener.exitIgnoredverb(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIgnoredverb" ):
                return visitor.visitIgnoredverb(self)
            else:
                return visitor.visitChildren(self)




    def ignoredverb(self):

        localctx = RULEMLParser.IgnoredverbContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_ignoredverb)
        try:
            self.state = 496
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [RULEMLParser.RDFSCOMMENT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 475
                self.rdfscomment()
                pass
            elif token in [RULEMLParser.RDFSLABEL]:
                self.enterOuterAlt(localctx, 2)
                self.state = 476
                self.rdfslabel()
                pass
            elif token in [RULEMLParser.DCDESCRIPTION]:
                self.enterOuterAlt(localctx, 3)
                self.state = 477
                self.dcdescription()
                pass
            elif token in [RULEMLParser.RDFTYPE]:
                self.enterOuterAlt(localctx, 4)
                self.state = 478
                self.rdftype()
                pass
            elif token in [RULEMLParser.SEEALSO]:
                self.enterOuterAlt(localctx, 5)
                self.state = 479
                self.seealso()
                pass
            elif token in [RULEMLParser.RDFREST]:
                self.enterOuterAlt(localctx, 6)
                self.state = 480
                self.rdfrest()
                pass
            elif token in [RULEMLParser.SKOSDEF]:
                self.enterOuterAlt(localctx, 7)
                self.state = 481
                self.skosdef()
                pass
            elif token in [RULEMLParser.SKOSPREFLABEL]:
                self.enterOuterAlt(localctx, 8)
                self.state = 482
                self.skospreflabel()
                pass
            elif token in [RULEMLParser.SKOSALTLABEL]:
                self.enterOuterAlt(localctx, 9)
                self.state = 483
                self.skosaltlabel()
                pass
            elif token in [RULEMLParser.SKOSHIDDENLABEL]:
                self.enterOuterAlt(localctx, 10)
                self.state = 484
                self.skoshiddenlabel()
                pass
            elif token in [RULEMLParser.SKOSNOTATION]:
                self.enterOuterAlt(localctx, 11)
                self.state = 485
                self.skosnotation()
                pass
            elif token in [RULEMLParser.ANNOTATEDS]:
                self.enterOuterAlt(localctx, 12)
                self.state = 486
                self.annotateds()
                pass
            elif token in [RULEMLParser.ANNOTATEDP]:
                self.enterOuterAlt(localctx, 13)
                self.state = 487
                self.annotatedp()
                pass
            elif token in [RULEMLParser.ANNOTATEDT]:
                self.enterOuterAlt(localctx, 14)
                self.state = 488
                self.annotatedt()
                pass
            elif token in [RULEMLParser.ISDEFINEDBY]:
                self.enterOuterAlt(localctx, 15)
                self.state = 489
                self.isdefinedby()
                pass
            elif token in [RULEMLParser.VERSIONINFO]:
                self.enterOuterAlt(localctx, 16)
                self.state = 490
                self.versioninfo()
                pass
            elif token in [RULEMLParser.DEPRECATED]:
                self.enterOuterAlt(localctx, 17)
                self.state = 491
                self.deprecated()
                pass
            elif token in [RULEMLParser.BACKCOMPATWITH]:
                self.enterOuterAlt(localctx, 18)
                self.state = 492
                self.backcompatwith()
                pass
            elif token in [RULEMLParser.INCOMPATWITH]:
                self.enterOuterAlt(localctx, 19)
                self.state = 493
                self.incompatwith()
                pass
            elif token in [RULEMLParser.PRIORVERSION]:
                self.enterOuterAlt(localctx, 20)
                self.state = 494
                self.priorversion()
                pass
            elif token in [RULEMLParser.DCSOURCE]:
                self.enterOuterAlt(localctx, 21)
                self.state = 495
                self.dcsource()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VerbContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def subpropertyof(self):
            return self.getTypedRuleContext(RULEMLParser.SubpropertyofContext,0)


        def subclassof(self):
            return self.getTypedRuleContext(RULEMLParser.SubclassofContext,0)


        def rdfsdomain(self):
            return self.getTypedRuleContext(RULEMLParser.RdfsdomainContext,0)


        def rdfsrange(self):
            return self.getTypedRuleContext(RULEMLParser.RdfsrangeContext,0)


        def ondatatype(self):
            return self.getTypedRuleContext(RULEMLParser.OndatatypeContext,0)


        def owlwithrestrictions(self):
            return self.getTypedRuleContext(RULEMLParser.OwlwithrestrictionsContext,0)


        def equiclass(self):
            return self.getTypedRuleContext(RULEMLParser.EquiclassContext,0)


        def owlclass(self):
            return self.getTypedRuleContext(RULEMLParser.OwlclassContext,0)


        def rdfdescription(self):
            return self.getTypedRuleContext(RULEMLParser.RdfdescriptionContext,0)


        def intersectionof(self):
            return self.getTypedRuleContext(RULEMLParser.IntersectionofContext,0)


        def owlsvf(self):
            return self.getTypedRuleContext(RULEMLParser.OwlsvfContext,0)


        def owlavf(self):
            return self.getTypedRuleContext(RULEMLParser.OwlavfContext,0)


        def onproperty(self):
            return self.getTypedRuleContext(RULEMLParser.OnpropertyContext,0)


        def hasvalue(self):
            return self.getTypedRuleContext(RULEMLParser.HasvalueContext,0)


        def rdfsdatatype(self):
            return self.getTypedRuleContext(RULEMLParser.RdfsdatatypeContext,0)


        def minexclusive(self):
            return self.getTypedRuleContext(RULEMLParser.MinexclusiveContext,0)


        def maxexclusive(self):
            return self.getTypedRuleContext(RULEMLParser.MaxexclusiveContext,0)


        def xsddatatype(self):
            return self.getTypedRuleContext(RULEMLParser.XsddatatypeContext,0)


        def funcproperty(self):
            return self.getTypedRuleContext(RULEMLParser.FuncpropertyContext,0)


        def owlonclass(self):
            return self.getTypedRuleContext(RULEMLParser.OwlonclassContext,0)


        def owlondatarange(self):
            return self.getTypedRuleContext(RULEMLParser.OwlondatarangeContext,0)


        def owlqc(self):
            return self.getTypedRuleContext(RULEMLParser.OwlqcContext,0)


        def objectproperty(self):
            return self.getTypedRuleContext(RULEMLParser.ObjectpropertyContext,0)


        def rdfnil(self):
            return self.getTypedRuleContext(RULEMLParser.RdfnilContext,0)


        def unionof(self):
            return self.getTypedRuleContext(RULEMLParser.UnionofContext,0)


        def cardinality(self):
            return self.getTypedRuleContext(RULEMLParser.CardinalityContext,0)


        def hasself(self):
            return self.getTypedRuleContext(RULEMLParser.HasselfContext,0)


        def owlmaxc(self):
            return self.getTypedRuleContext(RULEMLParser.OwlmaxcContext,0)


        def owlmaxqc(self):
            return self.getTypedRuleContext(RULEMLParser.OwlmaxqcContext,0)


        def owlminc(self):
            return self.getTypedRuleContext(RULEMLParser.OwlmincContext,0)


        def owlminqc(self):
            return self.getTypedRuleContext(RULEMLParser.OwlminqcContext,0)


        def onproperties(self):
            return self.getTypedRuleContext(RULEMLParser.OnpropertiesContext,0)


        def complementof(self):
            return self.getTypedRuleContext(RULEMLParser.ComplementofContext,0)


        def oneof(self):
            return self.getTypedRuleContext(RULEMLParser.OneofContext,0)


        def topop(self):
            return self.getTypedRuleContext(RULEMLParser.TopopContext,0)


        def bottomop(self):
            return self.getTypedRuleContext(RULEMLParser.BottomopContext,0)


        def inverseof(self):
            return self.getTypedRuleContext(RULEMLParser.InverseofContext,0)


        def topdp(self):
            return self.getTypedRuleContext(RULEMLParser.TopdpContext,0)


        def bottomdp(self):
            return self.getTypedRuleContext(RULEMLParser.BottomdpContext,0)


        def datacomplementof(self):
            return self.getTypedRuleContext(RULEMLParser.DatacomplementofContext,0)


        def disjointwith(self):
            return self.getTypedRuleContext(RULEMLParser.DisjointwithContext,0)


        def alldisjointclasses(self):
            return self.getTypedRuleContext(RULEMLParser.AlldisjointclassesContext,0)


        def owlmembers(self):
            return self.getTypedRuleContext(RULEMLParser.OwlmembersContext,0)


        def disjointunionof(self):
            return self.getTypedRuleContext(RULEMLParser.DisjointunionofContext,0)


        def propertychainaxiom(self):
            return self.getTypedRuleContext(RULEMLParser.PropertychainaxiomContext,0)


        def equiproperty(self):
            return self.getTypedRuleContext(RULEMLParser.EquipropertyContext,0)


        def pdisjointwith(self):
            return self.getTypedRuleContext(RULEMLParser.PdisjointwithContext,0)


        def alldisjointp(self):
            return self.getTypedRuleContext(RULEMLParser.AlldisjointpContext,0)


        def inversefuncp(self):
            return self.getTypedRuleContext(RULEMLParser.InversefuncpContext,0)


        def reflexp(self):
            return self.getTypedRuleContext(RULEMLParser.ReflexpContext,0)


        def irreflexp(self):
            return self.getTypedRuleContext(RULEMLParser.IrreflexpContext,0)


        def symmp(self):
            return self.getTypedRuleContext(RULEMLParser.SymmpContext,0)


        def asymmp(self):
            return self.getTypedRuleContext(RULEMLParser.AsymmpContext,0)


        def transitivep(self):
            return self.getTypedRuleContext(RULEMLParser.TransitivepContext,0)


        def sameas(self):
            return self.getTypedRuleContext(RULEMLParser.SameasContext,0)


        def differentfrom(self):
            return self.getTypedRuleContext(RULEMLParser.DifferentfromContext,0)


        def alldifferent(self):
            return self.getTypedRuleContext(RULEMLParser.AlldifferentContext,0)


        def negpassert(self):
            return self.getTypedRuleContext(RULEMLParser.NegpassertContext,0)


        def sourceindividual(self):
            return self.getTypedRuleContext(RULEMLParser.SourceindividualContext,0)


        def assertp(self):
            return self.getTypedRuleContext(RULEMLParser.AssertpContext,0)


        def targetindividual(self):
            return self.getTypedRuleContext(RULEMLParser.TargetindividualContext,0)


        def targetvalue(self):
            return self.getTypedRuleContext(RULEMLParser.TargetvalueContext,0)


        def haskey(self):
            return self.getTypedRuleContext(RULEMLParser.HaskeyContext,0)


        def datatypep(self):
            return self.getTypedRuleContext(RULEMLParser.DatatypepContext,0)


        def annotationp(self):
            return self.getTypedRuleContext(RULEMLParser.AnnotationpContext,0)


        def namedindividual(self):
            return self.getTypedRuleContext(RULEMLParser.NamedindividualContext,0)


        def owlaxiom(self):
            return self.getTypedRuleContext(RULEMLParser.OwlaxiomContext,0)


        def owlannotation(self):
            return self.getTypedRuleContext(RULEMLParser.OwlannotationContext,0)


        def rdfsliteral(self):
            return self.getTypedRuleContext(RULEMLParser.RdfsliteralContext,0)


        def owlrational(self):
            return self.getTypedRuleContext(RULEMLParser.OwlrationalContext,0)


        def owlreal(self):
            return self.getTypedRuleContext(RULEMLParser.OwlrealContext,0)


        def rdfplainl(self):
            return self.getTypedRuleContext(RULEMLParser.RdfplainlContext,0)


        def xmlliteral(self):
            return self.getTypedRuleContext(RULEMLParser.XmlliteralContext,0)


        def rdflangrange(self):
            return self.getTypedRuleContext(RULEMLParser.RdflangrangeContext,0)


        def getRuleIndex(self):
            return RULEMLParser.RULE_verb

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVerb" ):
                listener.enterVerb(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVerb" ):
                listener.exitVerb(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVerb" ):
                return visitor.visitVerb(self)
            else:
                return visitor.visitChildren(self)




    def verb(self):

        localctx = RULEMLParser.VerbContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_verb)
        try:
            self.state = 572
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [RULEMLParser.SUBP]:
                self.enterOuterAlt(localctx, 1)
                self.state = 498
                self.subpropertyof()
                pass
            elif token in [RULEMLParser.SUBC]:
                self.enterOuterAlt(localctx, 2)
                self.state = 499
                self.subclassof()
                pass
            elif token in [RULEMLParser.RDFSDOMAIN]:
                self.enterOuterAlt(localctx, 3)
                self.state = 500
                self.rdfsdomain()
                pass
            elif token in [RULEMLParser.RDFSRANGE]:
                self.enterOuterAlt(localctx, 4)
                self.state = 501
                self.rdfsrange()
                pass
            elif token in [RULEMLParser.ONDATATYPE]:
                self.enterOuterAlt(localctx, 5)
                self.state = 502
                self.ondatatype()
                pass
            elif token in [RULEMLParser.WITHRESTRICTIONS]:
                self.enterOuterAlt(localctx, 6)
                self.state = 503
                self.owlwithrestrictions()
                pass
            elif token in [RULEMLParser.EQUICLASS]:
                self.enterOuterAlt(localctx, 7)
                self.state = 504
                self.equiclass()
                pass
            elif token in [RULEMLParser.OWLCLASS]:
                self.enterOuterAlt(localctx, 8)
                self.state = 505
                self.owlclass()
                pass
            elif token in [RULEMLParser.RDFDESCRIPTION]:
                self.enterOuterAlt(localctx, 9)
                self.state = 506
                self.rdfdescription()
                pass
            elif token in [RULEMLParser.INTERSECTIONOF]:
                self.enterOuterAlt(localctx, 10)
                self.state = 507
                self.intersectionof()
                pass
            elif token in [RULEMLParser.OWLSVF]:
                self.enterOuterAlt(localctx, 11)
                self.state = 508
                self.owlsvf()
                pass
            elif token in [RULEMLParser.OWLAVF]:
                self.enterOuterAlt(localctx, 12)
                self.state = 509
                self.owlavf()
                pass
            elif token in [RULEMLParser.ONP]:
                self.enterOuterAlt(localctx, 13)
                self.state = 510
                self.onproperty()
                pass
            elif token in [RULEMLParser.HASVALUE]:
                self.enterOuterAlt(localctx, 14)
                self.state = 511
                self.hasvalue()
                pass
            elif token in [RULEMLParser.RDFSDATATYPE]:
                self.enterOuterAlt(localctx, 15)
                self.state = 512
                self.rdfsdatatype()
                pass
            elif token in [RULEMLParser.MINEXCLUSIVE]:
                self.enterOuterAlt(localctx, 16)
                self.state = 513
                self.minexclusive()
                pass
            elif token in [RULEMLParser.MAXEXCLUSIVE]:
                self.enterOuterAlt(localctx, 17)
                self.state = 514
                self.maxexclusive()
                pass
            elif token in [RULEMLParser.XSD]:
                self.enterOuterAlt(localctx, 18)
                self.state = 515
                self.xsddatatype()
                pass
            elif token in [RULEMLParser.FUNCPROPERTY]:
                self.enterOuterAlt(localctx, 19)
                self.state = 516
                self.funcproperty()
                pass
            elif token in [RULEMLParser.OWLONCLASS]:
                self.enterOuterAlt(localctx, 20)
                self.state = 517
                self.owlonclass()
                pass
            elif token in [RULEMLParser.OWLONDATARANGE]:
                self.enterOuterAlt(localctx, 21)
                self.state = 518
                self.owlondatarange()
                pass
            elif token in [RULEMLParser.OWLQC]:
                self.enterOuterAlt(localctx, 22)
                self.state = 519
                self.owlqc()
                pass
            elif token in [RULEMLParser.OBJECTPROPERTY]:
                self.enterOuterAlt(localctx, 23)
                self.state = 520
                self.objectproperty()
                pass
            elif token in [RULEMLParser.RDFNIL]:
                self.enterOuterAlt(localctx, 24)
                self.state = 521
                self.rdfnil()
                pass
            elif token in [RULEMLParser.UNIONOF]:
                self.enterOuterAlt(localctx, 25)
                self.state = 522
                self.unionof()
                pass
            elif token in [RULEMLParser.CARDINALITY]:
                self.enterOuterAlt(localctx, 26)
                self.state = 523
                self.cardinality()
                pass
            elif token in [RULEMLParser.HASSELF]:
                self.enterOuterAlt(localctx, 27)
                self.state = 524
                self.hasself()
                pass
            elif token in [RULEMLParser.OWLMAXC]:
                self.enterOuterAlt(localctx, 28)
                self.state = 525
                self.owlmaxc()
                pass
            elif token in [RULEMLParser.OWLMAXQC]:
                self.enterOuterAlt(localctx, 29)
                self.state = 526
                self.owlmaxqc()
                pass
            elif token in [RULEMLParser.OWLMINC]:
                self.enterOuterAlt(localctx, 30)
                self.state = 527
                self.owlminc()
                pass
            elif token in [RULEMLParser.OWLMINQC]:
                self.enterOuterAlt(localctx, 31)
                self.state = 528
                self.owlminqc()
                pass
            elif token in [RULEMLParser.ONPROPERTIES]:
                self.enterOuterAlt(localctx, 32)
                self.state = 529
                self.onproperties()
                pass
            elif token in [RULEMLParser.COMPLEMENTOF]:
                self.enterOuterAlt(localctx, 33)
                self.state = 530
                self.complementof()
                pass
            elif token in [RULEMLParser.ONEOF]:
                self.enterOuterAlt(localctx, 34)
                self.state = 531
                self.oneof()
                pass
            elif token in [RULEMLParser.TOPOP]:
                self.enterOuterAlt(localctx, 35)
                self.state = 532
                self.topop()
                pass
            elif token in [RULEMLParser.BOTTOMOP]:
                self.enterOuterAlt(localctx, 36)
                self.state = 533
                self.bottomop()
                pass
            elif token in [RULEMLParser.INVERSEOF]:
                self.enterOuterAlt(localctx, 37)
                self.state = 534
                self.inverseof()
                pass
            elif token in [RULEMLParser.TOPDP]:
                self.enterOuterAlt(localctx, 38)
                self.state = 535
                self.topdp()
                pass
            elif token in [RULEMLParser.BOTTOMDP]:
                self.enterOuterAlt(localctx, 39)
                self.state = 536
                self.bottomdp()
                pass
            elif token in [RULEMLParser.DATACOMPLEMENTOF]:
                self.enterOuterAlt(localctx, 40)
                self.state = 537
                self.datacomplementof()
                pass
            elif token in [RULEMLParser.DISJOINTWITH]:
                self.enterOuterAlt(localctx, 41)
                self.state = 538
                self.disjointwith()
                pass
            elif token in [RULEMLParser.ALLDISJOINTCLASSES]:
                self.enterOuterAlt(localctx, 42)
                self.state = 539
                self.alldisjointclasses()
                pass
            elif token in [RULEMLParser.OWLMEMBERS]:
                self.enterOuterAlt(localctx, 43)
                self.state = 540
                self.owlmembers()
                pass
            elif token in [RULEMLParser.DISJOINTUNIONOF]:
                self.enterOuterAlt(localctx, 44)
                self.state = 541
                self.disjointunionof()
                pass
            elif token in [RULEMLParser.PROPERTYCHAINAXIOM]:
                self.enterOuterAlt(localctx, 45)
                self.state = 542
                self.propertychainaxiom()
                pass
            elif token in [RULEMLParser.EQUIPROPERTY]:
                self.enterOuterAlt(localctx, 46)
                self.state = 543
                self.equiproperty()
                pass
            elif token in [RULEMLParser.PDISJOINTWITH]:
                self.enterOuterAlt(localctx, 47)
                self.state = 544
                self.pdisjointwith()
                pass
            elif token in [RULEMLParser.ALLDISJOINTP]:
                self.enterOuterAlt(localctx, 48)
                self.state = 545
                self.alldisjointp()
                pass
            elif token in [RULEMLParser.INVERSEFUNCP]:
                self.enterOuterAlt(localctx, 49)
                self.state = 546
                self.inversefuncp()
                pass
            elif token in [RULEMLParser.REFLEXP]:
                self.enterOuterAlt(localctx, 50)
                self.state = 547
                self.reflexp()
                pass
            elif token in [RULEMLParser.IRREFLEXP]:
                self.enterOuterAlt(localctx, 51)
                self.state = 548
                self.irreflexp()
                pass
            elif token in [RULEMLParser.SYMMP]:
                self.enterOuterAlt(localctx, 52)
                self.state = 549
                self.symmp()
                pass
            elif token in [RULEMLParser.ASYMMP]:
                self.enterOuterAlt(localctx, 53)
                self.state = 550
                self.asymmp()
                pass
            elif token in [RULEMLParser.TRANSITIVEP]:
                self.enterOuterAlt(localctx, 54)
                self.state = 551
                self.transitivep()
                pass
            elif token in [RULEMLParser.SAMEAS]:
                self.enterOuterAlt(localctx, 55)
                self.state = 552
                self.sameas()
                pass
            elif token in [RULEMLParser.DIFFERENTFROM]:
                self.enterOuterAlt(localctx, 56)
                self.state = 553
                self.differentfrom()
                pass
            elif token in [RULEMLParser.ALLDIFFERENT]:
                self.enterOuterAlt(localctx, 57)
                self.state = 554
                self.alldifferent()
                pass
            elif token in [RULEMLParser.NEGPASSERT]:
                self.enterOuterAlt(localctx, 58)
                self.state = 555
                self.negpassert()
                pass
            elif token in [RULEMLParser.SOURCEINDIVIDUAL]:
                self.enterOuterAlt(localctx, 59)
                self.state = 556
                self.sourceindividual()
                pass
            elif token in [RULEMLParser.ASSERTP]:
                self.enterOuterAlt(localctx, 60)
                self.state = 557
                self.assertp()
                pass
            elif token in [RULEMLParser.TARGETINDIVIDUAL]:
                self.enterOuterAlt(localctx, 61)
                self.state = 558
                self.targetindividual()
                pass
            elif token in [RULEMLParser.TARGETVALUE]:
                self.enterOuterAlt(localctx, 62)
                self.state = 559
                self.targetvalue()
                pass
            elif token in [RULEMLParser.HASKEY]:
                self.enterOuterAlt(localctx, 63)
                self.state = 560
                self.haskey()
                pass
            elif token in [RULEMLParser.DATATYPEP]:
                self.enterOuterAlt(localctx, 64)
                self.state = 561
                self.datatypep()
                pass
            elif token in [RULEMLParser.ANNOTATIONP]:
                self.enterOuterAlt(localctx, 65)
                self.state = 562
                self.annotationp()
                pass
            elif token in [RULEMLParser.NAMEDINDIVIDUAL]:
                self.enterOuterAlt(localctx, 66)
                self.state = 563
                self.namedindividual()
                pass
            elif token in [RULEMLParser.OWLAXIOM]:
                self.enterOuterAlt(localctx, 67)
                self.state = 564
                self.owlaxiom()
                pass
            elif token in [RULEMLParser.OWLANNOTATION]:
                self.enterOuterAlt(localctx, 68)
                self.state = 565
                self.owlannotation()
                pass
            elif token in [RULEMLParser.RDFSLITERAL]:
                self.enterOuterAlt(localctx, 69)
                self.state = 566
                self.rdfsliteral()
                pass
            elif token in [RULEMLParser.OWLRATIONAL]:
                self.enterOuterAlt(localctx, 70)
                self.state = 567
                self.owlrational()
                pass
            elif token in [RULEMLParser.OWLREAL]:
                self.enterOuterAlt(localctx, 71)
                self.state = 568
                self.owlreal()
                pass
            elif token in [RULEMLParser.RDFPLAINL]:
                self.enterOuterAlt(localctx, 72)
                self.state = 569
                self.rdfplainl()
                pass
            elif token in [RULEMLParser.XMLLITERAL]:
                self.enterOuterAlt(localctx, 73)
                self.state = 570
                self.xmlliteral()
                pass
            elif token in [RULEMLParser.RDFLANGRANGE]:
                self.enterOuterAlt(localctx, 74)
                self.state = 571
                self.rdflangrange()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class XsdContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def xsdvalue(self):
            return self.getTypedRuleContext(RULEMLParser.XsdvalueContext,0)


        def POWER(self, i:int=None):
            if i is None:
                return self.getTokens(RULEMLParser.POWER)
            else:
                return self.getToken(RULEMLParser.POWER, i)

        def xsddatatype(self):
            return self.getTypedRuleContext(RULEMLParser.XsddatatypeContext,0)


        def getRuleIndex(self):
            return RULEMLParser.RULE_xsd

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterXsd" ):
                listener.enterXsd(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitXsd" ):
                listener.exitXsd(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitXsd" ):
                return visitor.visitXsd(self)
            else:
                return visitor.visitChildren(self)




    def xsd(self):

        localctx = RULEMLParser.XsdContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_xsd)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 574
            self.xsdvalue()
            self.state = 575
            self.match(RULEMLParser.POWER)
            self.state = 576
            self.match(RULEMLParser.POWER)
            self.state = 577
            self.xsddatatype()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class XsdvalueContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def digit(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RULEMLParser.DigitContext)
            else:
                return self.getTypedRuleContext(RULEMLParser.DigitContext,i)


        def DOT(self):
            return self.getToken(RULEMLParser.DOT, 0)

        def PLUS(self, i:int=None):
            if i is None:
                return self.getTokens(RULEMLParser.PLUS)
            else:
                return self.getToken(RULEMLParser.PLUS, i)

        def HYPHEN(self, i:int=None):
            if i is None:
                return self.getTokens(RULEMLParser.HYPHEN)
            else:
                return self.getToken(RULEMLParser.HYPHEN, i)

        def TRUE(self):
            return self.getToken(RULEMLParser.TRUE, 0)

        def FALSE(self):
            return self.getToken(RULEMLParser.FALSE, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_xsdvalue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterXsdvalue" ):
                listener.enterXsdvalue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitXsdvalue" ):
                listener.exitXsdvalue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitXsdvalue" ):
                return visitor.visitXsdvalue(self)
            else:
                return visitor.visitChildren(self)




    def xsdvalue(self):

        localctx = RULEMLParser.XsdvalueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_xsdvalue)
        self._la = 0 # Token type
        try:
            self.state = 601
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [RULEMLParser.D0, RULEMLParser.D1, RULEMLParser.D2, RULEMLParser.D3, RULEMLParser.D4, RULEMLParser.D5, RULEMLParser.D6, RULEMLParser.D7, RULEMLParser.D8, RULEMLParser.D9, RULEMLParser.HYPHEN, RULEMLParser.PLUS]:
                self.enterOuterAlt(localctx, 1)
                self.state = 582
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==RULEMLParser.HYPHEN or _la==RULEMLParser.PLUS:
                    self.state = 579
                    _la = self._input.LA(1)
                    if not(_la==RULEMLParser.HYPHEN or _la==RULEMLParser.PLUS):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 584
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 586 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 585
                        self.digit()

                    else:
                        raise NoViableAltException(self)
                    self.state = 588 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,25,self._ctx)

                self.state = 591
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==RULEMLParser.DOT:
                    self.state = 590
                    self.match(RULEMLParser.DOT)


                self.state = 596
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while ((((_la - 111)) & ~0x3f) == 0 and ((1 << (_la - 111)) & ((1 << (RULEMLParser.D0 - 111)) | (1 << (RULEMLParser.D1 - 111)) | (1 << (RULEMLParser.D2 - 111)) | (1 << (RULEMLParser.D3 - 111)) | (1 << (RULEMLParser.D4 - 111)) | (1 << (RULEMLParser.D5 - 111)) | (1 << (RULEMLParser.D6 - 111)) | (1 << (RULEMLParser.D7 - 111)) | (1 << (RULEMLParser.D8 - 111)) | (1 << (RULEMLParser.D9 - 111)))) != 0):
                    self.state = 593
                    self.digit()
                    self.state = 598
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            elif token in [RULEMLParser.TRUE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 599
                self.match(RULEMLParser.TRUE)
                pass
            elif token in [RULEMLParser.FALSE]:
                self.enterOuterAlt(localctx, 3)
                self.state = 600
                self.match(RULEMLParser.FALSE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class XsddatatypeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def XSD(self):
            return self.getToken(RULEMLParser.XSD, 0)

        def alpha(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RULEMLParser.AlphaContext)
            else:
                return self.getTypedRuleContext(RULEMLParser.AlphaContext,i)


        def getRuleIndex(self):
            return RULEMLParser.RULE_xsddatatype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterXsddatatype" ):
                listener.enterXsddatatype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitXsddatatype" ):
                listener.exitXsddatatype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitXsddatatype" ):
                return visitor.visitXsddatatype(self)
            else:
                return visitor.visitChildren(self)




    def xsddatatype(self):

        localctx = RULEMLParser.XsddatatypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_xsddatatype)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 603
            self.match(RULEMLParser.XSD)
            self.state = 605 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 604
                self.alpha()
                self.state = 607 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (((((_la - 121)) & ~0x3f) == 0 and ((1 << (_la - 121)) & ((1 << (RULEMLParser.A - 121)) | (1 << (RULEMLParser.B - 121)) | (1 << (RULEMLParser.C - 121)) | (1 << (RULEMLParser.D - 121)) | (1 << (RULEMLParser.E - 121)) | (1 << (RULEMLParser.F - 121)) | (1 << (RULEMLParser.G - 121)) | (1 << (RULEMLParser.H - 121)) | (1 << (RULEMLParser.I - 121)) | (1 << (RULEMLParser.J - 121)) | (1 << (RULEMLParser.K - 121)) | (1 << (RULEMLParser.L - 121)) | (1 << (RULEMLParser.M - 121)) | (1 << (RULEMLParser.N - 121)) | (1 << (RULEMLParser.O - 121)) | (1 << (RULEMLParser.P - 121)) | (1 << (RULEMLParser.Q - 121)) | (1 << (RULEMLParser.R - 121)) | (1 << (RULEMLParser.S - 121)) | (1 << (RULEMLParser.T - 121)) | (1 << (RULEMLParser.U - 121)) | (1 << (RULEMLParser.V - 121)) | (1 << (RULEMLParser.W - 121)) | (1 << (RULEMLParser.X - 121)) | (1 << (RULEMLParser.Y - 121)) | (1 << (RULEMLParser.Z - 121)))) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Unreserved_contentContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INDOPEN(self):
            return self.getToken(RULEMLParser.INDOPEN, 0)

        def INDCLOSE(self):
            return self.getToken(RULEMLParser.INDCLOSE, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_unreserved_content

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnreserved_content" ):
                listener.enterUnreserved_content(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnreserved_content" ):
                listener.exitUnreserved_content(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnreserved_content" ):
                return visitor.visitUnreserved_content(self)
            else:
                return visitor.visitChildren(self)




    def unreserved_content(self):

        localctx = RULEMLParser.Unreserved_contentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_unreserved_content)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 609
            self.match(RULEMLParser.INDOPEN)
            self.state = 613
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,30,self._ctx)
            while _alt!=1 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1+1:
                    self.state = 610
                    self.matchWildcard() 
                self.state = 615
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,30,self._ctx)

            self.state = 616
            self.match(RULEMLParser.INDCLOSE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RdfscommentContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RDFSCOMMENT(self):
            return self.getToken(RULEMLParser.RDFSCOMMENT, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_rdfscomment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRdfscomment" ):
                listener.enterRdfscomment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRdfscomment" ):
                listener.exitRdfscomment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRdfscomment" ):
                return visitor.visitRdfscomment(self)
            else:
                return visitor.visitChildren(self)




    def rdfscomment(self):

        localctx = RULEMLParser.RdfscommentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_rdfscomment)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 618
            self.match(RULEMLParser.RDFSCOMMENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RdfslabelContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RDFSLABEL(self):
            return self.getToken(RULEMLParser.RDFSLABEL, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_rdfslabel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRdfslabel" ):
                listener.enterRdfslabel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRdfslabel" ):
                listener.exitRdfslabel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRdfslabel" ):
                return visitor.visitRdfslabel(self)
            else:
                return visitor.visitChildren(self)




    def rdfslabel(self):

        localctx = RULEMLParser.RdfslabelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_rdfslabel)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 620
            self.match(RULEMLParser.RDFSLABEL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DcdescriptionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DCDESCRIPTION(self):
            return self.getToken(RULEMLParser.DCDESCRIPTION, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_dcdescription

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDcdescription" ):
                listener.enterDcdescription(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDcdescription" ):
                listener.exitDcdescription(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDcdescription" ):
                return visitor.visitDcdescription(self)
            else:
                return visitor.visitChildren(self)




    def dcdescription(self):

        localctx = RULEMLParser.DcdescriptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_dcdescription)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 622
            self.match(RULEMLParser.DCDESCRIPTION)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RdftypeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RDFTYPE(self):
            return self.getToken(RULEMLParser.RDFTYPE, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_rdftype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRdftype" ):
                listener.enterRdftype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRdftype" ):
                listener.exitRdftype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRdftype" ):
                return visitor.visitRdftype(self)
            else:
                return visitor.visitChildren(self)




    def rdftype(self):

        localctx = RULEMLParser.RdftypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_rdftype)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 624
            self.match(RULEMLParser.RDFTYPE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SeealsoContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SEEALSO(self):
            return self.getToken(RULEMLParser.SEEALSO, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_seealso

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSeealso" ):
                listener.enterSeealso(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSeealso" ):
                listener.exitSeealso(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSeealso" ):
                return visitor.visitSeealso(self)
            else:
                return visitor.visitChildren(self)




    def seealso(self):

        localctx = RULEMLParser.SeealsoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_seealso)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 626
            self.match(RULEMLParser.SEEALSO)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RdfrestContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RDFREST(self):
            return self.getToken(RULEMLParser.RDFREST, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_rdfrest

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRdfrest" ):
                listener.enterRdfrest(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRdfrest" ):
                listener.exitRdfrest(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRdfrest" ):
                return visitor.visitRdfrest(self)
            else:
                return visitor.visitChildren(self)




    def rdfrest(self):

        localctx = RULEMLParser.RdfrestContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_rdfrest)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 628
            self.match(RULEMLParser.RDFREST)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SkosdefContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SKOSDEF(self):
            return self.getToken(RULEMLParser.SKOSDEF, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_skosdef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSkosdef" ):
                listener.enterSkosdef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSkosdef" ):
                listener.exitSkosdef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSkosdef" ):
                return visitor.visitSkosdef(self)
            else:
                return visitor.visitChildren(self)




    def skosdef(self):

        localctx = RULEMLParser.SkosdefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_skosdef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 630
            self.match(RULEMLParser.SKOSDEF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SkospreflabelContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SKOSPREFLABEL(self):
            return self.getToken(RULEMLParser.SKOSPREFLABEL, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_skospreflabel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSkospreflabel" ):
                listener.enterSkospreflabel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSkospreflabel" ):
                listener.exitSkospreflabel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSkospreflabel" ):
                return visitor.visitSkospreflabel(self)
            else:
                return visitor.visitChildren(self)




    def skospreflabel(self):

        localctx = RULEMLParser.SkospreflabelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_skospreflabel)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 632
            self.match(RULEMLParser.SKOSPREFLABEL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SkosaltlabelContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SKOSALTLABEL(self):
            return self.getToken(RULEMLParser.SKOSALTLABEL, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_skosaltlabel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSkosaltlabel" ):
                listener.enterSkosaltlabel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSkosaltlabel" ):
                listener.exitSkosaltlabel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSkosaltlabel" ):
                return visitor.visitSkosaltlabel(self)
            else:
                return visitor.visitChildren(self)




    def skosaltlabel(self):

        localctx = RULEMLParser.SkosaltlabelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_skosaltlabel)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 634
            self.match(RULEMLParser.SKOSALTLABEL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SkoshiddenlabelContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SKOSHIDDENLABEL(self):
            return self.getToken(RULEMLParser.SKOSHIDDENLABEL, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_skoshiddenlabel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSkoshiddenlabel" ):
                listener.enterSkoshiddenlabel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSkoshiddenlabel" ):
                listener.exitSkoshiddenlabel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSkoshiddenlabel" ):
                return visitor.visitSkoshiddenlabel(self)
            else:
                return visitor.visitChildren(self)




    def skoshiddenlabel(self):

        localctx = RULEMLParser.SkoshiddenlabelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_skoshiddenlabel)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 636
            self.match(RULEMLParser.SKOSHIDDENLABEL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SkosnotationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SKOSNOTATION(self):
            return self.getToken(RULEMLParser.SKOSNOTATION, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_skosnotation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSkosnotation" ):
                listener.enterSkosnotation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSkosnotation" ):
                listener.exitSkosnotation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSkosnotation" ):
                return visitor.visitSkosnotation(self)
            else:
                return visitor.visitChildren(self)




    def skosnotation(self):

        localctx = RULEMLParser.SkosnotationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_skosnotation)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 638
            self.match(RULEMLParser.SKOSNOTATION)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AnnotatedsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ANNOTATEDS(self):
            return self.getToken(RULEMLParser.ANNOTATEDS, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_annotateds

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAnnotateds" ):
                listener.enterAnnotateds(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAnnotateds" ):
                listener.exitAnnotateds(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAnnotateds" ):
                return visitor.visitAnnotateds(self)
            else:
                return visitor.visitChildren(self)




    def annotateds(self):

        localctx = RULEMLParser.AnnotatedsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_annotateds)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 640
            self.match(RULEMLParser.ANNOTATEDS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AnnotatedpContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ANNOTATEDP(self):
            return self.getToken(RULEMLParser.ANNOTATEDP, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_annotatedp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAnnotatedp" ):
                listener.enterAnnotatedp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAnnotatedp" ):
                listener.exitAnnotatedp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAnnotatedp" ):
                return visitor.visitAnnotatedp(self)
            else:
                return visitor.visitChildren(self)




    def annotatedp(self):

        localctx = RULEMLParser.AnnotatedpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_annotatedp)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 642
            self.match(RULEMLParser.ANNOTATEDP)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AnnotatedtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ANNOTATEDT(self):
            return self.getToken(RULEMLParser.ANNOTATEDT, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_annotatedt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAnnotatedt" ):
                listener.enterAnnotatedt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAnnotatedt" ):
                listener.exitAnnotatedt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAnnotatedt" ):
                return visitor.visitAnnotatedt(self)
            else:
                return visitor.visitChildren(self)




    def annotatedt(self):

        localctx = RULEMLParser.AnnotatedtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_annotatedt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 644
            self.match(RULEMLParser.ANNOTATEDT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IsdefinedbyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ISDEFINEDBY(self):
            return self.getToken(RULEMLParser.ISDEFINEDBY, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_isdefinedby

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIsdefinedby" ):
                listener.enterIsdefinedby(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIsdefinedby" ):
                listener.exitIsdefinedby(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIsdefinedby" ):
                return visitor.visitIsdefinedby(self)
            else:
                return visitor.visitChildren(self)




    def isdefinedby(self):

        localctx = RULEMLParser.IsdefinedbyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_isdefinedby)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 646
            self.match(RULEMLParser.ISDEFINEDBY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VersioninfoContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VERSIONINFO(self):
            return self.getToken(RULEMLParser.VERSIONINFO, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_versioninfo

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVersioninfo" ):
                listener.enterVersioninfo(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVersioninfo" ):
                listener.exitVersioninfo(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVersioninfo" ):
                return visitor.visitVersioninfo(self)
            else:
                return visitor.visitChildren(self)




    def versioninfo(self):

        localctx = RULEMLParser.VersioninfoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_versioninfo)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 648
            self.match(RULEMLParser.VERSIONINFO)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeprecatedContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DEPRECATED(self):
            return self.getToken(RULEMLParser.DEPRECATED, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_deprecated

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeprecated" ):
                listener.enterDeprecated(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeprecated" ):
                listener.exitDeprecated(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeprecated" ):
                return visitor.visitDeprecated(self)
            else:
                return visitor.visitChildren(self)




    def deprecated(self):

        localctx = RULEMLParser.DeprecatedContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_deprecated)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 650
            self.match(RULEMLParser.DEPRECATED)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BackcompatwithContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BACKCOMPATWITH(self):
            return self.getToken(RULEMLParser.BACKCOMPATWITH, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_backcompatwith

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBackcompatwith" ):
                listener.enterBackcompatwith(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBackcompatwith" ):
                listener.exitBackcompatwith(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBackcompatwith" ):
                return visitor.visitBackcompatwith(self)
            else:
                return visitor.visitChildren(self)




    def backcompatwith(self):

        localctx = RULEMLParser.BackcompatwithContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_backcompatwith)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 652
            self.match(RULEMLParser.BACKCOMPATWITH)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IncompatwithContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INCOMPATWITH(self):
            return self.getToken(RULEMLParser.INCOMPATWITH, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_incompatwith

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIncompatwith" ):
                listener.enterIncompatwith(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIncompatwith" ):
                listener.exitIncompatwith(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIncompatwith" ):
                return visitor.visitIncompatwith(self)
            else:
                return visitor.visitChildren(self)




    def incompatwith(self):

        localctx = RULEMLParser.IncompatwithContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_incompatwith)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 654
            self.match(RULEMLParser.INCOMPATWITH)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PriorversionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PRIORVERSION(self):
            return self.getToken(RULEMLParser.PRIORVERSION, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_priorversion

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPriorversion" ):
                listener.enterPriorversion(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPriorversion" ):
                listener.exitPriorversion(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPriorversion" ):
                return visitor.visitPriorversion(self)
            else:
                return visitor.visitChildren(self)




    def priorversion(self):

        localctx = RULEMLParser.PriorversionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_priorversion)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 656
            self.match(RULEMLParser.PRIORVERSION)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DcsourceContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DCSOURCE(self):
            return self.getToken(RULEMLParser.DCSOURCE, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_dcsource

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDcsource" ):
                listener.enterDcsource(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDcsource" ):
                listener.exitDcsource(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDcsource" ):
                return visitor.visitDcsource(self)
            else:
                return visitor.visitChildren(self)




    def dcsource(self):

        localctx = RULEMLParser.DcsourceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_dcsource)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 658
            self.match(RULEMLParser.DCSOURCE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OndatatypeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ONDATATYPE(self):
            return self.getToken(RULEMLParser.ONDATATYPE, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_ondatatype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOndatatype" ):
                listener.enterOndatatype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOndatatype" ):
                listener.exitOndatatype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOndatatype" ):
                return visitor.visitOndatatype(self)
            else:
                return visitor.visitChildren(self)




    def ondatatype(self):

        localctx = RULEMLParser.OndatatypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_ondatatype)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 660
            self.match(RULEMLParser.ONDATATYPE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OwlwithrestrictionsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WITHRESTRICTIONS(self):
            return self.getToken(RULEMLParser.WITHRESTRICTIONS, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_owlwithrestrictions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOwlwithrestrictions" ):
                listener.enterOwlwithrestrictions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOwlwithrestrictions" ):
                listener.exitOwlwithrestrictions(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOwlwithrestrictions" ):
                return visitor.visitOwlwithrestrictions(self)
            else:
                return visitor.visitChildren(self)




    def owlwithrestrictions(self):

        localctx = RULEMLParser.OwlwithrestrictionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_owlwithrestrictions)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 662
            self.match(RULEMLParser.WITHRESTRICTIONS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubpropertyofContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SUBP(self):
            return self.getToken(RULEMLParser.SUBP, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_subpropertyof

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubpropertyof" ):
                listener.enterSubpropertyof(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubpropertyof" ):
                listener.exitSubpropertyof(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubpropertyof" ):
                return visitor.visitSubpropertyof(self)
            else:
                return visitor.visitChildren(self)




    def subpropertyof(self):

        localctx = RULEMLParser.SubpropertyofContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_subpropertyof)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 664
            self.match(RULEMLParser.SUBP)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubclassofContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SUBC(self):
            return self.getToken(RULEMLParser.SUBC, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_subclassof

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubclassof" ):
                listener.enterSubclassof(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubclassof" ):
                listener.exitSubclassof(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubclassof" ):
                return visitor.visitSubclassof(self)
            else:
                return visitor.visitChildren(self)




    def subclassof(self):

        localctx = RULEMLParser.SubclassofContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_subclassof)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 666
            self.match(RULEMLParser.SUBC)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RdfsdomainContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RDFSDOMAIN(self):
            return self.getToken(RULEMLParser.RDFSDOMAIN, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_rdfsdomain

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRdfsdomain" ):
                listener.enterRdfsdomain(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRdfsdomain" ):
                listener.exitRdfsdomain(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRdfsdomain" ):
                return visitor.visitRdfsdomain(self)
            else:
                return visitor.visitChildren(self)




    def rdfsdomain(self):

        localctx = RULEMLParser.RdfsdomainContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_rdfsdomain)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 668
            self.match(RULEMLParser.RDFSDOMAIN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RdfsrangeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RDFSRANGE(self):
            return self.getToken(RULEMLParser.RDFSRANGE, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_rdfsrange

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRdfsrange" ):
                listener.enterRdfsrange(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRdfsrange" ):
                listener.exitRdfsrange(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRdfsrange" ):
                return visitor.visitRdfsrange(self)
            else:
                return visitor.visitChildren(self)




    def rdfsrange(self):

        localctx = RULEMLParser.RdfsrangeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_rdfsrange)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 670
            self.match(RULEMLParser.RDFSRANGE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EquiclassContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQUICLASS(self):
            return self.getToken(RULEMLParser.EQUICLASS, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_equiclass

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEquiclass" ):
                listener.enterEquiclass(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEquiclass" ):
                listener.exitEquiclass(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEquiclass" ):
                return visitor.visitEquiclass(self)
            else:
                return visitor.visitChildren(self)




    def equiclass(self):

        localctx = RULEMLParser.EquiclassContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_equiclass)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 672
            self.match(RULEMLParser.EQUICLASS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OwlclassContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OWLCLASS(self):
            return self.getToken(RULEMLParser.OWLCLASS, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_owlclass

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOwlclass" ):
                listener.enterOwlclass(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOwlclass" ):
                listener.exitOwlclass(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOwlclass" ):
                return visitor.visitOwlclass(self)
            else:
                return visitor.visitChildren(self)




    def owlclass(self):

        localctx = RULEMLParser.OwlclassContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_owlclass)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 674
            self.match(RULEMLParser.OWLCLASS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RdfdescriptionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RDFDESCRIPTION(self):
            return self.getToken(RULEMLParser.RDFDESCRIPTION, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_rdfdescription

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRdfdescription" ):
                listener.enterRdfdescription(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRdfdescription" ):
                listener.exitRdfdescription(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRdfdescription" ):
                return visitor.visitRdfdescription(self)
            else:
                return visitor.visitChildren(self)




    def rdfdescription(self):

        localctx = RULEMLParser.RdfdescriptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_rdfdescription)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 676
            self.match(RULEMLParser.RDFDESCRIPTION)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IntersectionofContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTERSECTIONOF(self):
            return self.getToken(RULEMLParser.INTERSECTIONOF, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_intersectionof

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntersectionof" ):
                listener.enterIntersectionof(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntersectionof" ):
                listener.exitIntersectionof(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIntersectionof" ):
                return visitor.visitIntersectionof(self)
            else:
                return visitor.visitChildren(self)




    def intersectionof(self):

        localctx = RULEMLParser.IntersectionofContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_intersectionof)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 678
            self.match(RULEMLParser.INTERSECTIONOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OwlsvfContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OWLSVF(self):
            return self.getToken(RULEMLParser.OWLSVF, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_owlsvf

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOwlsvf" ):
                listener.enterOwlsvf(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOwlsvf" ):
                listener.exitOwlsvf(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOwlsvf" ):
                return visitor.visitOwlsvf(self)
            else:
                return visitor.visitChildren(self)




    def owlsvf(self):

        localctx = RULEMLParser.OwlsvfContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_owlsvf)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 680
            self.match(RULEMLParser.OWLSVF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OwlavfContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OWLAVF(self):
            return self.getToken(RULEMLParser.OWLAVF, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_owlavf

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOwlavf" ):
                listener.enterOwlavf(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOwlavf" ):
                listener.exitOwlavf(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOwlavf" ):
                return visitor.visitOwlavf(self)
            else:
                return visitor.visitChildren(self)




    def owlavf(self):

        localctx = RULEMLParser.OwlavfContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_owlavf)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 682
            self.match(RULEMLParser.OWLAVF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OnpropertyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ONP(self):
            return self.getToken(RULEMLParser.ONP, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_onproperty

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOnproperty" ):
                listener.enterOnproperty(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOnproperty" ):
                listener.exitOnproperty(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOnproperty" ):
                return visitor.visitOnproperty(self)
            else:
                return visitor.visitChildren(self)




    def onproperty(self):

        localctx = RULEMLParser.OnpropertyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_onproperty)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 684
            self.match(RULEMLParser.ONP)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HasvalueContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HASVALUE(self):
            return self.getToken(RULEMLParser.HASVALUE, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_hasvalue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHasvalue" ):
                listener.enterHasvalue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHasvalue" ):
                listener.exitHasvalue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHasvalue" ):
                return visitor.visitHasvalue(self)
            else:
                return visitor.visitChildren(self)




    def hasvalue(self):

        localctx = RULEMLParser.HasvalueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_hasvalue)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 686
            self.match(RULEMLParser.HASVALUE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MinexclusiveContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MINEXCLUSIVE(self):
            return self.getToken(RULEMLParser.MINEXCLUSIVE, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_minexclusive

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMinexclusive" ):
                listener.enterMinexclusive(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMinexclusive" ):
                listener.exitMinexclusive(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMinexclusive" ):
                return visitor.visitMinexclusive(self)
            else:
                return visitor.visitChildren(self)




    def minexclusive(self):

        localctx = RULEMLParser.MinexclusiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_minexclusive)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 688
            self.match(RULEMLParser.MINEXCLUSIVE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MaxexclusiveContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MAXEXCLUSIVE(self):
            return self.getToken(RULEMLParser.MAXEXCLUSIVE, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_maxexclusive

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMaxexclusive" ):
                listener.enterMaxexclusive(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMaxexclusive" ):
                listener.exitMaxexclusive(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMaxexclusive" ):
                return visitor.visitMaxexclusive(self)
            else:
                return visitor.visitChildren(self)




    def maxexclusive(self):

        localctx = RULEMLParser.MaxexclusiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_maxexclusive)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 690
            self.match(RULEMLParser.MAXEXCLUSIVE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OwlrestrictionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OWLRESTRICTION(self):
            return self.getToken(RULEMLParser.OWLRESTRICTION, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_owlrestriction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOwlrestriction" ):
                listener.enterOwlrestriction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOwlrestriction" ):
                listener.exitOwlrestriction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOwlrestriction" ):
                return visitor.visitOwlrestriction(self)
            else:
                return visitor.visitChildren(self)




    def owlrestriction(self):

        localctx = RULEMLParser.OwlrestrictionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_owlrestriction)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 692
            self.match(RULEMLParser.OWLRESTRICTION)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RdfsdatatypeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RDFSDATATYPE(self):
            return self.getToken(RULEMLParser.RDFSDATATYPE, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_rdfsdatatype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRdfsdatatype" ):
                listener.enterRdfsdatatype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRdfsdatatype" ):
                listener.exitRdfsdatatype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRdfsdatatype" ):
                return visitor.visitRdfsdatatype(self)
            else:
                return visitor.visitChildren(self)




    def rdfsdatatype(self):

        localctx = RULEMLParser.RdfsdatatypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_rdfsdatatype)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 694
            self.match(RULEMLParser.RDFSDATATYPE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FuncpropertyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FUNCPROPERTY(self):
            return self.getToken(RULEMLParser.FUNCPROPERTY, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_funcproperty

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFuncproperty" ):
                listener.enterFuncproperty(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFuncproperty" ):
                listener.exitFuncproperty(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFuncproperty" ):
                return visitor.visitFuncproperty(self)
            else:
                return visitor.visitChildren(self)




    def funcproperty(self):

        localctx = RULEMLParser.FuncpropertyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_funcproperty)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 696
            self.match(RULEMLParser.FUNCPROPERTY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OwlondatarangeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OWLONDATARANGE(self):
            return self.getToken(RULEMLParser.OWLONDATARANGE, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_owlondatarange

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOwlondatarange" ):
                listener.enterOwlondatarange(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOwlondatarange" ):
                listener.exitOwlondatarange(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOwlondatarange" ):
                return visitor.visitOwlondatarange(self)
            else:
                return visitor.visitChildren(self)




    def owlondatarange(self):

        localctx = RULEMLParser.OwlondatarangeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_owlondatarange)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 698
            self.match(RULEMLParser.OWLONDATARANGE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OwlonclassContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OWLONCLASS(self):
            return self.getToken(RULEMLParser.OWLONCLASS, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_owlonclass

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOwlonclass" ):
                listener.enterOwlonclass(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOwlonclass" ):
                listener.exitOwlonclass(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOwlonclass" ):
                return visitor.visitOwlonclass(self)
            else:
                return visitor.visitChildren(self)




    def owlonclass(self):

        localctx = RULEMLParser.OwlonclassContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_owlonclass)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 700
            self.match(RULEMLParser.OWLONCLASS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OwlqcContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OWLQC(self):
            return self.getToken(RULEMLParser.OWLQC, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_owlqc

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOwlqc" ):
                listener.enterOwlqc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOwlqc" ):
                listener.exitOwlqc(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOwlqc" ):
                return visitor.visitOwlqc(self)
            else:
                return visitor.visitChildren(self)




    def owlqc(self):

        localctx = RULEMLParser.OwlqcContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_owlqc)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 702
            self.match(RULEMLParser.OWLQC)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectpropertyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OBJECTPROPERTY(self):
            return self.getToken(RULEMLParser.OBJECTPROPERTY, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_objectproperty

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectproperty" ):
                listener.enterObjectproperty(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectproperty" ):
                listener.exitObjectproperty(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectproperty" ):
                return visitor.visitObjectproperty(self)
            else:
                return visitor.visitChildren(self)




    def objectproperty(self):

        localctx = RULEMLParser.ObjectpropertyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_objectproperty)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 704
            self.match(RULEMLParser.OBJECTPROPERTY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RdfnilContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RDFNIL(self):
            return self.getToken(RULEMLParser.RDFNIL, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_rdfnil

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRdfnil" ):
                listener.enterRdfnil(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRdfnil" ):
                listener.exitRdfnil(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRdfnil" ):
                return visitor.visitRdfnil(self)
            else:
                return visitor.visitChildren(self)




    def rdfnil(self):

        localctx = RULEMLParser.RdfnilContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_rdfnil)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 706
            self.match(RULEMLParser.RDFNIL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnionofContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UNIONOF(self):
            return self.getToken(RULEMLParser.UNIONOF, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_unionof

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnionof" ):
                listener.enterUnionof(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnionof" ):
                listener.exitUnionof(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnionof" ):
                return visitor.visitUnionof(self)
            else:
                return visitor.visitChildren(self)




    def unionof(self):

        localctx = RULEMLParser.UnionofContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_unionof)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 708
            self.match(RULEMLParser.UNIONOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CardinalityContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CARDINALITY(self):
            return self.getToken(RULEMLParser.CARDINALITY, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_cardinality

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCardinality" ):
                listener.enterCardinality(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCardinality" ):
                listener.exitCardinality(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCardinality" ):
                return visitor.visitCardinality(self)
            else:
                return visitor.visitChildren(self)




    def cardinality(self):

        localctx = RULEMLParser.CardinalityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_cardinality)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 710
            self.match(RULEMLParser.CARDINALITY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HasselfContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HASSELF(self):
            return self.getToken(RULEMLParser.HASSELF, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_hasself

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHasself" ):
                listener.enterHasself(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHasself" ):
                listener.exitHasself(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHasself" ):
                return visitor.visitHasself(self)
            else:
                return visitor.visitChildren(self)




    def hasself(self):

        localctx = RULEMLParser.HasselfContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_hasself)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 712
            self.match(RULEMLParser.HASSELF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OwlmaxcContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OWLMAXC(self):
            return self.getToken(RULEMLParser.OWLMAXC, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_owlmaxc

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOwlmaxc" ):
                listener.enterOwlmaxc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOwlmaxc" ):
                listener.exitOwlmaxc(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOwlmaxc" ):
                return visitor.visitOwlmaxc(self)
            else:
                return visitor.visitChildren(self)




    def owlmaxc(self):

        localctx = RULEMLParser.OwlmaxcContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_owlmaxc)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 714
            self.match(RULEMLParser.OWLMAXC)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OwlmaxqcContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OWLMAXQC(self):
            return self.getToken(RULEMLParser.OWLMAXQC, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_owlmaxqc

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOwlmaxqc" ):
                listener.enterOwlmaxqc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOwlmaxqc" ):
                listener.exitOwlmaxqc(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOwlmaxqc" ):
                return visitor.visitOwlmaxqc(self)
            else:
                return visitor.visitChildren(self)




    def owlmaxqc(self):

        localctx = RULEMLParser.OwlmaxqcContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_owlmaxqc)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 716
            self.match(RULEMLParser.OWLMAXQC)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OwlmincContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OWLMINC(self):
            return self.getToken(RULEMLParser.OWLMINC, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_owlminc

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOwlminc" ):
                listener.enterOwlminc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOwlminc" ):
                listener.exitOwlminc(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOwlminc" ):
                return visitor.visitOwlminc(self)
            else:
                return visitor.visitChildren(self)




    def owlminc(self):

        localctx = RULEMLParser.OwlmincContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_owlminc)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 718
            self.match(RULEMLParser.OWLMINC)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OwlminqcContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OWLMINQC(self):
            return self.getToken(RULEMLParser.OWLMINQC, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_owlminqc

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOwlminqc" ):
                listener.enterOwlminqc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOwlminqc" ):
                listener.exitOwlminqc(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOwlminqc" ):
                return visitor.visitOwlminqc(self)
            else:
                return visitor.visitChildren(self)




    def owlminqc(self):

        localctx = RULEMLParser.OwlminqcContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_owlminqc)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 720
            self.match(RULEMLParser.OWLMINQC)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OnpropertiesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ONPROPERTIES(self):
            return self.getToken(RULEMLParser.ONPROPERTIES, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_onproperties

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOnproperties" ):
                listener.enterOnproperties(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOnproperties" ):
                listener.exitOnproperties(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOnproperties" ):
                return visitor.visitOnproperties(self)
            else:
                return visitor.visitChildren(self)




    def onproperties(self):

        localctx = RULEMLParser.OnpropertiesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_onproperties)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 722
            self.match(RULEMLParser.ONPROPERTIES)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComplementofContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COMPLEMENTOF(self):
            return self.getToken(RULEMLParser.COMPLEMENTOF, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_complementof

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComplementof" ):
                listener.enterComplementof(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComplementof" ):
                listener.exitComplementof(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComplementof" ):
                return visitor.visitComplementof(self)
            else:
                return visitor.visitChildren(self)




    def complementof(self):

        localctx = RULEMLParser.ComplementofContext(self, self._ctx, self.state)
        self.enterRule(localctx, 142, self.RULE_complementof)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 724
            self.match(RULEMLParser.COMPLEMENTOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OneofContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ONEOF(self):
            return self.getToken(RULEMLParser.ONEOF, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_oneof

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOneof" ):
                listener.enterOneof(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOneof" ):
                listener.exitOneof(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOneof" ):
                return visitor.visitOneof(self)
            else:
                return visitor.visitChildren(self)




    def oneof(self):

        localctx = RULEMLParser.OneofContext(self, self._ctx, self.state)
        self.enterRule(localctx, 144, self.RULE_oneof)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 726
            self.match(RULEMLParser.ONEOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TopopContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TOPOP(self):
            return self.getToken(RULEMLParser.TOPOP, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_topop

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTopop" ):
                listener.enterTopop(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTopop" ):
                listener.exitTopop(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTopop" ):
                return visitor.visitTopop(self)
            else:
                return visitor.visitChildren(self)




    def topop(self):

        localctx = RULEMLParser.TopopContext(self, self._ctx, self.state)
        self.enterRule(localctx, 146, self.RULE_topop)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 728
            self.match(RULEMLParser.TOPOP)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BottomopContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BOTTOMOP(self):
            return self.getToken(RULEMLParser.BOTTOMOP, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_bottomop

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBottomop" ):
                listener.enterBottomop(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBottomop" ):
                listener.exitBottomop(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBottomop" ):
                return visitor.visitBottomop(self)
            else:
                return visitor.visitChildren(self)




    def bottomop(self):

        localctx = RULEMLParser.BottomopContext(self, self._ctx, self.state)
        self.enterRule(localctx, 148, self.RULE_bottomop)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 730
            self.match(RULEMLParser.BOTTOMOP)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InverseofContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INVERSEOF(self):
            return self.getToken(RULEMLParser.INVERSEOF, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_inverseof

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInverseof" ):
                listener.enterInverseof(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInverseof" ):
                listener.exitInverseof(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInverseof" ):
                return visitor.visitInverseof(self)
            else:
                return visitor.visitChildren(self)




    def inverseof(self):

        localctx = RULEMLParser.InverseofContext(self, self._ctx, self.state)
        self.enterRule(localctx, 150, self.RULE_inverseof)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 732
            self.match(RULEMLParser.INVERSEOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TopdpContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TOPDP(self):
            return self.getToken(RULEMLParser.TOPDP, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_topdp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTopdp" ):
                listener.enterTopdp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTopdp" ):
                listener.exitTopdp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTopdp" ):
                return visitor.visitTopdp(self)
            else:
                return visitor.visitChildren(self)




    def topdp(self):

        localctx = RULEMLParser.TopdpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 152, self.RULE_topdp)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 734
            self.match(RULEMLParser.TOPDP)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BottomdpContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BOTTOMDP(self):
            return self.getToken(RULEMLParser.BOTTOMDP, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_bottomdp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBottomdp" ):
                listener.enterBottomdp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBottomdp" ):
                listener.exitBottomdp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBottomdp" ):
                return visitor.visitBottomdp(self)
            else:
                return visitor.visitChildren(self)




    def bottomdp(self):

        localctx = RULEMLParser.BottomdpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 154, self.RULE_bottomdp)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 736
            self.match(RULEMLParser.BOTTOMDP)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatacomplementofContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DATACOMPLEMENTOF(self):
            return self.getToken(RULEMLParser.DATACOMPLEMENTOF, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_datacomplementof

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatacomplementof" ):
                listener.enterDatacomplementof(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatacomplementof" ):
                listener.exitDatacomplementof(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatacomplementof" ):
                return visitor.visitDatacomplementof(self)
            else:
                return visitor.visitChildren(self)




    def datacomplementof(self):

        localctx = RULEMLParser.DatacomplementofContext(self, self._ctx, self.state)
        self.enterRule(localctx, 156, self.RULE_datacomplementof)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 738
            self.match(RULEMLParser.DATACOMPLEMENTOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DisjointwithContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DISJOINTWITH(self):
            return self.getToken(RULEMLParser.DISJOINTWITH, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_disjointwith

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDisjointwith" ):
                listener.enterDisjointwith(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDisjointwith" ):
                listener.exitDisjointwith(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDisjointwith" ):
                return visitor.visitDisjointwith(self)
            else:
                return visitor.visitChildren(self)




    def disjointwith(self):

        localctx = RULEMLParser.DisjointwithContext(self, self._ctx, self.state)
        self.enterRule(localctx, 158, self.RULE_disjointwith)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 740
            self.match(RULEMLParser.DISJOINTWITH)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AlldisjointclassesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALLDISJOINTCLASSES(self):
            return self.getToken(RULEMLParser.ALLDISJOINTCLASSES, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_alldisjointclasses

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlldisjointclasses" ):
                listener.enterAlldisjointclasses(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlldisjointclasses" ):
                listener.exitAlldisjointclasses(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlldisjointclasses" ):
                return visitor.visitAlldisjointclasses(self)
            else:
                return visitor.visitChildren(self)




    def alldisjointclasses(self):

        localctx = RULEMLParser.AlldisjointclassesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 160, self.RULE_alldisjointclasses)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 742
            self.match(RULEMLParser.ALLDISJOINTCLASSES)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OwlmembersContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OWLMEMBERS(self):
            return self.getToken(RULEMLParser.OWLMEMBERS, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_owlmembers

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOwlmembers" ):
                listener.enterOwlmembers(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOwlmembers" ):
                listener.exitOwlmembers(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOwlmembers" ):
                return visitor.visitOwlmembers(self)
            else:
                return visitor.visitChildren(self)




    def owlmembers(self):

        localctx = RULEMLParser.OwlmembersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 162, self.RULE_owlmembers)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 744
            self.match(RULEMLParser.OWLMEMBERS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DisjointunionofContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DISJOINTUNIONOF(self):
            return self.getToken(RULEMLParser.DISJOINTUNIONOF, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_disjointunionof

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDisjointunionof" ):
                listener.enterDisjointunionof(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDisjointunionof" ):
                listener.exitDisjointunionof(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDisjointunionof" ):
                return visitor.visitDisjointunionof(self)
            else:
                return visitor.visitChildren(self)




    def disjointunionof(self):

        localctx = RULEMLParser.DisjointunionofContext(self, self._ctx, self.state)
        self.enterRule(localctx, 164, self.RULE_disjointunionof)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 746
            self.match(RULEMLParser.DISJOINTUNIONOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PropertychainaxiomContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PROPERTYCHAINAXIOM(self):
            return self.getToken(RULEMLParser.PROPERTYCHAINAXIOM, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_propertychainaxiom

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPropertychainaxiom" ):
                listener.enterPropertychainaxiom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPropertychainaxiom" ):
                listener.exitPropertychainaxiom(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPropertychainaxiom" ):
                return visitor.visitPropertychainaxiom(self)
            else:
                return visitor.visitChildren(self)




    def propertychainaxiom(self):

        localctx = RULEMLParser.PropertychainaxiomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 166, self.RULE_propertychainaxiom)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 748
            self.match(RULEMLParser.PROPERTYCHAINAXIOM)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EquipropertyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQUIPROPERTY(self):
            return self.getToken(RULEMLParser.EQUIPROPERTY, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_equiproperty

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEquiproperty" ):
                listener.enterEquiproperty(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEquiproperty" ):
                listener.exitEquiproperty(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEquiproperty" ):
                return visitor.visitEquiproperty(self)
            else:
                return visitor.visitChildren(self)




    def equiproperty(self):

        localctx = RULEMLParser.EquipropertyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 168, self.RULE_equiproperty)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 750
            self.match(RULEMLParser.EQUIPROPERTY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PdisjointwithContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PDISJOINTWITH(self):
            return self.getToken(RULEMLParser.PDISJOINTWITH, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_pdisjointwith

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPdisjointwith" ):
                listener.enterPdisjointwith(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPdisjointwith" ):
                listener.exitPdisjointwith(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPdisjointwith" ):
                return visitor.visitPdisjointwith(self)
            else:
                return visitor.visitChildren(self)




    def pdisjointwith(self):

        localctx = RULEMLParser.PdisjointwithContext(self, self._ctx, self.state)
        self.enterRule(localctx, 170, self.RULE_pdisjointwith)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 752
            self.match(RULEMLParser.PDISJOINTWITH)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AlldisjointpContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALLDISJOINTP(self):
            return self.getToken(RULEMLParser.ALLDISJOINTP, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_alldisjointp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlldisjointp" ):
                listener.enterAlldisjointp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlldisjointp" ):
                listener.exitAlldisjointp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlldisjointp" ):
                return visitor.visitAlldisjointp(self)
            else:
                return visitor.visitChildren(self)




    def alldisjointp(self):

        localctx = RULEMLParser.AlldisjointpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 172, self.RULE_alldisjointp)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 754
            self.match(RULEMLParser.ALLDISJOINTP)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InversefuncpContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INVERSEFUNCP(self):
            return self.getToken(RULEMLParser.INVERSEFUNCP, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_inversefuncp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInversefuncp" ):
                listener.enterInversefuncp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInversefuncp" ):
                listener.exitInversefuncp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInversefuncp" ):
                return visitor.visitInversefuncp(self)
            else:
                return visitor.visitChildren(self)




    def inversefuncp(self):

        localctx = RULEMLParser.InversefuncpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 174, self.RULE_inversefuncp)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 756
            self.match(RULEMLParser.INVERSEFUNCP)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReflexpContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REFLEXP(self):
            return self.getToken(RULEMLParser.REFLEXP, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_reflexp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReflexp" ):
                listener.enterReflexp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReflexp" ):
                listener.exitReflexp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReflexp" ):
                return visitor.visitReflexp(self)
            else:
                return visitor.visitChildren(self)




    def reflexp(self):

        localctx = RULEMLParser.ReflexpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 176, self.RULE_reflexp)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 758
            self.match(RULEMLParser.REFLEXP)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IrreflexpContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IRREFLEXP(self):
            return self.getToken(RULEMLParser.IRREFLEXP, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_irreflexp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIrreflexp" ):
                listener.enterIrreflexp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIrreflexp" ):
                listener.exitIrreflexp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIrreflexp" ):
                return visitor.visitIrreflexp(self)
            else:
                return visitor.visitChildren(self)




    def irreflexp(self):

        localctx = RULEMLParser.IrreflexpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 178, self.RULE_irreflexp)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 760
            self.match(RULEMLParser.IRREFLEXP)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SymmpContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SYMMP(self):
            return self.getToken(RULEMLParser.SYMMP, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_symmp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSymmp" ):
                listener.enterSymmp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSymmp" ):
                listener.exitSymmp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSymmp" ):
                return visitor.visitSymmp(self)
            else:
                return visitor.visitChildren(self)




    def symmp(self):

        localctx = RULEMLParser.SymmpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 180, self.RULE_symmp)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 762
            self.match(RULEMLParser.SYMMP)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AsymmpContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ASYMMP(self):
            return self.getToken(RULEMLParser.ASYMMP, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_asymmp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAsymmp" ):
                listener.enterAsymmp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAsymmp" ):
                listener.exitAsymmp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAsymmp" ):
                return visitor.visitAsymmp(self)
            else:
                return visitor.visitChildren(self)




    def asymmp(self):

        localctx = RULEMLParser.AsymmpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 182, self.RULE_asymmp)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 764
            self.match(RULEMLParser.ASYMMP)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TransitivepContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TRANSITIVEP(self):
            return self.getToken(RULEMLParser.TRANSITIVEP, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_transitivep

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTransitivep" ):
                listener.enterTransitivep(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTransitivep" ):
                listener.exitTransitivep(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTransitivep" ):
                return visitor.visitTransitivep(self)
            else:
                return visitor.visitChildren(self)




    def transitivep(self):

        localctx = RULEMLParser.TransitivepContext(self, self._ctx, self.state)
        self.enterRule(localctx, 184, self.RULE_transitivep)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 766
            self.match(RULEMLParser.TRANSITIVEP)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SameasContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SAMEAS(self):
            return self.getToken(RULEMLParser.SAMEAS, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_sameas

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSameas" ):
                listener.enterSameas(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSameas" ):
                listener.exitSameas(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSameas" ):
                return visitor.visitSameas(self)
            else:
                return visitor.visitChildren(self)




    def sameas(self):

        localctx = RULEMLParser.SameasContext(self, self._ctx, self.state)
        self.enterRule(localctx, 186, self.RULE_sameas)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 768
            self.match(RULEMLParser.SAMEAS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DifferentfromContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIFFERENTFROM(self):
            return self.getToken(RULEMLParser.DIFFERENTFROM, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_differentfrom

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDifferentfrom" ):
                listener.enterDifferentfrom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDifferentfrom" ):
                listener.exitDifferentfrom(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDifferentfrom" ):
                return visitor.visitDifferentfrom(self)
            else:
                return visitor.visitChildren(self)




    def differentfrom(self):

        localctx = RULEMLParser.DifferentfromContext(self, self._ctx, self.state)
        self.enterRule(localctx, 188, self.RULE_differentfrom)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 770
            self.match(RULEMLParser.DIFFERENTFROM)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AlldifferentContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALLDIFFERENT(self):
            return self.getToken(RULEMLParser.ALLDIFFERENT, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_alldifferent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlldifferent" ):
                listener.enterAlldifferent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlldifferent" ):
                listener.exitAlldifferent(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlldifferent" ):
                return visitor.visitAlldifferent(self)
            else:
                return visitor.visitChildren(self)




    def alldifferent(self):

        localctx = RULEMLParser.AlldifferentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 190, self.RULE_alldifferent)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 772
            self.match(RULEMLParser.ALLDIFFERENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NegpassertContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NEGPASSERT(self):
            return self.getToken(RULEMLParser.NEGPASSERT, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_negpassert

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNegpassert" ):
                listener.enterNegpassert(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNegpassert" ):
                listener.exitNegpassert(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNegpassert" ):
                return visitor.visitNegpassert(self)
            else:
                return visitor.visitChildren(self)




    def negpassert(self):

        localctx = RULEMLParser.NegpassertContext(self, self._ctx, self.state)
        self.enterRule(localctx, 192, self.RULE_negpassert)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 774
            self.match(RULEMLParser.NEGPASSERT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SourceindividualContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SOURCEINDIVIDUAL(self):
            return self.getToken(RULEMLParser.SOURCEINDIVIDUAL, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_sourceindividual

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSourceindividual" ):
                listener.enterSourceindividual(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSourceindividual" ):
                listener.exitSourceindividual(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSourceindividual" ):
                return visitor.visitSourceindividual(self)
            else:
                return visitor.visitChildren(self)




    def sourceindividual(self):

        localctx = RULEMLParser.SourceindividualContext(self, self._ctx, self.state)
        self.enterRule(localctx, 194, self.RULE_sourceindividual)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 776
            self.match(RULEMLParser.SOURCEINDIVIDUAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssertpContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ASSERTP(self):
            return self.getToken(RULEMLParser.ASSERTP, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_assertp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssertp" ):
                listener.enterAssertp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssertp" ):
                listener.exitAssertp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssertp" ):
                return visitor.visitAssertp(self)
            else:
                return visitor.visitChildren(self)




    def assertp(self):

        localctx = RULEMLParser.AssertpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 196, self.RULE_assertp)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 778
            self.match(RULEMLParser.ASSERTP)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TargetindividualContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TARGETINDIVIDUAL(self):
            return self.getToken(RULEMLParser.TARGETINDIVIDUAL, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_targetindividual

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTargetindividual" ):
                listener.enterTargetindividual(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTargetindividual" ):
                listener.exitTargetindividual(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTargetindividual" ):
                return visitor.visitTargetindividual(self)
            else:
                return visitor.visitChildren(self)




    def targetindividual(self):

        localctx = RULEMLParser.TargetindividualContext(self, self._ctx, self.state)
        self.enterRule(localctx, 198, self.RULE_targetindividual)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 780
            self.match(RULEMLParser.TARGETINDIVIDUAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TargetvalueContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TARGETVALUE(self):
            return self.getToken(RULEMLParser.TARGETVALUE, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_targetvalue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTargetvalue" ):
                listener.enterTargetvalue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTargetvalue" ):
                listener.exitTargetvalue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTargetvalue" ):
                return visitor.visitTargetvalue(self)
            else:
                return visitor.visitChildren(self)




    def targetvalue(self):

        localctx = RULEMLParser.TargetvalueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 200, self.RULE_targetvalue)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 782
            self.match(RULEMLParser.TARGETVALUE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HaskeyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HASKEY(self):
            return self.getToken(RULEMLParser.HASKEY, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_haskey

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHaskey" ):
                listener.enterHaskey(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHaskey" ):
                listener.exitHaskey(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHaskey" ):
                return visitor.visitHaskey(self)
            else:
                return visitor.visitChildren(self)




    def haskey(self):

        localctx = RULEMLParser.HaskeyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 202, self.RULE_haskey)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 784
            self.match(RULEMLParser.HASKEY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatatypepContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DATATYPEP(self):
            return self.getToken(RULEMLParser.DATATYPEP, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_datatypep

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatatypep" ):
                listener.enterDatatypep(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatatypep" ):
                listener.exitDatatypep(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatatypep" ):
                return visitor.visitDatatypep(self)
            else:
                return visitor.visitChildren(self)




    def datatypep(self):

        localctx = RULEMLParser.DatatypepContext(self, self._ctx, self.state)
        self.enterRule(localctx, 204, self.RULE_datatypep)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 786
            self.match(RULEMLParser.DATATYPEP)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AnnotationpContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ANNOTATIONP(self):
            return self.getToken(RULEMLParser.ANNOTATIONP, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_annotationp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAnnotationp" ):
                listener.enterAnnotationp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAnnotationp" ):
                listener.exitAnnotationp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAnnotationp" ):
                return visitor.visitAnnotationp(self)
            else:
                return visitor.visitChildren(self)




    def annotationp(self):

        localctx = RULEMLParser.AnnotationpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 206, self.RULE_annotationp)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 788
            self.match(RULEMLParser.ANNOTATIONP)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NamedindividualContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NAMEDINDIVIDUAL(self):
            return self.getToken(RULEMLParser.NAMEDINDIVIDUAL, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_namedindividual

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNamedindividual" ):
                listener.enterNamedindividual(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNamedindividual" ):
                listener.exitNamedindividual(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNamedindividual" ):
                return visitor.visitNamedindividual(self)
            else:
                return visitor.visitChildren(self)




    def namedindividual(self):

        localctx = RULEMLParser.NamedindividualContext(self, self._ctx, self.state)
        self.enterRule(localctx, 208, self.RULE_namedindividual)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 790
            self.match(RULEMLParser.NAMEDINDIVIDUAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OwlaxiomContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OWLAXIOM(self):
            return self.getToken(RULEMLParser.OWLAXIOM, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_owlaxiom

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOwlaxiom" ):
                listener.enterOwlaxiom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOwlaxiom" ):
                listener.exitOwlaxiom(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOwlaxiom" ):
                return visitor.visitOwlaxiom(self)
            else:
                return visitor.visitChildren(self)




    def owlaxiom(self):

        localctx = RULEMLParser.OwlaxiomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 210, self.RULE_owlaxiom)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 792
            self.match(RULEMLParser.OWLAXIOM)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OwlannotationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OWLANNOTATION(self):
            return self.getToken(RULEMLParser.OWLANNOTATION, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_owlannotation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOwlannotation" ):
                listener.enterOwlannotation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOwlannotation" ):
                listener.exitOwlannotation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOwlannotation" ):
                return visitor.visitOwlannotation(self)
            else:
                return visitor.visitChildren(self)




    def owlannotation(self):

        localctx = RULEMLParser.OwlannotationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 212, self.RULE_owlannotation)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 794
            self.match(RULEMLParser.OWLANNOTATION)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RdfsliteralContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RDFSLITERAL(self):
            return self.getToken(RULEMLParser.RDFSLITERAL, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_rdfsliteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRdfsliteral" ):
                listener.enterRdfsliteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRdfsliteral" ):
                listener.exitRdfsliteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRdfsliteral" ):
                return visitor.visitRdfsliteral(self)
            else:
                return visitor.visitChildren(self)




    def rdfsliteral(self):

        localctx = RULEMLParser.RdfsliteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 214, self.RULE_rdfsliteral)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 796
            self.match(RULEMLParser.RDFSLITERAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OwlrationalContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OWLRATIONAL(self):
            return self.getToken(RULEMLParser.OWLRATIONAL, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_owlrational

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOwlrational" ):
                listener.enterOwlrational(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOwlrational" ):
                listener.exitOwlrational(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOwlrational" ):
                return visitor.visitOwlrational(self)
            else:
                return visitor.visitChildren(self)




    def owlrational(self):

        localctx = RULEMLParser.OwlrationalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 216, self.RULE_owlrational)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 798
            self.match(RULEMLParser.OWLRATIONAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OwlrealContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OWLREAL(self):
            return self.getToken(RULEMLParser.OWLREAL, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_owlreal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOwlreal" ):
                listener.enterOwlreal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOwlreal" ):
                listener.exitOwlreal(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOwlreal" ):
                return visitor.visitOwlreal(self)
            else:
                return visitor.visitChildren(self)




    def owlreal(self):

        localctx = RULEMLParser.OwlrealContext(self, self._ctx, self.state)
        self.enterRule(localctx, 218, self.RULE_owlreal)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 800
            self.match(RULEMLParser.OWLREAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RdfplainlContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RDFPLAINL(self):
            return self.getToken(RULEMLParser.RDFPLAINL, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_rdfplainl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRdfplainl" ):
                listener.enterRdfplainl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRdfplainl" ):
                listener.exitRdfplainl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRdfplainl" ):
                return visitor.visitRdfplainl(self)
            else:
                return visitor.visitChildren(self)




    def rdfplainl(self):

        localctx = RULEMLParser.RdfplainlContext(self, self._ctx, self.state)
        self.enterRule(localctx, 220, self.RULE_rdfplainl)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 802
            self.match(RULEMLParser.RDFPLAINL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class XmlliteralContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def XMLLITERAL(self):
            return self.getToken(RULEMLParser.XMLLITERAL, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_xmlliteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterXmlliteral" ):
                listener.enterXmlliteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitXmlliteral" ):
                listener.exitXmlliteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitXmlliteral" ):
                return visitor.visitXmlliteral(self)
            else:
                return visitor.visitChildren(self)




    def xmlliteral(self):

        localctx = RULEMLParser.XmlliteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 222, self.RULE_xmlliteral)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 804
            self.match(RULEMLParser.XMLLITERAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RdflangrangeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RDFLANGRANGE(self):
            return self.getToken(RULEMLParser.RDFLANGRANGE, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_rdflangrange

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRdflangrange" ):
                listener.enterRdflangrange(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRdflangrange" ):
                listener.exitRdflangrange(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRdflangrange" ):
                return visitor.visitRdflangrange(self)
            else:
                return visitor.visitChildren(self)




    def rdflangrange(self):

        localctx = RULEMLParser.RdflangrangeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 224, self.RULE_rdflangrange)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 806
            self.match(RULEMLParser.RDFLANGRANGE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IriContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def scheme(self):
            return self.getTypedRuleContext(RULEMLParser.SchemeContext,0)


        def COL(self):
            return self.getToken(RULEMLParser.COL, 0)

        def ihier_part(self):
            return self.getTypedRuleContext(RULEMLParser.Ihier_partContext,0)


        def QMARK(self):
            return self.getToken(RULEMLParser.QMARK, 0)

        def iquery(self):
            return self.getTypedRuleContext(RULEMLParser.IqueryContext,0)


        def HASH(self):
            return self.getToken(RULEMLParser.HASH, 0)

        def ifragment(self):
            return self.getTypedRuleContext(RULEMLParser.IfragmentContext,0)


        def getRuleIndex(self):
            return RULEMLParser.RULE_iri

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIri" ):
                listener.enterIri(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIri" ):
                listener.exitIri(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIri" ):
                return visitor.visitIri(self)
            else:
                return visitor.visitChildren(self)




    def iri(self):

        localctx = RULEMLParser.IriContext(self, self._ctx, self.state)
        self.enterRule(localctx, 226, self.RULE_iri)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 808
            self.scheme()
            self.state = 809
            self.match(RULEMLParser.COL)
            self.state = 810
            self.ihier_part()
            self.state = 813
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==RULEMLParser.QMARK:
                self.state = 811
                self.match(RULEMLParser.QMARK)
                self.state = 812
                self.iquery()


            self.state = 817
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==RULEMLParser.HASH:
                self.state = 815
                self.match(RULEMLParser.HASH)
                self.state = 816
                self.ifragment()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Ihier_partContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FSLASH2(self):
            return self.getToken(RULEMLParser.FSLASH2, 0)

        def iauthority(self):
            return self.getTypedRuleContext(RULEMLParser.IauthorityContext,0)


        def ipath_abempty(self):
            return self.getTypedRuleContext(RULEMLParser.Ipath_abemptyContext,0)


        def ipath_absolute(self):
            return self.getTypedRuleContext(RULEMLParser.Ipath_absoluteContext,0)


        def ipath_rootless(self):
            return self.getTypedRuleContext(RULEMLParser.Ipath_rootlessContext,0)


        def ipath_empty(self):
            return self.getTypedRuleContext(RULEMLParser.Ipath_emptyContext,0)


        def getRuleIndex(self):
            return RULEMLParser.RULE_ihier_part

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIhier_part" ):
                listener.enterIhier_part(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIhier_part" ):
                listener.exitIhier_part(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIhier_part" ):
                return visitor.visitIhier_part(self)
            else:
                return visitor.visitChildren(self)




    def ihier_part(self):

        localctx = RULEMLParser.Ihier_partContext(self, self._ctx, self.state)
        self.enterRule(localctx, 228, self.RULE_ihier_part)
        try:
            self.state = 826
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [RULEMLParser.FSLASH2]:
                self.enterOuterAlt(localctx, 1)
                self.state = 819
                self.match(RULEMLParser.FSLASH2)
                self.state = 820
                self.iauthority()
                self.state = 821
                self.ipath_abempty()
                pass
            elif token in [RULEMLParser.FSLASH]:
                self.enterOuterAlt(localctx, 2)
                self.state = 823
                self.ipath_absolute()
                pass
            elif token in [RULEMLParser.UCSCHAR, RULEMLParser.D0, RULEMLParser.D1, RULEMLParser.D2, RULEMLParser.D3, RULEMLParser.D4, RULEMLParser.D5, RULEMLParser.D6, RULEMLParser.D7, RULEMLParser.D8, RULEMLParser.D9, RULEMLParser.A, RULEMLParser.B, RULEMLParser.C, RULEMLParser.D, RULEMLParser.E, RULEMLParser.F, RULEMLParser.G, RULEMLParser.H, RULEMLParser.I, RULEMLParser.J, RULEMLParser.K, RULEMLParser.L, RULEMLParser.M, RULEMLParser.N, RULEMLParser.O, RULEMLParser.P, RULEMLParser.Q, RULEMLParser.R, RULEMLParser.S, RULEMLParser.T, RULEMLParser.U, RULEMLParser.V, RULEMLParser.W, RULEMLParser.X, RULEMLParser.Y, RULEMLParser.Z, RULEMLParser.COL, RULEMLParser.DOT, RULEMLParser.PERCENT, RULEMLParser.HYPHEN, RULEMLParser.TILDE, RULEMLParser.USCORE, RULEMLParser.EXCL, RULEMLParser.DOLLAR, RULEMLParser.AMP, RULEMLParser.SQUOTE, RULEMLParser.OPAREN, RULEMLParser.CPAREN, RULEMLParser.STAR, RULEMLParser.PLUS, RULEMLParser.COMMA, RULEMLParser.SCOL, RULEMLParser.EQUALS, RULEMLParser.AT]:
                self.enterOuterAlt(localctx, 3)
                self.state = 824
                self.ipath_rootless()
                pass
            elif token in [RULEMLParser.EOF, RULEMLParser.INDCLOSE, RULEMLParser.QMARK, RULEMLParser.HASH]:
                self.enterOuterAlt(localctx, 4)
                self.state = 825
                self.ipath_empty()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Iri_referenceContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def iri(self):
            return self.getTypedRuleContext(RULEMLParser.IriContext,0)


        def irelative_ref(self):
            return self.getTypedRuleContext(RULEMLParser.Irelative_refContext,0)


        def getRuleIndex(self):
            return RULEMLParser.RULE_iri_reference

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIri_reference" ):
                listener.enterIri_reference(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIri_reference" ):
                listener.exitIri_reference(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIri_reference" ):
                return visitor.visitIri_reference(self)
            else:
                return visitor.visitChildren(self)




    def iri_reference(self):

        localctx = RULEMLParser.Iri_referenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 230, self.RULE_iri_reference)
        try:
            self.state = 830
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,34,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 828
                self.iri()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 829
                self.irelative_ref()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Absolute_iriContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def scheme(self):
            return self.getTypedRuleContext(RULEMLParser.SchemeContext,0)


        def COL(self):
            return self.getToken(RULEMLParser.COL, 0)

        def ihier_part(self):
            return self.getTypedRuleContext(RULEMLParser.Ihier_partContext,0)


        def QMARK(self):
            return self.getToken(RULEMLParser.QMARK, 0)

        def iquery(self):
            return self.getTypedRuleContext(RULEMLParser.IqueryContext,0)


        def getRuleIndex(self):
            return RULEMLParser.RULE_absolute_iri

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAbsolute_iri" ):
                listener.enterAbsolute_iri(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAbsolute_iri" ):
                listener.exitAbsolute_iri(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAbsolute_iri" ):
                return visitor.visitAbsolute_iri(self)
            else:
                return visitor.visitChildren(self)




    def absolute_iri(self):

        localctx = RULEMLParser.Absolute_iriContext(self, self._ctx, self.state)
        self.enterRule(localctx, 232, self.RULE_absolute_iri)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 832
            self.scheme()
            self.state = 833
            self.match(RULEMLParser.COL)
            self.state = 834
            self.ihier_part()
            self.state = 837
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==RULEMLParser.QMARK:
                self.state = 835
                self.match(RULEMLParser.QMARK)
                self.state = 836
                self.iquery()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Irelative_refContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def irelative_part(self):
            return self.getTypedRuleContext(RULEMLParser.Irelative_partContext,0)


        def QMARK(self):
            return self.getToken(RULEMLParser.QMARK, 0)

        def iquery(self):
            return self.getTypedRuleContext(RULEMLParser.IqueryContext,0)


        def HASH(self):
            return self.getToken(RULEMLParser.HASH, 0)

        def ifragment(self):
            return self.getTypedRuleContext(RULEMLParser.IfragmentContext,0)


        def getRuleIndex(self):
            return RULEMLParser.RULE_irelative_ref

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIrelative_ref" ):
                listener.enterIrelative_ref(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIrelative_ref" ):
                listener.exitIrelative_ref(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIrelative_ref" ):
                return visitor.visitIrelative_ref(self)
            else:
                return visitor.visitChildren(self)




    def irelative_ref(self):

        localctx = RULEMLParser.Irelative_refContext(self, self._ctx, self.state)
        self.enterRule(localctx, 234, self.RULE_irelative_ref)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 839
            self.irelative_part()
            self.state = 842
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==RULEMLParser.QMARK:
                self.state = 840
                self.match(RULEMLParser.QMARK)
                self.state = 841
                self.iquery()


            self.state = 846
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==RULEMLParser.HASH:
                self.state = 844
                self.match(RULEMLParser.HASH)
                self.state = 845
                self.ifragment()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Irelative_partContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FSLASH2(self):
            return self.getToken(RULEMLParser.FSLASH2, 0)

        def iauthority(self):
            return self.getTypedRuleContext(RULEMLParser.IauthorityContext,0)


        def ipath_abempty(self):
            return self.getTypedRuleContext(RULEMLParser.Ipath_abemptyContext,0)


        def ipath_absolute(self):
            return self.getTypedRuleContext(RULEMLParser.Ipath_absoluteContext,0)


        def ipath_noscheme(self):
            return self.getTypedRuleContext(RULEMLParser.Ipath_noschemeContext,0)


        def ipath_empty(self):
            return self.getTypedRuleContext(RULEMLParser.Ipath_emptyContext,0)


        def getRuleIndex(self):
            return RULEMLParser.RULE_irelative_part

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIrelative_part" ):
                listener.enterIrelative_part(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIrelative_part" ):
                listener.exitIrelative_part(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIrelative_part" ):
                return visitor.visitIrelative_part(self)
            else:
                return visitor.visitChildren(self)




    def irelative_part(self):

        localctx = RULEMLParser.Irelative_partContext(self, self._ctx, self.state)
        self.enterRule(localctx, 236, self.RULE_irelative_part)
        try:
            self.state = 855
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [RULEMLParser.FSLASH2]:
                self.enterOuterAlt(localctx, 1)
                self.state = 848
                self.match(RULEMLParser.FSLASH2)
                self.state = 849
                self.iauthority()
                self.state = 850
                self.ipath_abempty()
                pass
            elif token in [RULEMLParser.FSLASH]:
                self.enterOuterAlt(localctx, 2)
                self.state = 852
                self.ipath_absolute()
                pass
            elif token in [RULEMLParser.UCSCHAR, RULEMLParser.D0, RULEMLParser.D1, RULEMLParser.D2, RULEMLParser.D3, RULEMLParser.D4, RULEMLParser.D5, RULEMLParser.D6, RULEMLParser.D7, RULEMLParser.D8, RULEMLParser.D9, RULEMLParser.A, RULEMLParser.B, RULEMLParser.C, RULEMLParser.D, RULEMLParser.E, RULEMLParser.F, RULEMLParser.G, RULEMLParser.H, RULEMLParser.I, RULEMLParser.J, RULEMLParser.K, RULEMLParser.L, RULEMLParser.M, RULEMLParser.N, RULEMLParser.O, RULEMLParser.P, RULEMLParser.Q, RULEMLParser.R, RULEMLParser.S, RULEMLParser.T, RULEMLParser.U, RULEMLParser.V, RULEMLParser.W, RULEMLParser.X, RULEMLParser.Y, RULEMLParser.Z, RULEMLParser.DOT, RULEMLParser.PERCENT, RULEMLParser.HYPHEN, RULEMLParser.TILDE, RULEMLParser.USCORE, RULEMLParser.EXCL, RULEMLParser.DOLLAR, RULEMLParser.AMP, RULEMLParser.SQUOTE, RULEMLParser.OPAREN, RULEMLParser.CPAREN, RULEMLParser.STAR, RULEMLParser.PLUS, RULEMLParser.COMMA, RULEMLParser.SCOL, RULEMLParser.EQUALS, RULEMLParser.AT]:
                self.enterOuterAlt(localctx, 3)
                self.state = 853
                self.ipath_noscheme()
                pass
            elif token in [RULEMLParser.EOF, RULEMLParser.QMARK, RULEMLParser.HASH]:
                self.enterOuterAlt(localctx, 4)
                self.state = 854
                self.ipath_empty()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IauthorityContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ihost(self):
            return self.getTypedRuleContext(RULEMLParser.IhostContext,0)


        def iuserinfo(self):
            return self.getTypedRuleContext(RULEMLParser.IuserinfoContext,0)


        def AT(self):
            return self.getToken(RULEMLParser.AT, 0)

        def COL(self):
            return self.getToken(RULEMLParser.COL, 0)

        def port(self):
            return self.getTypedRuleContext(RULEMLParser.PortContext,0)


        def getRuleIndex(self):
            return RULEMLParser.RULE_iauthority

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIauthority" ):
                listener.enterIauthority(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIauthority" ):
                listener.exitIauthority(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIauthority" ):
                return visitor.visitIauthority(self)
            else:
                return visitor.visitChildren(self)




    def iauthority(self):

        localctx = RULEMLParser.IauthorityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 238, self.RULE_iauthority)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 860
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,39,self._ctx)
            if la_ == 1:
                self.state = 857
                self.iuserinfo()
                self.state = 858
                self.match(RULEMLParser.AT)


            self.state = 862
            self.ihost()
            self.state = 865
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==RULEMLParser.COL:
                self.state = 863
                self.match(RULEMLParser.COL)
                self.state = 864
                self.port()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IuserinfoContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def iunreserved(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RULEMLParser.IunreservedContext)
            else:
                return self.getTypedRuleContext(RULEMLParser.IunreservedContext,i)


        def pct_encoded(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RULEMLParser.Pct_encodedContext)
            else:
                return self.getTypedRuleContext(RULEMLParser.Pct_encodedContext,i)


        def sub_delims(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RULEMLParser.Sub_delimsContext)
            else:
                return self.getTypedRuleContext(RULEMLParser.Sub_delimsContext,i)


        def COL(self, i:int=None):
            if i is None:
                return self.getTokens(RULEMLParser.COL)
            else:
                return self.getToken(RULEMLParser.COL, i)

        def getRuleIndex(self):
            return RULEMLParser.RULE_iuserinfo

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIuserinfo" ):
                listener.enterIuserinfo(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIuserinfo" ):
                listener.exitIuserinfo(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIuserinfo" ):
                return visitor.visitIuserinfo(self)
            else:
                return visitor.visitChildren(self)




    def iuserinfo(self):

        localctx = RULEMLParser.IuserinfoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 240, self.RULE_iuserinfo)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 873
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 109)) & ~0x3f) == 0 and ((1 << (_la - 109)) & ((1 << (RULEMLParser.UCSCHAR - 109)) | (1 << (RULEMLParser.D0 - 109)) | (1 << (RULEMLParser.D1 - 109)) | (1 << (RULEMLParser.D2 - 109)) | (1 << (RULEMLParser.D3 - 109)) | (1 << (RULEMLParser.D4 - 109)) | (1 << (RULEMLParser.D5 - 109)) | (1 << (RULEMLParser.D6 - 109)) | (1 << (RULEMLParser.D7 - 109)) | (1 << (RULEMLParser.D8 - 109)) | (1 << (RULEMLParser.D9 - 109)) | (1 << (RULEMLParser.A - 109)) | (1 << (RULEMLParser.B - 109)) | (1 << (RULEMLParser.C - 109)) | (1 << (RULEMLParser.D - 109)) | (1 << (RULEMLParser.E - 109)) | (1 << (RULEMLParser.F - 109)) | (1 << (RULEMLParser.G - 109)) | (1 << (RULEMLParser.H - 109)) | (1 << (RULEMLParser.I - 109)) | (1 << (RULEMLParser.J - 109)) | (1 << (RULEMLParser.K - 109)) | (1 << (RULEMLParser.L - 109)) | (1 << (RULEMLParser.M - 109)) | (1 << (RULEMLParser.N - 109)) | (1 << (RULEMLParser.O - 109)) | (1 << (RULEMLParser.P - 109)) | (1 << (RULEMLParser.Q - 109)) | (1 << (RULEMLParser.R - 109)) | (1 << (RULEMLParser.S - 109)) | (1 << (RULEMLParser.T - 109)) | (1 << (RULEMLParser.U - 109)) | (1 << (RULEMLParser.V - 109)) | (1 << (RULEMLParser.W - 109)) | (1 << (RULEMLParser.X - 109)) | (1 << (RULEMLParser.Y - 109)) | (1 << (RULEMLParser.Z - 109)) | (1 << (RULEMLParser.COL - 109)) | (1 << (RULEMLParser.DOT - 109)) | (1 << (RULEMLParser.PERCENT - 109)) | (1 << (RULEMLParser.HYPHEN - 109)) | (1 << (RULEMLParser.TILDE - 109)) | (1 << (RULEMLParser.USCORE - 109)) | (1 << (RULEMLParser.EXCL - 109)) | (1 << (RULEMLParser.DOLLAR - 109)) | (1 << (RULEMLParser.AMP - 109)) | (1 << (RULEMLParser.SQUOTE - 109)) | (1 << (RULEMLParser.OPAREN - 109)) | (1 << (RULEMLParser.CPAREN - 109)) | (1 << (RULEMLParser.STAR - 109)) | (1 << (RULEMLParser.PLUS - 109)) | (1 << (RULEMLParser.COMMA - 109)) | (1 << (RULEMLParser.SCOL - 109)) | (1 << (RULEMLParser.EQUALS - 109)))) != 0):
                self.state = 871
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [RULEMLParser.UCSCHAR, RULEMLParser.D0, RULEMLParser.D1, RULEMLParser.D2, RULEMLParser.D3, RULEMLParser.D4, RULEMLParser.D5, RULEMLParser.D6, RULEMLParser.D7, RULEMLParser.D8, RULEMLParser.D9, RULEMLParser.A, RULEMLParser.B, RULEMLParser.C, RULEMLParser.D, RULEMLParser.E, RULEMLParser.F, RULEMLParser.G, RULEMLParser.H, RULEMLParser.I, RULEMLParser.J, RULEMLParser.K, RULEMLParser.L, RULEMLParser.M, RULEMLParser.N, RULEMLParser.O, RULEMLParser.P, RULEMLParser.Q, RULEMLParser.R, RULEMLParser.S, RULEMLParser.T, RULEMLParser.U, RULEMLParser.V, RULEMLParser.W, RULEMLParser.X, RULEMLParser.Y, RULEMLParser.Z, RULEMLParser.DOT, RULEMLParser.HYPHEN, RULEMLParser.TILDE, RULEMLParser.USCORE]:
                    self.state = 867
                    self.iunreserved()
                    pass
                elif token in [RULEMLParser.PERCENT]:
                    self.state = 868
                    self.pct_encoded()
                    pass
                elif token in [RULEMLParser.EXCL, RULEMLParser.DOLLAR, RULEMLParser.AMP, RULEMLParser.SQUOTE, RULEMLParser.OPAREN, RULEMLParser.CPAREN, RULEMLParser.STAR, RULEMLParser.PLUS, RULEMLParser.COMMA, RULEMLParser.SCOL, RULEMLParser.EQUALS]:
                    self.state = 869
                    self.sub_delims()
                    pass
                elif token in [RULEMLParser.COL]:
                    self.state = 870
                    self.match(RULEMLParser.COL)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 875
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IhostContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ip_literal(self):
            return self.getTypedRuleContext(RULEMLParser.Ip_literalContext,0)


        def ip_v4_address(self):
            return self.getTypedRuleContext(RULEMLParser.Ip_v4_addressContext,0)


        def ireg_name(self):
            return self.getTypedRuleContext(RULEMLParser.Ireg_nameContext,0)


        def getRuleIndex(self):
            return RULEMLParser.RULE_ihost

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIhost" ):
                listener.enterIhost(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIhost" ):
                listener.exitIhost(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIhost" ):
                return visitor.visitIhost(self)
            else:
                return visitor.visitChildren(self)




    def ihost(self):

        localctx = RULEMLParser.IhostContext(self, self._ctx, self.state)
        self.enterRule(localctx, 242, self.RULE_ihost)
        try:
            self.state = 879
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,43,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 876
                self.ip_literal()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 877
                self.ip_v4_address()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 878
                self.ireg_name()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Ireg_nameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def iunreserved(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RULEMLParser.IunreservedContext)
            else:
                return self.getTypedRuleContext(RULEMLParser.IunreservedContext,i)


        def pct_encoded(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RULEMLParser.Pct_encodedContext)
            else:
                return self.getTypedRuleContext(RULEMLParser.Pct_encodedContext,i)


        def sub_delims(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RULEMLParser.Sub_delimsContext)
            else:
                return self.getTypedRuleContext(RULEMLParser.Sub_delimsContext,i)


        def getRuleIndex(self):
            return RULEMLParser.RULE_ireg_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIreg_name" ):
                listener.enterIreg_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIreg_name" ):
                listener.exitIreg_name(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIreg_name" ):
                return visitor.visitIreg_name(self)
            else:
                return visitor.visitChildren(self)




    def ireg_name(self):

        localctx = RULEMLParser.Ireg_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 244, self.RULE_ireg_name)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 886
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 109)) & ~0x3f) == 0 and ((1 << (_la - 109)) & ((1 << (RULEMLParser.UCSCHAR - 109)) | (1 << (RULEMLParser.D0 - 109)) | (1 << (RULEMLParser.D1 - 109)) | (1 << (RULEMLParser.D2 - 109)) | (1 << (RULEMLParser.D3 - 109)) | (1 << (RULEMLParser.D4 - 109)) | (1 << (RULEMLParser.D5 - 109)) | (1 << (RULEMLParser.D6 - 109)) | (1 << (RULEMLParser.D7 - 109)) | (1 << (RULEMLParser.D8 - 109)) | (1 << (RULEMLParser.D9 - 109)) | (1 << (RULEMLParser.A - 109)) | (1 << (RULEMLParser.B - 109)) | (1 << (RULEMLParser.C - 109)) | (1 << (RULEMLParser.D - 109)) | (1 << (RULEMLParser.E - 109)) | (1 << (RULEMLParser.F - 109)) | (1 << (RULEMLParser.G - 109)) | (1 << (RULEMLParser.H - 109)) | (1 << (RULEMLParser.I - 109)) | (1 << (RULEMLParser.J - 109)) | (1 << (RULEMLParser.K - 109)) | (1 << (RULEMLParser.L - 109)) | (1 << (RULEMLParser.M - 109)) | (1 << (RULEMLParser.N - 109)) | (1 << (RULEMLParser.O - 109)) | (1 << (RULEMLParser.P - 109)) | (1 << (RULEMLParser.Q - 109)) | (1 << (RULEMLParser.R - 109)) | (1 << (RULEMLParser.S - 109)) | (1 << (RULEMLParser.T - 109)) | (1 << (RULEMLParser.U - 109)) | (1 << (RULEMLParser.V - 109)) | (1 << (RULEMLParser.W - 109)) | (1 << (RULEMLParser.X - 109)) | (1 << (RULEMLParser.Y - 109)) | (1 << (RULEMLParser.Z - 109)) | (1 << (RULEMLParser.DOT - 109)) | (1 << (RULEMLParser.PERCENT - 109)) | (1 << (RULEMLParser.HYPHEN - 109)) | (1 << (RULEMLParser.TILDE - 109)) | (1 << (RULEMLParser.USCORE - 109)) | (1 << (RULEMLParser.EXCL - 109)) | (1 << (RULEMLParser.DOLLAR - 109)) | (1 << (RULEMLParser.AMP - 109)) | (1 << (RULEMLParser.SQUOTE - 109)) | (1 << (RULEMLParser.OPAREN - 109)) | (1 << (RULEMLParser.CPAREN - 109)) | (1 << (RULEMLParser.STAR - 109)) | (1 << (RULEMLParser.PLUS - 109)) | (1 << (RULEMLParser.COMMA - 109)) | (1 << (RULEMLParser.SCOL - 109)) | (1 << (RULEMLParser.EQUALS - 109)))) != 0):
                self.state = 884
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [RULEMLParser.UCSCHAR, RULEMLParser.D0, RULEMLParser.D1, RULEMLParser.D2, RULEMLParser.D3, RULEMLParser.D4, RULEMLParser.D5, RULEMLParser.D6, RULEMLParser.D7, RULEMLParser.D8, RULEMLParser.D9, RULEMLParser.A, RULEMLParser.B, RULEMLParser.C, RULEMLParser.D, RULEMLParser.E, RULEMLParser.F, RULEMLParser.G, RULEMLParser.H, RULEMLParser.I, RULEMLParser.J, RULEMLParser.K, RULEMLParser.L, RULEMLParser.M, RULEMLParser.N, RULEMLParser.O, RULEMLParser.P, RULEMLParser.Q, RULEMLParser.R, RULEMLParser.S, RULEMLParser.T, RULEMLParser.U, RULEMLParser.V, RULEMLParser.W, RULEMLParser.X, RULEMLParser.Y, RULEMLParser.Z, RULEMLParser.DOT, RULEMLParser.HYPHEN, RULEMLParser.TILDE, RULEMLParser.USCORE]:
                    self.state = 881
                    self.iunreserved()
                    pass
                elif token in [RULEMLParser.PERCENT]:
                    self.state = 882
                    self.pct_encoded()
                    pass
                elif token in [RULEMLParser.EXCL, RULEMLParser.DOLLAR, RULEMLParser.AMP, RULEMLParser.SQUOTE, RULEMLParser.OPAREN, RULEMLParser.CPAREN, RULEMLParser.STAR, RULEMLParser.PLUS, RULEMLParser.COMMA, RULEMLParser.SCOL, RULEMLParser.EQUALS]:
                    self.state = 883
                    self.sub_delims()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 888
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IpathContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ipath_abempty(self):
            return self.getTypedRuleContext(RULEMLParser.Ipath_abemptyContext,0)


        def ipath_absolute(self):
            return self.getTypedRuleContext(RULEMLParser.Ipath_absoluteContext,0)


        def ipath_noscheme(self):
            return self.getTypedRuleContext(RULEMLParser.Ipath_noschemeContext,0)


        def ipath_rootless(self):
            return self.getTypedRuleContext(RULEMLParser.Ipath_rootlessContext,0)


        def ipath_empty(self):
            return self.getTypedRuleContext(RULEMLParser.Ipath_emptyContext,0)


        def getRuleIndex(self):
            return RULEMLParser.RULE_ipath

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIpath" ):
                listener.enterIpath(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIpath" ):
                listener.exitIpath(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIpath" ):
                return visitor.visitIpath(self)
            else:
                return visitor.visitChildren(self)




    def ipath(self):

        localctx = RULEMLParser.IpathContext(self, self._ctx, self.state)
        self.enterRule(localctx, 246, self.RULE_ipath)
        try:
            self.state = 894
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,46,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 889
                self.ipath_abempty()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 890
                self.ipath_absolute()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 891
                self.ipath_noscheme()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 892
                self.ipath_rootless()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 893
                self.ipath_empty()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Ipath_abemptyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FSLASH(self, i:int=None):
            if i is None:
                return self.getTokens(RULEMLParser.FSLASH)
            else:
                return self.getToken(RULEMLParser.FSLASH, i)

        def isegment(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RULEMLParser.IsegmentContext)
            else:
                return self.getTypedRuleContext(RULEMLParser.IsegmentContext,i)


        def getRuleIndex(self):
            return RULEMLParser.RULE_ipath_abempty

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIpath_abempty" ):
                listener.enterIpath_abempty(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIpath_abempty" ):
                listener.exitIpath_abempty(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIpath_abempty" ):
                return visitor.visitIpath_abempty(self)
            else:
                return visitor.visitChildren(self)




    def ipath_abempty(self):

        localctx = RULEMLParser.Ipath_abemptyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 248, self.RULE_ipath_abempty)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 900
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==RULEMLParser.FSLASH:
                self.state = 896
                self.match(RULEMLParser.FSLASH)
                self.state = 897
                self.isegment()
                self.state = 902
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Ipath_absoluteContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FSLASH(self, i:int=None):
            if i is None:
                return self.getTokens(RULEMLParser.FSLASH)
            else:
                return self.getToken(RULEMLParser.FSLASH, i)

        def isegment_nz(self):
            return self.getTypedRuleContext(RULEMLParser.Isegment_nzContext,0)


        def isegment(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RULEMLParser.IsegmentContext)
            else:
                return self.getTypedRuleContext(RULEMLParser.IsegmentContext,i)


        def getRuleIndex(self):
            return RULEMLParser.RULE_ipath_absolute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIpath_absolute" ):
                listener.enterIpath_absolute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIpath_absolute" ):
                listener.exitIpath_absolute(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIpath_absolute" ):
                return visitor.visitIpath_absolute(self)
            else:
                return visitor.visitChildren(self)




    def ipath_absolute(self):

        localctx = RULEMLParser.Ipath_absoluteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 250, self.RULE_ipath_absolute)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 903
            self.match(RULEMLParser.FSLASH)
            self.state = 912
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 109)) & ~0x3f) == 0 and ((1 << (_la - 109)) & ((1 << (RULEMLParser.UCSCHAR - 109)) | (1 << (RULEMLParser.D0 - 109)) | (1 << (RULEMLParser.D1 - 109)) | (1 << (RULEMLParser.D2 - 109)) | (1 << (RULEMLParser.D3 - 109)) | (1 << (RULEMLParser.D4 - 109)) | (1 << (RULEMLParser.D5 - 109)) | (1 << (RULEMLParser.D6 - 109)) | (1 << (RULEMLParser.D7 - 109)) | (1 << (RULEMLParser.D8 - 109)) | (1 << (RULEMLParser.D9 - 109)) | (1 << (RULEMLParser.A - 109)) | (1 << (RULEMLParser.B - 109)) | (1 << (RULEMLParser.C - 109)) | (1 << (RULEMLParser.D - 109)) | (1 << (RULEMLParser.E - 109)) | (1 << (RULEMLParser.F - 109)) | (1 << (RULEMLParser.G - 109)) | (1 << (RULEMLParser.H - 109)) | (1 << (RULEMLParser.I - 109)) | (1 << (RULEMLParser.J - 109)) | (1 << (RULEMLParser.K - 109)) | (1 << (RULEMLParser.L - 109)) | (1 << (RULEMLParser.M - 109)) | (1 << (RULEMLParser.N - 109)) | (1 << (RULEMLParser.O - 109)) | (1 << (RULEMLParser.P - 109)) | (1 << (RULEMLParser.Q - 109)) | (1 << (RULEMLParser.R - 109)) | (1 << (RULEMLParser.S - 109)) | (1 << (RULEMLParser.T - 109)) | (1 << (RULEMLParser.U - 109)) | (1 << (RULEMLParser.V - 109)) | (1 << (RULEMLParser.W - 109)) | (1 << (RULEMLParser.X - 109)) | (1 << (RULEMLParser.Y - 109)) | (1 << (RULEMLParser.Z - 109)) | (1 << (RULEMLParser.COL - 109)) | (1 << (RULEMLParser.DOT - 109)) | (1 << (RULEMLParser.PERCENT - 109)) | (1 << (RULEMLParser.HYPHEN - 109)) | (1 << (RULEMLParser.TILDE - 109)) | (1 << (RULEMLParser.USCORE - 109)) | (1 << (RULEMLParser.EXCL - 109)) | (1 << (RULEMLParser.DOLLAR - 109)) | (1 << (RULEMLParser.AMP - 109)) | (1 << (RULEMLParser.SQUOTE - 109)) | (1 << (RULEMLParser.OPAREN - 109)) | (1 << (RULEMLParser.CPAREN - 109)) | (1 << (RULEMLParser.STAR - 109)) | (1 << (RULEMLParser.PLUS - 109)) | (1 << (RULEMLParser.COMMA - 109)) | (1 << (RULEMLParser.SCOL - 109)) | (1 << (RULEMLParser.EQUALS - 109)) | (1 << (RULEMLParser.AT - 109)))) != 0):
                self.state = 904
                self.isegment_nz()
                self.state = 909
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==RULEMLParser.FSLASH:
                    self.state = 905
                    self.match(RULEMLParser.FSLASH)
                    self.state = 906
                    self.isegment()
                    self.state = 911
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Ipath_noschemeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def isegment_nz_nc(self):
            return self.getTypedRuleContext(RULEMLParser.Isegment_nz_ncContext,0)


        def FSLASH(self, i:int=None):
            if i is None:
                return self.getTokens(RULEMLParser.FSLASH)
            else:
                return self.getToken(RULEMLParser.FSLASH, i)

        def isegment(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RULEMLParser.IsegmentContext)
            else:
                return self.getTypedRuleContext(RULEMLParser.IsegmentContext,i)


        def getRuleIndex(self):
            return RULEMLParser.RULE_ipath_noscheme

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIpath_noscheme" ):
                listener.enterIpath_noscheme(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIpath_noscheme" ):
                listener.exitIpath_noscheme(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIpath_noscheme" ):
                return visitor.visitIpath_noscheme(self)
            else:
                return visitor.visitChildren(self)




    def ipath_noscheme(self):

        localctx = RULEMLParser.Ipath_noschemeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 252, self.RULE_ipath_noscheme)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 914
            self.isegment_nz_nc()
            self.state = 919
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==RULEMLParser.FSLASH:
                self.state = 915
                self.match(RULEMLParser.FSLASH)
                self.state = 916
                self.isegment()
                self.state = 921
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Ipath_rootlessContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def isegment_nz(self):
            return self.getTypedRuleContext(RULEMLParser.Isegment_nzContext,0)


        def FSLASH(self, i:int=None):
            if i is None:
                return self.getTokens(RULEMLParser.FSLASH)
            else:
                return self.getToken(RULEMLParser.FSLASH, i)

        def isegment(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RULEMLParser.IsegmentContext)
            else:
                return self.getTypedRuleContext(RULEMLParser.IsegmentContext,i)


        def getRuleIndex(self):
            return RULEMLParser.RULE_ipath_rootless

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIpath_rootless" ):
                listener.enterIpath_rootless(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIpath_rootless" ):
                listener.exitIpath_rootless(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIpath_rootless" ):
                return visitor.visitIpath_rootless(self)
            else:
                return visitor.visitChildren(self)




    def ipath_rootless(self):

        localctx = RULEMLParser.Ipath_rootlessContext(self, self._ctx, self.state)
        self.enterRule(localctx, 254, self.RULE_ipath_rootless)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 922
            self.isegment_nz()
            self.state = 927
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==RULEMLParser.FSLASH:
                self.state = 923
                self.match(RULEMLParser.FSLASH)
                self.state = 924
                self.isegment()
                self.state = 929
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Ipath_emptyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RULEMLParser.RULE_ipath_empty

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIpath_empty" ):
                listener.enterIpath_empty(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIpath_empty" ):
                listener.exitIpath_empty(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIpath_empty" ):
                return visitor.visitIpath_empty(self)
            else:
                return visitor.visitChildren(self)




    def ipath_empty(self):

        localctx = RULEMLParser.Ipath_emptyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 256, self.RULE_ipath_empty)
        try:
            self.enterOuterAlt(localctx, 1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IsegmentContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ipchar(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RULEMLParser.IpcharContext)
            else:
                return self.getTypedRuleContext(RULEMLParser.IpcharContext,i)


        def getRuleIndex(self):
            return RULEMLParser.RULE_isegment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIsegment" ):
                listener.enterIsegment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIsegment" ):
                listener.exitIsegment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIsegment" ):
                return visitor.visitIsegment(self)
            else:
                return visitor.visitChildren(self)




    def isegment(self):

        localctx = RULEMLParser.IsegmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 258, self.RULE_isegment)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 935
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 109)) & ~0x3f) == 0 and ((1 << (_la - 109)) & ((1 << (RULEMLParser.UCSCHAR - 109)) | (1 << (RULEMLParser.D0 - 109)) | (1 << (RULEMLParser.D1 - 109)) | (1 << (RULEMLParser.D2 - 109)) | (1 << (RULEMLParser.D3 - 109)) | (1 << (RULEMLParser.D4 - 109)) | (1 << (RULEMLParser.D5 - 109)) | (1 << (RULEMLParser.D6 - 109)) | (1 << (RULEMLParser.D7 - 109)) | (1 << (RULEMLParser.D8 - 109)) | (1 << (RULEMLParser.D9 - 109)) | (1 << (RULEMLParser.A - 109)) | (1 << (RULEMLParser.B - 109)) | (1 << (RULEMLParser.C - 109)) | (1 << (RULEMLParser.D - 109)) | (1 << (RULEMLParser.E - 109)) | (1 << (RULEMLParser.F - 109)) | (1 << (RULEMLParser.G - 109)) | (1 << (RULEMLParser.H - 109)) | (1 << (RULEMLParser.I - 109)) | (1 << (RULEMLParser.J - 109)) | (1 << (RULEMLParser.K - 109)) | (1 << (RULEMLParser.L - 109)) | (1 << (RULEMLParser.M - 109)) | (1 << (RULEMLParser.N - 109)) | (1 << (RULEMLParser.O - 109)) | (1 << (RULEMLParser.P - 109)) | (1 << (RULEMLParser.Q - 109)) | (1 << (RULEMLParser.R - 109)) | (1 << (RULEMLParser.S - 109)) | (1 << (RULEMLParser.T - 109)) | (1 << (RULEMLParser.U - 109)) | (1 << (RULEMLParser.V - 109)) | (1 << (RULEMLParser.W - 109)) | (1 << (RULEMLParser.X - 109)) | (1 << (RULEMLParser.Y - 109)) | (1 << (RULEMLParser.Z - 109)) | (1 << (RULEMLParser.COL - 109)) | (1 << (RULEMLParser.DOT - 109)) | (1 << (RULEMLParser.PERCENT - 109)) | (1 << (RULEMLParser.HYPHEN - 109)) | (1 << (RULEMLParser.TILDE - 109)) | (1 << (RULEMLParser.USCORE - 109)) | (1 << (RULEMLParser.EXCL - 109)) | (1 << (RULEMLParser.DOLLAR - 109)) | (1 << (RULEMLParser.AMP - 109)) | (1 << (RULEMLParser.SQUOTE - 109)) | (1 << (RULEMLParser.OPAREN - 109)) | (1 << (RULEMLParser.CPAREN - 109)) | (1 << (RULEMLParser.STAR - 109)) | (1 << (RULEMLParser.PLUS - 109)) | (1 << (RULEMLParser.COMMA - 109)) | (1 << (RULEMLParser.SCOL - 109)) | (1 << (RULEMLParser.EQUALS - 109)) | (1 << (RULEMLParser.AT - 109)))) != 0):
                self.state = 932
                self.ipchar()
                self.state = 937
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Isegment_nzContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ipchar(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RULEMLParser.IpcharContext)
            else:
                return self.getTypedRuleContext(RULEMLParser.IpcharContext,i)


        def getRuleIndex(self):
            return RULEMLParser.RULE_isegment_nz

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIsegment_nz" ):
                listener.enterIsegment_nz(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIsegment_nz" ):
                listener.exitIsegment_nz(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIsegment_nz" ):
                return visitor.visitIsegment_nz(self)
            else:
                return visitor.visitChildren(self)




    def isegment_nz(self):

        localctx = RULEMLParser.Isegment_nzContext(self, self._ctx, self.state)
        self.enterRule(localctx, 260, self.RULE_isegment_nz)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 939 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 938
                self.ipchar()
                self.state = 941 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (((((_la - 109)) & ~0x3f) == 0 and ((1 << (_la - 109)) & ((1 << (RULEMLParser.UCSCHAR - 109)) | (1 << (RULEMLParser.D0 - 109)) | (1 << (RULEMLParser.D1 - 109)) | (1 << (RULEMLParser.D2 - 109)) | (1 << (RULEMLParser.D3 - 109)) | (1 << (RULEMLParser.D4 - 109)) | (1 << (RULEMLParser.D5 - 109)) | (1 << (RULEMLParser.D6 - 109)) | (1 << (RULEMLParser.D7 - 109)) | (1 << (RULEMLParser.D8 - 109)) | (1 << (RULEMLParser.D9 - 109)) | (1 << (RULEMLParser.A - 109)) | (1 << (RULEMLParser.B - 109)) | (1 << (RULEMLParser.C - 109)) | (1 << (RULEMLParser.D - 109)) | (1 << (RULEMLParser.E - 109)) | (1 << (RULEMLParser.F - 109)) | (1 << (RULEMLParser.G - 109)) | (1 << (RULEMLParser.H - 109)) | (1 << (RULEMLParser.I - 109)) | (1 << (RULEMLParser.J - 109)) | (1 << (RULEMLParser.K - 109)) | (1 << (RULEMLParser.L - 109)) | (1 << (RULEMLParser.M - 109)) | (1 << (RULEMLParser.N - 109)) | (1 << (RULEMLParser.O - 109)) | (1 << (RULEMLParser.P - 109)) | (1 << (RULEMLParser.Q - 109)) | (1 << (RULEMLParser.R - 109)) | (1 << (RULEMLParser.S - 109)) | (1 << (RULEMLParser.T - 109)) | (1 << (RULEMLParser.U - 109)) | (1 << (RULEMLParser.V - 109)) | (1 << (RULEMLParser.W - 109)) | (1 << (RULEMLParser.X - 109)) | (1 << (RULEMLParser.Y - 109)) | (1 << (RULEMLParser.Z - 109)) | (1 << (RULEMLParser.COL - 109)) | (1 << (RULEMLParser.DOT - 109)) | (1 << (RULEMLParser.PERCENT - 109)) | (1 << (RULEMLParser.HYPHEN - 109)) | (1 << (RULEMLParser.TILDE - 109)) | (1 << (RULEMLParser.USCORE - 109)) | (1 << (RULEMLParser.EXCL - 109)) | (1 << (RULEMLParser.DOLLAR - 109)) | (1 << (RULEMLParser.AMP - 109)) | (1 << (RULEMLParser.SQUOTE - 109)) | (1 << (RULEMLParser.OPAREN - 109)) | (1 << (RULEMLParser.CPAREN - 109)) | (1 << (RULEMLParser.STAR - 109)) | (1 << (RULEMLParser.PLUS - 109)) | (1 << (RULEMLParser.COMMA - 109)) | (1 << (RULEMLParser.SCOL - 109)) | (1 << (RULEMLParser.EQUALS - 109)) | (1 << (RULEMLParser.AT - 109)))) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Isegment_nz_ncContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def iunreserved(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RULEMLParser.IunreservedContext)
            else:
                return self.getTypedRuleContext(RULEMLParser.IunreservedContext,i)


        def pct_encoded(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RULEMLParser.Pct_encodedContext)
            else:
                return self.getTypedRuleContext(RULEMLParser.Pct_encodedContext,i)


        def sub_delims(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RULEMLParser.Sub_delimsContext)
            else:
                return self.getTypedRuleContext(RULEMLParser.Sub_delimsContext,i)


        def AT(self, i:int=None):
            if i is None:
                return self.getTokens(RULEMLParser.AT)
            else:
                return self.getToken(RULEMLParser.AT, i)

        def getRuleIndex(self):
            return RULEMLParser.RULE_isegment_nz_nc

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIsegment_nz_nc" ):
                listener.enterIsegment_nz_nc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIsegment_nz_nc" ):
                listener.exitIsegment_nz_nc(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIsegment_nz_nc" ):
                return visitor.visitIsegment_nz_nc(self)
            else:
                return visitor.visitChildren(self)




    def isegment_nz_nc(self):

        localctx = RULEMLParser.Isegment_nz_ncContext(self, self._ctx, self.state)
        self.enterRule(localctx, 262, self.RULE_isegment_nz_nc)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 947 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 947
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [RULEMLParser.UCSCHAR, RULEMLParser.D0, RULEMLParser.D1, RULEMLParser.D2, RULEMLParser.D3, RULEMLParser.D4, RULEMLParser.D5, RULEMLParser.D6, RULEMLParser.D7, RULEMLParser.D8, RULEMLParser.D9, RULEMLParser.A, RULEMLParser.B, RULEMLParser.C, RULEMLParser.D, RULEMLParser.E, RULEMLParser.F, RULEMLParser.G, RULEMLParser.H, RULEMLParser.I, RULEMLParser.J, RULEMLParser.K, RULEMLParser.L, RULEMLParser.M, RULEMLParser.N, RULEMLParser.O, RULEMLParser.P, RULEMLParser.Q, RULEMLParser.R, RULEMLParser.S, RULEMLParser.T, RULEMLParser.U, RULEMLParser.V, RULEMLParser.W, RULEMLParser.X, RULEMLParser.Y, RULEMLParser.Z, RULEMLParser.DOT, RULEMLParser.HYPHEN, RULEMLParser.TILDE, RULEMLParser.USCORE]:
                    self.state = 943
                    self.iunreserved()
                    pass
                elif token in [RULEMLParser.PERCENT]:
                    self.state = 944
                    self.pct_encoded()
                    pass
                elif token in [RULEMLParser.EXCL, RULEMLParser.DOLLAR, RULEMLParser.AMP, RULEMLParser.SQUOTE, RULEMLParser.OPAREN, RULEMLParser.CPAREN, RULEMLParser.STAR, RULEMLParser.PLUS, RULEMLParser.COMMA, RULEMLParser.SCOL, RULEMLParser.EQUALS]:
                    self.state = 945
                    self.sub_delims()
                    pass
                elif token in [RULEMLParser.AT]:
                    self.state = 946
                    self.match(RULEMLParser.AT)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 949 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (((((_la - 109)) & ~0x3f) == 0 and ((1 << (_la - 109)) & ((1 << (RULEMLParser.UCSCHAR - 109)) | (1 << (RULEMLParser.D0 - 109)) | (1 << (RULEMLParser.D1 - 109)) | (1 << (RULEMLParser.D2 - 109)) | (1 << (RULEMLParser.D3 - 109)) | (1 << (RULEMLParser.D4 - 109)) | (1 << (RULEMLParser.D5 - 109)) | (1 << (RULEMLParser.D6 - 109)) | (1 << (RULEMLParser.D7 - 109)) | (1 << (RULEMLParser.D8 - 109)) | (1 << (RULEMLParser.D9 - 109)) | (1 << (RULEMLParser.A - 109)) | (1 << (RULEMLParser.B - 109)) | (1 << (RULEMLParser.C - 109)) | (1 << (RULEMLParser.D - 109)) | (1 << (RULEMLParser.E - 109)) | (1 << (RULEMLParser.F - 109)) | (1 << (RULEMLParser.G - 109)) | (1 << (RULEMLParser.H - 109)) | (1 << (RULEMLParser.I - 109)) | (1 << (RULEMLParser.J - 109)) | (1 << (RULEMLParser.K - 109)) | (1 << (RULEMLParser.L - 109)) | (1 << (RULEMLParser.M - 109)) | (1 << (RULEMLParser.N - 109)) | (1 << (RULEMLParser.O - 109)) | (1 << (RULEMLParser.P - 109)) | (1 << (RULEMLParser.Q - 109)) | (1 << (RULEMLParser.R - 109)) | (1 << (RULEMLParser.S - 109)) | (1 << (RULEMLParser.T - 109)) | (1 << (RULEMLParser.U - 109)) | (1 << (RULEMLParser.V - 109)) | (1 << (RULEMLParser.W - 109)) | (1 << (RULEMLParser.X - 109)) | (1 << (RULEMLParser.Y - 109)) | (1 << (RULEMLParser.Z - 109)) | (1 << (RULEMLParser.DOT - 109)) | (1 << (RULEMLParser.PERCENT - 109)) | (1 << (RULEMLParser.HYPHEN - 109)) | (1 << (RULEMLParser.TILDE - 109)) | (1 << (RULEMLParser.USCORE - 109)) | (1 << (RULEMLParser.EXCL - 109)) | (1 << (RULEMLParser.DOLLAR - 109)) | (1 << (RULEMLParser.AMP - 109)) | (1 << (RULEMLParser.SQUOTE - 109)) | (1 << (RULEMLParser.OPAREN - 109)) | (1 << (RULEMLParser.CPAREN - 109)) | (1 << (RULEMLParser.STAR - 109)) | (1 << (RULEMLParser.PLUS - 109)) | (1 << (RULEMLParser.COMMA - 109)) | (1 << (RULEMLParser.SCOL - 109)) | (1 << (RULEMLParser.EQUALS - 109)) | (1 << (RULEMLParser.AT - 109)))) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IpcharContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def iunreserved(self):
            return self.getTypedRuleContext(RULEMLParser.IunreservedContext,0)


        def pct_encoded(self):
            return self.getTypedRuleContext(RULEMLParser.Pct_encodedContext,0)


        def sub_delims(self):
            return self.getTypedRuleContext(RULEMLParser.Sub_delimsContext,0)


        def COL(self):
            return self.getToken(RULEMLParser.COL, 0)

        def AT(self):
            return self.getToken(RULEMLParser.AT, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_ipchar

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIpchar" ):
                listener.enterIpchar(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIpchar" ):
                listener.exitIpchar(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIpchar" ):
                return visitor.visitIpchar(self)
            else:
                return visitor.visitChildren(self)




    def ipchar(self):

        localctx = RULEMLParser.IpcharContext(self, self._ctx, self.state)
        self.enterRule(localctx, 264, self.RULE_ipchar)
        self._la = 0 # Token type
        try:
            self.state = 955
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [RULEMLParser.UCSCHAR, RULEMLParser.D0, RULEMLParser.D1, RULEMLParser.D2, RULEMLParser.D3, RULEMLParser.D4, RULEMLParser.D5, RULEMLParser.D6, RULEMLParser.D7, RULEMLParser.D8, RULEMLParser.D9, RULEMLParser.A, RULEMLParser.B, RULEMLParser.C, RULEMLParser.D, RULEMLParser.E, RULEMLParser.F, RULEMLParser.G, RULEMLParser.H, RULEMLParser.I, RULEMLParser.J, RULEMLParser.K, RULEMLParser.L, RULEMLParser.M, RULEMLParser.N, RULEMLParser.O, RULEMLParser.P, RULEMLParser.Q, RULEMLParser.R, RULEMLParser.S, RULEMLParser.T, RULEMLParser.U, RULEMLParser.V, RULEMLParser.W, RULEMLParser.X, RULEMLParser.Y, RULEMLParser.Z, RULEMLParser.DOT, RULEMLParser.HYPHEN, RULEMLParser.TILDE, RULEMLParser.USCORE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 951
                self.iunreserved()
                pass
            elif token in [RULEMLParser.PERCENT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 952
                self.pct_encoded()
                pass
            elif token in [RULEMLParser.EXCL, RULEMLParser.DOLLAR, RULEMLParser.AMP, RULEMLParser.SQUOTE, RULEMLParser.OPAREN, RULEMLParser.CPAREN, RULEMLParser.STAR, RULEMLParser.PLUS, RULEMLParser.COMMA, RULEMLParser.SCOL, RULEMLParser.EQUALS]:
                self.enterOuterAlt(localctx, 3)
                self.state = 953
                self.sub_delims()
                pass
            elif token in [RULEMLParser.COL, RULEMLParser.AT]:
                self.enterOuterAlt(localctx, 4)
                self.state = 954
                _la = self._input.LA(1)
                if not(_la==RULEMLParser.COL or _la==RULEMLParser.AT):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IqueryContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ipchar(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RULEMLParser.IpcharContext)
            else:
                return self.getTypedRuleContext(RULEMLParser.IpcharContext,i)


        def IPRIVATE(self, i:int=None):
            if i is None:
                return self.getTokens(RULEMLParser.IPRIVATE)
            else:
                return self.getToken(RULEMLParser.IPRIVATE, i)

        def FSLASH(self, i:int=None):
            if i is None:
                return self.getTokens(RULEMLParser.FSLASH)
            else:
                return self.getToken(RULEMLParser.FSLASH, i)

        def QMARK(self, i:int=None):
            if i is None:
                return self.getTokens(RULEMLParser.QMARK)
            else:
                return self.getToken(RULEMLParser.QMARK, i)

        def getRuleIndex(self):
            return RULEMLParser.RULE_iquery

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIquery" ):
                listener.enterIquery(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIquery" ):
                listener.exitIquery(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIquery" ):
                return visitor.visitIquery(self)
            else:
                return visitor.visitChildren(self)




    def iquery(self):

        localctx = RULEMLParser.IqueryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 266, self.RULE_iquery)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 961
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 109)) & ~0x3f) == 0 and ((1 << (_la - 109)) & ((1 << (RULEMLParser.UCSCHAR - 109)) | (1 << (RULEMLParser.IPRIVATE - 109)) | (1 << (RULEMLParser.D0 - 109)) | (1 << (RULEMLParser.D1 - 109)) | (1 << (RULEMLParser.D2 - 109)) | (1 << (RULEMLParser.D3 - 109)) | (1 << (RULEMLParser.D4 - 109)) | (1 << (RULEMLParser.D5 - 109)) | (1 << (RULEMLParser.D6 - 109)) | (1 << (RULEMLParser.D7 - 109)) | (1 << (RULEMLParser.D8 - 109)) | (1 << (RULEMLParser.D9 - 109)) | (1 << (RULEMLParser.A - 109)) | (1 << (RULEMLParser.B - 109)) | (1 << (RULEMLParser.C - 109)) | (1 << (RULEMLParser.D - 109)) | (1 << (RULEMLParser.E - 109)) | (1 << (RULEMLParser.F - 109)) | (1 << (RULEMLParser.G - 109)) | (1 << (RULEMLParser.H - 109)) | (1 << (RULEMLParser.I - 109)) | (1 << (RULEMLParser.J - 109)) | (1 << (RULEMLParser.K - 109)) | (1 << (RULEMLParser.L - 109)) | (1 << (RULEMLParser.M - 109)) | (1 << (RULEMLParser.N - 109)) | (1 << (RULEMLParser.O - 109)) | (1 << (RULEMLParser.P - 109)) | (1 << (RULEMLParser.Q - 109)) | (1 << (RULEMLParser.R - 109)) | (1 << (RULEMLParser.S - 109)) | (1 << (RULEMLParser.T - 109)) | (1 << (RULEMLParser.U - 109)) | (1 << (RULEMLParser.V - 109)) | (1 << (RULEMLParser.W - 109)) | (1 << (RULEMLParser.X - 109)) | (1 << (RULEMLParser.Y - 109)) | (1 << (RULEMLParser.Z - 109)) | (1 << (RULEMLParser.COL - 109)) | (1 << (RULEMLParser.DOT - 109)) | (1 << (RULEMLParser.PERCENT - 109)) | (1 << (RULEMLParser.HYPHEN - 109)) | (1 << (RULEMLParser.TILDE - 109)) | (1 << (RULEMLParser.USCORE - 109)) | (1 << (RULEMLParser.EXCL - 109)) | (1 << (RULEMLParser.DOLLAR - 109)) | (1 << (RULEMLParser.AMP - 109)) | (1 << (RULEMLParser.SQUOTE - 109)) | (1 << (RULEMLParser.OPAREN - 109)) | (1 << (RULEMLParser.CPAREN - 109)) | (1 << (RULEMLParser.STAR - 109)) | (1 << (RULEMLParser.PLUS - 109)) | (1 << (RULEMLParser.COMMA - 109)) | (1 << (RULEMLParser.SCOL - 109)) | (1 << (RULEMLParser.EQUALS - 109)) | (1 << (RULEMLParser.FSLASH - 109)) | (1 << (RULEMLParser.QMARK - 109)) | (1 << (RULEMLParser.AT - 109)))) != 0):
                self.state = 959
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [RULEMLParser.UCSCHAR, RULEMLParser.D0, RULEMLParser.D1, RULEMLParser.D2, RULEMLParser.D3, RULEMLParser.D4, RULEMLParser.D5, RULEMLParser.D6, RULEMLParser.D7, RULEMLParser.D8, RULEMLParser.D9, RULEMLParser.A, RULEMLParser.B, RULEMLParser.C, RULEMLParser.D, RULEMLParser.E, RULEMLParser.F, RULEMLParser.G, RULEMLParser.H, RULEMLParser.I, RULEMLParser.J, RULEMLParser.K, RULEMLParser.L, RULEMLParser.M, RULEMLParser.N, RULEMLParser.O, RULEMLParser.P, RULEMLParser.Q, RULEMLParser.R, RULEMLParser.S, RULEMLParser.T, RULEMLParser.U, RULEMLParser.V, RULEMLParser.W, RULEMLParser.X, RULEMLParser.Y, RULEMLParser.Z, RULEMLParser.COL, RULEMLParser.DOT, RULEMLParser.PERCENT, RULEMLParser.HYPHEN, RULEMLParser.TILDE, RULEMLParser.USCORE, RULEMLParser.EXCL, RULEMLParser.DOLLAR, RULEMLParser.AMP, RULEMLParser.SQUOTE, RULEMLParser.OPAREN, RULEMLParser.CPAREN, RULEMLParser.STAR, RULEMLParser.PLUS, RULEMLParser.COMMA, RULEMLParser.SCOL, RULEMLParser.EQUALS, RULEMLParser.AT]:
                    self.state = 957
                    self.ipchar()
                    pass
                elif token in [RULEMLParser.IPRIVATE, RULEMLParser.FSLASH, RULEMLParser.QMARK]:
                    self.state = 958
                    _la = self._input.LA(1)
                    if not(((((_la - 110)) & ~0x3f) == 0 and ((1 << (_la - 110)) & ((1 << (RULEMLParser.IPRIVATE - 110)) | (1 << (RULEMLParser.FSLASH - 110)) | (1 << (RULEMLParser.QMARK - 110)))) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 963
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IfragmentContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ipchar(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RULEMLParser.IpcharContext)
            else:
                return self.getTypedRuleContext(RULEMLParser.IpcharContext,i)


        def FSLASH(self, i:int=None):
            if i is None:
                return self.getTokens(RULEMLParser.FSLASH)
            else:
                return self.getToken(RULEMLParser.FSLASH, i)

        def QMARK(self, i:int=None):
            if i is None:
                return self.getTokens(RULEMLParser.QMARK)
            else:
                return self.getToken(RULEMLParser.QMARK, i)

        def getRuleIndex(self):
            return RULEMLParser.RULE_ifragment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfragment" ):
                listener.enterIfragment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfragment" ):
                listener.exitIfragment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIfragment" ):
                return visitor.visitIfragment(self)
            else:
                return visitor.visitChildren(self)




    def ifragment(self):

        localctx = RULEMLParser.IfragmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 268, self.RULE_ifragment)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 968
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 109)) & ~0x3f) == 0 and ((1 << (_la - 109)) & ((1 << (RULEMLParser.UCSCHAR - 109)) | (1 << (RULEMLParser.D0 - 109)) | (1 << (RULEMLParser.D1 - 109)) | (1 << (RULEMLParser.D2 - 109)) | (1 << (RULEMLParser.D3 - 109)) | (1 << (RULEMLParser.D4 - 109)) | (1 << (RULEMLParser.D5 - 109)) | (1 << (RULEMLParser.D6 - 109)) | (1 << (RULEMLParser.D7 - 109)) | (1 << (RULEMLParser.D8 - 109)) | (1 << (RULEMLParser.D9 - 109)) | (1 << (RULEMLParser.A - 109)) | (1 << (RULEMLParser.B - 109)) | (1 << (RULEMLParser.C - 109)) | (1 << (RULEMLParser.D - 109)) | (1 << (RULEMLParser.E - 109)) | (1 << (RULEMLParser.F - 109)) | (1 << (RULEMLParser.G - 109)) | (1 << (RULEMLParser.H - 109)) | (1 << (RULEMLParser.I - 109)) | (1 << (RULEMLParser.J - 109)) | (1 << (RULEMLParser.K - 109)) | (1 << (RULEMLParser.L - 109)) | (1 << (RULEMLParser.M - 109)) | (1 << (RULEMLParser.N - 109)) | (1 << (RULEMLParser.O - 109)) | (1 << (RULEMLParser.P - 109)) | (1 << (RULEMLParser.Q - 109)) | (1 << (RULEMLParser.R - 109)) | (1 << (RULEMLParser.S - 109)) | (1 << (RULEMLParser.T - 109)) | (1 << (RULEMLParser.U - 109)) | (1 << (RULEMLParser.V - 109)) | (1 << (RULEMLParser.W - 109)) | (1 << (RULEMLParser.X - 109)) | (1 << (RULEMLParser.Y - 109)) | (1 << (RULEMLParser.Z - 109)) | (1 << (RULEMLParser.COL - 109)) | (1 << (RULEMLParser.DOT - 109)) | (1 << (RULEMLParser.PERCENT - 109)) | (1 << (RULEMLParser.HYPHEN - 109)) | (1 << (RULEMLParser.TILDE - 109)) | (1 << (RULEMLParser.USCORE - 109)) | (1 << (RULEMLParser.EXCL - 109)) | (1 << (RULEMLParser.DOLLAR - 109)) | (1 << (RULEMLParser.AMP - 109)) | (1 << (RULEMLParser.SQUOTE - 109)) | (1 << (RULEMLParser.OPAREN - 109)) | (1 << (RULEMLParser.CPAREN - 109)) | (1 << (RULEMLParser.STAR - 109)) | (1 << (RULEMLParser.PLUS - 109)) | (1 << (RULEMLParser.COMMA - 109)) | (1 << (RULEMLParser.SCOL - 109)) | (1 << (RULEMLParser.EQUALS - 109)) | (1 << (RULEMLParser.FSLASH - 109)) | (1 << (RULEMLParser.QMARK - 109)) | (1 << (RULEMLParser.AT - 109)))) != 0):
                self.state = 966
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [RULEMLParser.UCSCHAR, RULEMLParser.D0, RULEMLParser.D1, RULEMLParser.D2, RULEMLParser.D3, RULEMLParser.D4, RULEMLParser.D5, RULEMLParser.D6, RULEMLParser.D7, RULEMLParser.D8, RULEMLParser.D9, RULEMLParser.A, RULEMLParser.B, RULEMLParser.C, RULEMLParser.D, RULEMLParser.E, RULEMLParser.F, RULEMLParser.G, RULEMLParser.H, RULEMLParser.I, RULEMLParser.J, RULEMLParser.K, RULEMLParser.L, RULEMLParser.M, RULEMLParser.N, RULEMLParser.O, RULEMLParser.P, RULEMLParser.Q, RULEMLParser.R, RULEMLParser.S, RULEMLParser.T, RULEMLParser.U, RULEMLParser.V, RULEMLParser.W, RULEMLParser.X, RULEMLParser.Y, RULEMLParser.Z, RULEMLParser.COL, RULEMLParser.DOT, RULEMLParser.PERCENT, RULEMLParser.HYPHEN, RULEMLParser.TILDE, RULEMLParser.USCORE, RULEMLParser.EXCL, RULEMLParser.DOLLAR, RULEMLParser.AMP, RULEMLParser.SQUOTE, RULEMLParser.OPAREN, RULEMLParser.CPAREN, RULEMLParser.STAR, RULEMLParser.PLUS, RULEMLParser.COMMA, RULEMLParser.SCOL, RULEMLParser.EQUALS, RULEMLParser.AT]:
                    self.state = 964
                    self.ipchar()
                    pass
                elif token in [RULEMLParser.FSLASH, RULEMLParser.QMARK]:
                    self.state = 965
                    _la = self._input.LA(1)
                    if not(_la==RULEMLParser.FSLASH or _la==RULEMLParser.QMARK):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 970
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IunreservedContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def alpha(self):
            return self.getTypedRuleContext(RULEMLParser.AlphaContext,0)


        def digit(self):
            return self.getTypedRuleContext(RULEMLParser.DigitContext,0)


        def HYPHEN(self):
            return self.getToken(RULEMLParser.HYPHEN, 0)

        def DOT(self):
            return self.getToken(RULEMLParser.DOT, 0)

        def USCORE(self):
            return self.getToken(RULEMLParser.USCORE, 0)

        def TILDE(self):
            return self.getToken(RULEMLParser.TILDE, 0)

        def UCSCHAR(self):
            return self.getToken(RULEMLParser.UCSCHAR, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_iunreserved

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIunreserved" ):
                listener.enterIunreserved(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIunreserved" ):
                listener.exitIunreserved(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIunreserved" ):
                return visitor.visitIunreserved(self)
            else:
                return visitor.visitChildren(self)




    def iunreserved(self):

        localctx = RULEMLParser.IunreservedContext(self, self._ctx, self.state)
        self.enterRule(localctx, 270, self.RULE_iunreserved)
        self._la = 0 # Token type
        try:
            self.state = 974
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [RULEMLParser.A, RULEMLParser.B, RULEMLParser.C, RULEMLParser.D, RULEMLParser.E, RULEMLParser.F, RULEMLParser.G, RULEMLParser.H, RULEMLParser.I, RULEMLParser.J, RULEMLParser.K, RULEMLParser.L, RULEMLParser.M, RULEMLParser.N, RULEMLParser.O, RULEMLParser.P, RULEMLParser.Q, RULEMLParser.R, RULEMLParser.S, RULEMLParser.T, RULEMLParser.U, RULEMLParser.V, RULEMLParser.W, RULEMLParser.X, RULEMLParser.Y, RULEMLParser.Z]:
                self.enterOuterAlt(localctx, 1)
                self.state = 971
                self.alpha()
                pass
            elif token in [RULEMLParser.D0, RULEMLParser.D1, RULEMLParser.D2, RULEMLParser.D3, RULEMLParser.D4, RULEMLParser.D5, RULEMLParser.D6, RULEMLParser.D7, RULEMLParser.D8, RULEMLParser.D9]:
                self.enterOuterAlt(localctx, 2)
                self.state = 972
                self.digit()
                pass
            elif token in [RULEMLParser.UCSCHAR, RULEMLParser.DOT, RULEMLParser.HYPHEN, RULEMLParser.TILDE, RULEMLParser.USCORE]:
                self.enterOuterAlt(localctx, 3)
                self.state = 973
                _la = self._input.LA(1)
                if not(((((_la - 109)) & ~0x3f) == 0 and ((1 << (_la - 109)) & ((1 << (RULEMLParser.UCSCHAR - 109)) | (1 << (RULEMLParser.DOT - 109)) | (1 << (RULEMLParser.HYPHEN - 109)) | (1 << (RULEMLParser.TILDE - 109)) | (1 << (RULEMLParser.USCORE - 109)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SchemeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def alpha(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RULEMLParser.AlphaContext)
            else:
                return self.getTypedRuleContext(RULEMLParser.AlphaContext,i)


        def digit(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RULEMLParser.DigitContext)
            else:
                return self.getTypedRuleContext(RULEMLParser.DigitContext,i)


        def PLUS(self, i:int=None):
            if i is None:
                return self.getTokens(RULEMLParser.PLUS)
            else:
                return self.getToken(RULEMLParser.PLUS, i)

        def HYPHEN(self, i:int=None):
            if i is None:
                return self.getTokens(RULEMLParser.HYPHEN)
            else:
                return self.getToken(RULEMLParser.HYPHEN, i)

        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(RULEMLParser.DOT)
            else:
                return self.getToken(RULEMLParser.DOT, i)

        def getRuleIndex(self):
            return RULEMLParser.RULE_scheme

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterScheme" ):
                listener.enterScheme(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitScheme" ):
                listener.exitScheme(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitScheme" ):
                return visitor.visitScheme(self)
            else:
                return visitor.visitChildren(self)




    def scheme(self):

        localctx = RULEMLParser.SchemeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 272, self.RULE_scheme)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 976
            self.alpha()
            self.state = 982
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 111)) & ~0x3f) == 0 and ((1 << (_la - 111)) & ((1 << (RULEMLParser.D0 - 111)) | (1 << (RULEMLParser.D1 - 111)) | (1 << (RULEMLParser.D2 - 111)) | (1 << (RULEMLParser.D3 - 111)) | (1 << (RULEMLParser.D4 - 111)) | (1 << (RULEMLParser.D5 - 111)) | (1 << (RULEMLParser.D6 - 111)) | (1 << (RULEMLParser.D7 - 111)) | (1 << (RULEMLParser.D8 - 111)) | (1 << (RULEMLParser.D9 - 111)) | (1 << (RULEMLParser.A - 111)) | (1 << (RULEMLParser.B - 111)) | (1 << (RULEMLParser.C - 111)) | (1 << (RULEMLParser.D - 111)) | (1 << (RULEMLParser.E - 111)) | (1 << (RULEMLParser.F - 111)) | (1 << (RULEMLParser.G - 111)) | (1 << (RULEMLParser.H - 111)) | (1 << (RULEMLParser.I - 111)) | (1 << (RULEMLParser.J - 111)) | (1 << (RULEMLParser.K - 111)) | (1 << (RULEMLParser.L - 111)) | (1 << (RULEMLParser.M - 111)) | (1 << (RULEMLParser.N - 111)) | (1 << (RULEMLParser.O - 111)) | (1 << (RULEMLParser.P - 111)) | (1 << (RULEMLParser.Q - 111)) | (1 << (RULEMLParser.R - 111)) | (1 << (RULEMLParser.S - 111)) | (1 << (RULEMLParser.T - 111)) | (1 << (RULEMLParser.U - 111)) | (1 << (RULEMLParser.V - 111)) | (1 << (RULEMLParser.W - 111)) | (1 << (RULEMLParser.X - 111)) | (1 << (RULEMLParser.Y - 111)) | (1 << (RULEMLParser.Z - 111)) | (1 << (RULEMLParser.DOT - 111)) | (1 << (RULEMLParser.HYPHEN - 111)) | (1 << (RULEMLParser.PLUS - 111)))) != 0):
                self.state = 980
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [RULEMLParser.A, RULEMLParser.B, RULEMLParser.C, RULEMLParser.D, RULEMLParser.E, RULEMLParser.F, RULEMLParser.G, RULEMLParser.H, RULEMLParser.I, RULEMLParser.J, RULEMLParser.K, RULEMLParser.L, RULEMLParser.M, RULEMLParser.N, RULEMLParser.O, RULEMLParser.P, RULEMLParser.Q, RULEMLParser.R, RULEMLParser.S, RULEMLParser.T, RULEMLParser.U, RULEMLParser.V, RULEMLParser.W, RULEMLParser.X, RULEMLParser.Y, RULEMLParser.Z]:
                    self.state = 977
                    self.alpha()
                    pass
                elif token in [RULEMLParser.D0, RULEMLParser.D1, RULEMLParser.D2, RULEMLParser.D3, RULEMLParser.D4, RULEMLParser.D5, RULEMLParser.D6, RULEMLParser.D7, RULEMLParser.D8, RULEMLParser.D9]:
                    self.state = 978
                    self.digit()
                    pass
                elif token in [RULEMLParser.DOT, RULEMLParser.HYPHEN, RULEMLParser.PLUS]:
                    self.state = 979
                    _la = self._input.LA(1)
                    if not(((((_la - 149)) & ~0x3f) == 0 and ((1 << (_la - 149)) & ((1 << (RULEMLParser.DOT - 149)) | (1 << (RULEMLParser.HYPHEN - 149)) | (1 << (RULEMLParser.PLUS - 149)))) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 984
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PortContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def digit(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RULEMLParser.DigitContext)
            else:
                return self.getTypedRuleContext(RULEMLParser.DigitContext,i)


        def getRuleIndex(self):
            return RULEMLParser.RULE_port

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPort" ):
                listener.enterPort(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPort" ):
                listener.exitPort(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPort" ):
                return visitor.visitPort(self)
            else:
                return visitor.visitChildren(self)




    def port(self):

        localctx = RULEMLParser.PortContext(self, self._ctx, self.state)
        self.enterRule(localctx, 274, self.RULE_port)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 988
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 111)) & ~0x3f) == 0 and ((1 << (_la - 111)) & ((1 << (RULEMLParser.D0 - 111)) | (1 << (RULEMLParser.D1 - 111)) | (1 << (RULEMLParser.D2 - 111)) | (1 << (RULEMLParser.D3 - 111)) | (1 << (RULEMLParser.D4 - 111)) | (1 << (RULEMLParser.D5 - 111)) | (1 << (RULEMLParser.D6 - 111)) | (1 << (RULEMLParser.D7 - 111)) | (1 << (RULEMLParser.D8 - 111)) | (1 << (RULEMLParser.D9 - 111)))) != 0):
                self.state = 985
                self.digit()
                self.state = 990
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Ip_literalContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OBRACK(self):
            return self.getToken(RULEMLParser.OBRACK, 0)

        def CBRACK(self):
            return self.getToken(RULEMLParser.CBRACK, 0)

        def ip_v6_address(self):
            return self.getTypedRuleContext(RULEMLParser.Ip_v6_addressContext,0)


        def ip_v_future(self):
            return self.getTypedRuleContext(RULEMLParser.Ip_v_futureContext,0)


        def getRuleIndex(self):
            return RULEMLParser.RULE_ip_literal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIp_literal" ):
                listener.enterIp_literal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIp_literal" ):
                listener.exitIp_literal(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIp_literal" ):
                return visitor.visitIp_literal(self)
            else:
                return visitor.visitChildren(self)




    def ip_literal(self):

        localctx = RULEMLParser.Ip_literalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 276, self.RULE_ip_literal)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 991
            self.match(RULEMLParser.OBRACK)
            self.state = 994
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [RULEMLParser.D0, RULEMLParser.D1, RULEMLParser.D2, RULEMLParser.D3, RULEMLParser.D4, RULEMLParser.D5, RULEMLParser.D6, RULEMLParser.D7, RULEMLParser.D8, RULEMLParser.D9, RULEMLParser.A, RULEMLParser.B, RULEMLParser.C, RULEMLParser.D, RULEMLParser.E, RULEMLParser.F, RULEMLParser.COL2]:
                self.state = 992
                self.ip_v6_address()
                pass
            elif token in [RULEMLParser.V]:
                self.state = 993
                self.ip_v_future()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 996
            self.match(RULEMLParser.CBRACK)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Ip_v_futureContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def V(self):
            return self.getToken(RULEMLParser.V, 0)

        def DOT(self):
            return self.getToken(RULEMLParser.DOT, 0)

        def hexdig(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RULEMLParser.HexdigContext)
            else:
                return self.getTypedRuleContext(RULEMLParser.HexdigContext,i)


        def unreserved(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RULEMLParser.UnreservedContext)
            else:
                return self.getTypedRuleContext(RULEMLParser.UnreservedContext,i)


        def sub_delims(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RULEMLParser.Sub_delimsContext)
            else:
                return self.getTypedRuleContext(RULEMLParser.Sub_delimsContext,i)


        def COL(self, i:int=None):
            if i is None:
                return self.getTokens(RULEMLParser.COL)
            else:
                return self.getToken(RULEMLParser.COL, i)

        def getRuleIndex(self):
            return RULEMLParser.RULE_ip_v_future

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIp_v_future" ):
                listener.enterIp_v_future(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIp_v_future" ):
                listener.exitIp_v_future(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIp_v_future" ):
                return visitor.visitIp_v_future(self)
            else:
                return visitor.visitChildren(self)




    def ip_v_future(self):

        localctx = RULEMLParser.Ip_v_futureContext(self, self._ctx, self.state)
        self.enterRule(localctx, 278, self.RULE_ip_v_future)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 998
            self.match(RULEMLParser.V)
            self.state = 1000 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 999
                self.hexdig()
                self.state = 1002 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (((((_la - 111)) & ~0x3f) == 0 and ((1 << (_la - 111)) & ((1 << (RULEMLParser.D0 - 111)) | (1 << (RULEMLParser.D1 - 111)) | (1 << (RULEMLParser.D2 - 111)) | (1 << (RULEMLParser.D3 - 111)) | (1 << (RULEMLParser.D4 - 111)) | (1 << (RULEMLParser.D5 - 111)) | (1 << (RULEMLParser.D6 - 111)) | (1 << (RULEMLParser.D7 - 111)) | (1 << (RULEMLParser.D8 - 111)) | (1 << (RULEMLParser.D9 - 111)) | (1 << (RULEMLParser.A - 111)) | (1 << (RULEMLParser.B - 111)) | (1 << (RULEMLParser.C - 111)) | (1 << (RULEMLParser.D - 111)) | (1 << (RULEMLParser.E - 111)) | (1 << (RULEMLParser.F - 111)))) != 0)):
                    break

            self.state = 1004
            self.match(RULEMLParser.DOT)
            self.state = 1008 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 1008
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [RULEMLParser.D0, RULEMLParser.D1, RULEMLParser.D2, RULEMLParser.D3, RULEMLParser.D4, RULEMLParser.D5, RULEMLParser.D6, RULEMLParser.D7, RULEMLParser.D8, RULEMLParser.D9, RULEMLParser.A, RULEMLParser.B, RULEMLParser.C, RULEMLParser.D, RULEMLParser.E, RULEMLParser.F, RULEMLParser.G, RULEMLParser.H, RULEMLParser.I, RULEMLParser.J, RULEMLParser.K, RULEMLParser.L, RULEMLParser.M, RULEMLParser.N, RULEMLParser.O, RULEMLParser.P, RULEMLParser.Q, RULEMLParser.R, RULEMLParser.S, RULEMLParser.T, RULEMLParser.U, RULEMLParser.V, RULEMLParser.W, RULEMLParser.X, RULEMLParser.Y, RULEMLParser.Z, RULEMLParser.DOT, RULEMLParser.HYPHEN, RULEMLParser.TILDE, RULEMLParser.USCORE]:
                    self.state = 1005
                    self.unreserved()
                    pass
                elif token in [RULEMLParser.EXCL, RULEMLParser.DOLLAR, RULEMLParser.AMP, RULEMLParser.SQUOTE, RULEMLParser.OPAREN, RULEMLParser.CPAREN, RULEMLParser.STAR, RULEMLParser.PLUS, RULEMLParser.COMMA, RULEMLParser.SCOL, RULEMLParser.EQUALS]:
                    self.state = 1006
                    self.sub_delims()
                    pass
                elif token in [RULEMLParser.COL]:
                    self.state = 1007
                    self.match(RULEMLParser.COL)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1010 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (((((_la - 111)) & ~0x3f) == 0 and ((1 << (_la - 111)) & ((1 << (RULEMLParser.D0 - 111)) | (1 << (RULEMLParser.D1 - 111)) | (1 << (RULEMLParser.D2 - 111)) | (1 << (RULEMLParser.D3 - 111)) | (1 << (RULEMLParser.D4 - 111)) | (1 << (RULEMLParser.D5 - 111)) | (1 << (RULEMLParser.D6 - 111)) | (1 << (RULEMLParser.D7 - 111)) | (1 << (RULEMLParser.D8 - 111)) | (1 << (RULEMLParser.D9 - 111)) | (1 << (RULEMLParser.A - 111)) | (1 << (RULEMLParser.B - 111)) | (1 << (RULEMLParser.C - 111)) | (1 << (RULEMLParser.D - 111)) | (1 << (RULEMLParser.E - 111)) | (1 << (RULEMLParser.F - 111)) | (1 << (RULEMLParser.G - 111)) | (1 << (RULEMLParser.H - 111)) | (1 << (RULEMLParser.I - 111)) | (1 << (RULEMLParser.J - 111)) | (1 << (RULEMLParser.K - 111)) | (1 << (RULEMLParser.L - 111)) | (1 << (RULEMLParser.M - 111)) | (1 << (RULEMLParser.N - 111)) | (1 << (RULEMLParser.O - 111)) | (1 << (RULEMLParser.P - 111)) | (1 << (RULEMLParser.Q - 111)) | (1 << (RULEMLParser.R - 111)) | (1 << (RULEMLParser.S - 111)) | (1 << (RULEMLParser.T - 111)) | (1 << (RULEMLParser.U - 111)) | (1 << (RULEMLParser.V - 111)) | (1 << (RULEMLParser.W - 111)) | (1 << (RULEMLParser.X - 111)) | (1 << (RULEMLParser.Y - 111)) | (1 << (RULEMLParser.Z - 111)) | (1 << (RULEMLParser.COL - 111)) | (1 << (RULEMLParser.DOT - 111)) | (1 << (RULEMLParser.HYPHEN - 111)) | (1 << (RULEMLParser.TILDE - 111)) | (1 << (RULEMLParser.USCORE - 111)) | (1 << (RULEMLParser.EXCL - 111)) | (1 << (RULEMLParser.DOLLAR - 111)) | (1 << (RULEMLParser.AMP - 111)) | (1 << (RULEMLParser.SQUOTE - 111)) | (1 << (RULEMLParser.OPAREN - 111)) | (1 << (RULEMLParser.CPAREN - 111)) | (1 << (RULEMLParser.STAR - 111)) | (1 << (RULEMLParser.PLUS - 111)) | (1 << (RULEMLParser.COMMA - 111)) | (1 << (RULEMLParser.SCOL - 111)) | (1 << (RULEMLParser.EQUALS - 111)))) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Ip_v6_addressContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def h16(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RULEMLParser.H16Context)
            else:
                return self.getTypedRuleContext(RULEMLParser.H16Context,i)


        def COL(self, i:int=None):
            if i is None:
                return self.getTokens(RULEMLParser.COL)
            else:
                return self.getToken(RULEMLParser.COL, i)

        def ls32(self):
            return self.getTypedRuleContext(RULEMLParser.Ls32Context,0)


        def COL2(self):
            return self.getToken(RULEMLParser.COL2, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_ip_v6_address

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIp_v6_address" ):
                listener.enterIp_v6_address(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIp_v6_address" ):
                listener.exitIp_v6_address(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIp_v6_address" ):
                return visitor.visitIp_v6_address(self)
            else:
                return visitor.visitChildren(self)




    def ip_v6_address(self):

        localctx = RULEMLParser.Ip_v6_addressContext(self, self._ctx, self.state)
        self.enterRule(localctx, 280, self.RULE_ip_v6_address)
        self._la = 0 # Token type
        try:
            self.state = 1202
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,97,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1012
                self.h16()
                self.state = 1013
                self.match(RULEMLParser.COL)
                self.state = 1014
                self.h16()
                self.state = 1015
                self.match(RULEMLParser.COL)
                self.state = 1016
                self.h16()
                self.state = 1017
                self.match(RULEMLParser.COL)
                self.state = 1018
                self.h16()
                self.state = 1019
                self.match(RULEMLParser.COL)
                self.state = 1020
                self.h16()
                self.state = 1021
                self.match(RULEMLParser.COL)
                self.state = 1022
                self.h16()
                self.state = 1023
                self.match(RULEMLParser.COL)
                self.state = 1024
                self.ls32()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1026
                self.match(RULEMLParser.COL2)
                self.state = 1027
                self.h16()
                self.state = 1028
                self.match(RULEMLParser.COL)
                self.state = 1029
                self.h16()
                self.state = 1030
                self.match(RULEMLParser.COL)
                self.state = 1031
                self.h16()
                self.state = 1032
                self.match(RULEMLParser.COL)
                self.state = 1033
                self.h16()
                self.state = 1034
                self.match(RULEMLParser.COL)
                self.state = 1035
                self.h16()
                self.state = 1036
                self.match(RULEMLParser.COL)
                self.state = 1037
                self.ls32()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1040
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 111)) & ~0x3f) == 0 and ((1 << (_la - 111)) & ((1 << (RULEMLParser.D0 - 111)) | (1 << (RULEMLParser.D1 - 111)) | (1 << (RULEMLParser.D2 - 111)) | (1 << (RULEMLParser.D3 - 111)) | (1 << (RULEMLParser.D4 - 111)) | (1 << (RULEMLParser.D5 - 111)) | (1 << (RULEMLParser.D6 - 111)) | (1 << (RULEMLParser.D7 - 111)) | (1 << (RULEMLParser.D8 - 111)) | (1 << (RULEMLParser.D9 - 111)) | (1 << (RULEMLParser.A - 111)) | (1 << (RULEMLParser.B - 111)) | (1 << (RULEMLParser.C - 111)) | (1 << (RULEMLParser.D - 111)) | (1 << (RULEMLParser.E - 111)) | (1 << (RULEMLParser.F - 111)))) != 0):
                    self.state = 1039
                    self.h16()


                self.state = 1042
                self.match(RULEMLParser.COL2)
                self.state = 1043
                self.h16()
                self.state = 1044
                self.match(RULEMLParser.COL)
                self.state = 1045
                self.h16()
                self.state = 1046
                self.match(RULEMLParser.COL)
                self.state = 1047
                self.h16()
                self.state = 1048
                self.match(RULEMLParser.COL)
                self.state = 1049
                self.h16()
                self.state = 1050
                self.match(RULEMLParser.COL)
                self.state = 1051
                self.ls32()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1059
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 111)) & ~0x3f) == 0 and ((1 << (_la - 111)) & ((1 << (RULEMLParser.D0 - 111)) | (1 << (RULEMLParser.D1 - 111)) | (1 << (RULEMLParser.D2 - 111)) | (1 << (RULEMLParser.D3 - 111)) | (1 << (RULEMLParser.D4 - 111)) | (1 << (RULEMLParser.D5 - 111)) | (1 << (RULEMLParser.D6 - 111)) | (1 << (RULEMLParser.D7 - 111)) | (1 << (RULEMLParser.D8 - 111)) | (1 << (RULEMLParser.D9 - 111)) | (1 << (RULEMLParser.A - 111)) | (1 << (RULEMLParser.B - 111)) | (1 << (RULEMLParser.C - 111)) | (1 << (RULEMLParser.D - 111)) | (1 << (RULEMLParser.E - 111)) | (1 << (RULEMLParser.F - 111)))) != 0):
                    self.state = 1056
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,70,self._ctx)
                    if la_ == 1:
                        self.state = 1053
                        self.h16()
                        self.state = 1054
                        self.match(RULEMLParser.COL)


                    self.state = 1058
                    self.h16()


                self.state = 1061
                self.match(RULEMLParser.COL2)
                self.state = 1062
                self.h16()
                self.state = 1063
                self.match(RULEMLParser.COL)
                self.state = 1064
                self.h16()
                self.state = 1065
                self.match(RULEMLParser.COL)
                self.state = 1066
                self.h16()
                self.state = 1067
                self.match(RULEMLParser.COL)
                self.state = 1068
                self.ls32()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1081
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 111)) & ~0x3f) == 0 and ((1 << (_la - 111)) & ((1 << (RULEMLParser.D0 - 111)) | (1 << (RULEMLParser.D1 - 111)) | (1 << (RULEMLParser.D2 - 111)) | (1 << (RULEMLParser.D3 - 111)) | (1 << (RULEMLParser.D4 - 111)) | (1 << (RULEMLParser.D5 - 111)) | (1 << (RULEMLParser.D6 - 111)) | (1 << (RULEMLParser.D7 - 111)) | (1 << (RULEMLParser.D8 - 111)) | (1 << (RULEMLParser.D9 - 111)) | (1 << (RULEMLParser.A - 111)) | (1 << (RULEMLParser.B - 111)) | (1 << (RULEMLParser.C - 111)) | (1 << (RULEMLParser.D - 111)) | (1 << (RULEMLParser.E - 111)) | (1 << (RULEMLParser.F - 111)))) != 0):
                    self.state = 1078
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,73,self._ctx)
                    if la_ == 1:
                        self.state = 1073
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,72,self._ctx)
                        if la_ == 1:
                            self.state = 1070
                            self.h16()
                            self.state = 1071
                            self.match(RULEMLParser.COL)


                        self.state = 1075
                        self.h16()
                        self.state = 1076
                        self.match(RULEMLParser.COL)


                    self.state = 1080
                    self.h16()


                self.state = 1083
                self.match(RULEMLParser.COL2)
                self.state = 1084
                self.h16()
                self.state = 1085
                self.match(RULEMLParser.COL)
                self.state = 1086
                self.h16()
                self.state = 1087
                self.match(RULEMLParser.COL)
                self.state = 1088
                self.ls32()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 1106
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 111)) & ~0x3f) == 0 and ((1 << (_la - 111)) & ((1 << (RULEMLParser.D0 - 111)) | (1 << (RULEMLParser.D1 - 111)) | (1 << (RULEMLParser.D2 - 111)) | (1 << (RULEMLParser.D3 - 111)) | (1 << (RULEMLParser.D4 - 111)) | (1 << (RULEMLParser.D5 - 111)) | (1 << (RULEMLParser.D6 - 111)) | (1 << (RULEMLParser.D7 - 111)) | (1 << (RULEMLParser.D8 - 111)) | (1 << (RULEMLParser.D9 - 111)) | (1 << (RULEMLParser.A - 111)) | (1 << (RULEMLParser.B - 111)) | (1 << (RULEMLParser.C - 111)) | (1 << (RULEMLParser.D - 111)) | (1 << (RULEMLParser.E - 111)) | (1 << (RULEMLParser.F - 111)))) != 0):
                    self.state = 1103
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,77,self._ctx)
                    if la_ == 1:
                        self.state = 1098
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,76,self._ctx)
                        if la_ == 1:
                            self.state = 1093
                            self._errHandler.sync(self)
                            la_ = self._interp.adaptivePredict(self._input,75,self._ctx)
                            if la_ == 1:
                                self.state = 1090
                                self.h16()
                                self.state = 1091
                                self.match(RULEMLParser.COL)


                            self.state = 1095
                            self.h16()
                            self.state = 1096
                            self.match(RULEMLParser.COL)


                        self.state = 1100
                        self.h16()
                        self.state = 1101
                        self.match(RULEMLParser.COL)


                    self.state = 1105
                    self.h16()


                self.state = 1108
                self.match(RULEMLParser.COL2)
                self.state = 1109
                self.h16()
                self.state = 1110
                self.match(RULEMLParser.COL)
                self.state = 1111
                self.ls32()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 1134
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 111)) & ~0x3f) == 0 and ((1 << (_la - 111)) & ((1 << (RULEMLParser.D0 - 111)) | (1 << (RULEMLParser.D1 - 111)) | (1 << (RULEMLParser.D2 - 111)) | (1 << (RULEMLParser.D3 - 111)) | (1 << (RULEMLParser.D4 - 111)) | (1 << (RULEMLParser.D5 - 111)) | (1 << (RULEMLParser.D6 - 111)) | (1 << (RULEMLParser.D7 - 111)) | (1 << (RULEMLParser.D8 - 111)) | (1 << (RULEMLParser.D9 - 111)) | (1 << (RULEMLParser.A - 111)) | (1 << (RULEMLParser.B - 111)) | (1 << (RULEMLParser.C - 111)) | (1 << (RULEMLParser.D - 111)) | (1 << (RULEMLParser.E - 111)) | (1 << (RULEMLParser.F - 111)))) != 0):
                    self.state = 1131
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,82,self._ctx)
                    if la_ == 1:
                        self.state = 1126
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,81,self._ctx)
                        if la_ == 1:
                            self.state = 1121
                            self._errHandler.sync(self)
                            la_ = self._interp.adaptivePredict(self._input,80,self._ctx)
                            if la_ == 1:
                                self.state = 1116
                                self._errHandler.sync(self)
                                la_ = self._interp.adaptivePredict(self._input,79,self._ctx)
                                if la_ == 1:
                                    self.state = 1113
                                    self.h16()
                                    self.state = 1114
                                    self.match(RULEMLParser.COL)


                                self.state = 1118
                                self.h16()
                                self.state = 1119
                                self.match(RULEMLParser.COL)


                            self.state = 1123
                            self.h16()
                            self.state = 1124
                            self.match(RULEMLParser.COL)


                        self.state = 1128
                        self.h16()
                        self.state = 1129
                        self.match(RULEMLParser.COL)


                    self.state = 1133
                    self.h16()


                self.state = 1136
                self.match(RULEMLParser.COL2)
                self.state = 1137
                self.ls32()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 1164
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 111)) & ~0x3f) == 0 and ((1 << (_la - 111)) & ((1 << (RULEMLParser.D0 - 111)) | (1 << (RULEMLParser.D1 - 111)) | (1 << (RULEMLParser.D2 - 111)) | (1 << (RULEMLParser.D3 - 111)) | (1 << (RULEMLParser.D4 - 111)) | (1 << (RULEMLParser.D5 - 111)) | (1 << (RULEMLParser.D6 - 111)) | (1 << (RULEMLParser.D7 - 111)) | (1 << (RULEMLParser.D8 - 111)) | (1 << (RULEMLParser.D9 - 111)) | (1 << (RULEMLParser.A - 111)) | (1 << (RULEMLParser.B - 111)) | (1 << (RULEMLParser.C - 111)) | (1 << (RULEMLParser.D - 111)) | (1 << (RULEMLParser.E - 111)) | (1 << (RULEMLParser.F - 111)))) != 0):
                    self.state = 1161
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,88,self._ctx)
                    if la_ == 1:
                        self.state = 1156
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,87,self._ctx)
                        if la_ == 1:
                            self.state = 1151
                            self._errHandler.sync(self)
                            la_ = self._interp.adaptivePredict(self._input,86,self._ctx)
                            if la_ == 1:
                                self.state = 1146
                                self._errHandler.sync(self)
                                la_ = self._interp.adaptivePredict(self._input,85,self._ctx)
                                if la_ == 1:
                                    self.state = 1141
                                    self._errHandler.sync(self)
                                    la_ = self._interp.adaptivePredict(self._input,84,self._ctx)
                                    if la_ == 1:
                                        self.state = 1138
                                        self.h16()
                                        self.state = 1139
                                        self.match(RULEMLParser.COL)


                                    self.state = 1143
                                    self.h16()
                                    self.state = 1144
                                    self.match(RULEMLParser.COL)


                                self.state = 1148
                                self.h16()
                                self.state = 1149
                                self.match(RULEMLParser.COL)


                            self.state = 1153
                            self.h16()
                            self.state = 1154
                            self.match(RULEMLParser.COL)


                        self.state = 1158
                        self.h16()
                        self.state = 1159
                        self.match(RULEMLParser.COL)


                    self.state = 1163
                    self.h16()


                self.state = 1166
                self.match(RULEMLParser.COL2)
                self.state = 1167
                self.h16()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 1199
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 111)) & ~0x3f) == 0 and ((1 << (_la - 111)) & ((1 << (RULEMLParser.D0 - 111)) | (1 << (RULEMLParser.D1 - 111)) | (1 << (RULEMLParser.D2 - 111)) | (1 << (RULEMLParser.D3 - 111)) | (1 << (RULEMLParser.D4 - 111)) | (1 << (RULEMLParser.D5 - 111)) | (1 << (RULEMLParser.D6 - 111)) | (1 << (RULEMLParser.D7 - 111)) | (1 << (RULEMLParser.D8 - 111)) | (1 << (RULEMLParser.D9 - 111)) | (1 << (RULEMLParser.A - 111)) | (1 << (RULEMLParser.B - 111)) | (1 << (RULEMLParser.C - 111)) | (1 << (RULEMLParser.D - 111)) | (1 << (RULEMLParser.E - 111)) | (1 << (RULEMLParser.F - 111)))) != 0):
                    self.state = 1196
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,95,self._ctx)
                    if la_ == 1:
                        self.state = 1191
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,94,self._ctx)
                        if la_ == 1:
                            self.state = 1186
                            self._errHandler.sync(self)
                            la_ = self._interp.adaptivePredict(self._input,93,self._ctx)
                            if la_ == 1:
                                self.state = 1181
                                self._errHandler.sync(self)
                                la_ = self._interp.adaptivePredict(self._input,92,self._ctx)
                                if la_ == 1:
                                    self.state = 1176
                                    self._errHandler.sync(self)
                                    la_ = self._interp.adaptivePredict(self._input,91,self._ctx)
                                    if la_ == 1:
                                        self.state = 1171
                                        self._errHandler.sync(self)
                                        la_ = self._interp.adaptivePredict(self._input,90,self._ctx)
                                        if la_ == 1:
                                            self.state = 1168
                                            self.h16()
                                            self.state = 1169
                                            self.match(RULEMLParser.COL)


                                        self.state = 1173
                                        self.h16()
                                        self.state = 1174
                                        self.match(RULEMLParser.COL)


                                    self.state = 1178
                                    self.h16()
                                    self.state = 1179
                                    self.match(RULEMLParser.COL)


                                self.state = 1183
                                self.h16()
                                self.state = 1184
                                self.match(RULEMLParser.COL)


                            self.state = 1188
                            self.h16()
                            self.state = 1189
                            self.match(RULEMLParser.COL)


                        self.state = 1193
                        self.h16()
                        self.state = 1194
                        self.match(RULEMLParser.COL)


                    self.state = 1198
                    self.h16()


                self.state = 1201
                self.match(RULEMLParser.COL2)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class H16Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def hexdig(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RULEMLParser.HexdigContext)
            else:
                return self.getTypedRuleContext(RULEMLParser.HexdigContext,i)


        def getRuleIndex(self):
            return RULEMLParser.RULE_h16

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterH16" ):
                listener.enterH16(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitH16" ):
                listener.exitH16(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitH16" ):
                return visitor.visitH16(self)
            else:
                return visitor.visitChildren(self)




    def h16(self):

        localctx = RULEMLParser.H16Context(self, self._ctx, self.state)
        self.enterRule(localctx, 282, self.RULE_h16)
        try:
            self.state = 1217
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,98,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1204
                self.hexdig()
                self.state = 1205
                self.hexdig()
                self.state = 1206
                self.hexdig()
                self.state = 1207
                self.hexdig()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1209
                self.hexdig()
                self.state = 1210
                self.hexdig()
                self.state = 1211
                self.hexdig()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1213
                self.hexdig()
                self.state = 1214
                self.hexdig()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1216
                self.hexdig()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Ls32Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def h16(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RULEMLParser.H16Context)
            else:
                return self.getTypedRuleContext(RULEMLParser.H16Context,i)


        def COL(self):
            return self.getToken(RULEMLParser.COL, 0)

        def ip_v4_address(self):
            return self.getTypedRuleContext(RULEMLParser.Ip_v4_addressContext,0)


        def getRuleIndex(self):
            return RULEMLParser.RULE_ls32

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLs32" ):
                listener.enterLs32(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLs32" ):
                listener.exitLs32(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLs32" ):
                return visitor.visitLs32(self)
            else:
                return visitor.visitChildren(self)




    def ls32(self):

        localctx = RULEMLParser.Ls32Context(self, self._ctx, self.state)
        self.enterRule(localctx, 284, self.RULE_ls32)
        try:
            self.state = 1224
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,99,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1219
                self.h16()
                self.state = 1220
                self.match(RULEMLParser.COL)
                self.state = 1221
                self.h16()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1223
                self.ip_v4_address()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Ip_v4_addressContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def dec_octet(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RULEMLParser.Dec_octetContext)
            else:
                return self.getTypedRuleContext(RULEMLParser.Dec_octetContext,i)


        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(RULEMLParser.DOT)
            else:
                return self.getToken(RULEMLParser.DOT, i)

        def getRuleIndex(self):
            return RULEMLParser.RULE_ip_v4_address

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIp_v4_address" ):
                listener.enterIp_v4_address(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIp_v4_address" ):
                listener.exitIp_v4_address(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIp_v4_address" ):
                return visitor.visitIp_v4_address(self)
            else:
                return visitor.visitChildren(self)




    def ip_v4_address(self):

        localctx = RULEMLParser.Ip_v4_addressContext(self, self._ctx, self.state)
        self.enterRule(localctx, 286, self.RULE_ip_v4_address)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1226
            self.dec_octet()
            self.state = 1227
            self.match(RULEMLParser.DOT)
            self.state = 1228
            self.dec_octet()
            self.state = 1229
            self.match(RULEMLParser.DOT)
            self.state = 1230
            self.dec_octet()
            self.state = 1231
            self.match(RULEMLParser.DOT)
            self.state = 1232
            self.dec_octet()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Dec_octetContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def digit(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RULEMLParser.DigitContext)
            else:
                return self.getTypedRuleContext(RULEMLParser.DigitContext,i)


        def non_zero_digit(self):
            return self.getTypedRuleContext(RULEMLParser.Non_zero_digitContext,0)


        def D1(self):
            return self.getToken(RULEMLParser.D1, 0)

        def D2(self, i:int=None):
            if i is None:
                return self.getTokens(RULEMLParser.D2)
            else:
                return self.getToken(RULEMLParser.D2, i)

        def D0(self):
            return self.getToken(RULEMLParser.D0, 0)

        def D3(self):
            return self.getToken(RULEMLParser.D3, 0)

        def D4(self):
            return self.getToken(RULEMLParser.D4, 0)

        def D5(self, i:int=None):
            if i is None:
                return self.getTokens(RULEMLParser.D5)
            else:
                return self.getToken(RULEMLParser.D5, i)

        def getRuleIndex(self):
            return RULEMLParser.RULE_dec_octet

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDec_octet" ):
                listener.enterDec_octet(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDec_octet" ):
                listener.exitDec_octet(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDec_octet" ):
                return visitor.visitDec_octet(self)
            else:
                return visitor.visitChildren(self)




    def dec_octet(self):

        localctx = RULEMLParser.Dec_octetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 288, self.RULE_dec_octet)
        self._la = 0 # Token type
        try:
            self.state = 1248
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,100,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1234
                self.digit()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1235
                self.non_zero_digit()
                self.state = 1236
                self.digit()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1238
                self.match(RULEMLParser.D1)
                self.state = 1239
                self.digit()
                self.state = 1240
                self.digit()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1242
                self.match(RULEMLParser.D2)
                self.state = 1243
                _la = self._input.LA(1)
                if not(((((_la - 111)) & ~0x3f) == 0 and ((1 << (_la - 111)) & ((1 << (RULEMLParser.D0 - 111)) | (1 << (RULEMLParser.D1 - 111)) | (1 << (RULEMLParser.D2 - 111)) | (1 << (RULEMLParser.D3 - 111)) | (1 << (RULEMLParser.D4 - 111)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1244
                self.digit()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1245
                self.match(RULEMLParser.D2)
                self.state = 1246
                self.match(RULEMLParser.D5)
                self.state = 1247
                _la = self._input.LA(1)
                if not(((((_la - 111)) & ~0x3f) == 0 and ((1 << (_la - 111)) & ((1 << (RULEMLParser.D0 - 111)) | (1 << (RULEMLParser.D1 - 111)) | (1 << (RULEMLParser.D2 - 111)) | (1 << (RULEMLParser.D3 - 111)) | (1 << (RULEMLParser.D4 - 111)) | (1 << (RULEMLParser.D5 - 111)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Pct_encodedContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PERCENT(self):
            return self.getToken(RULEMLParser.PERCENT, 0)

        def hexdig(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RULEMLParser.HexdigContext)
            else:
                return self.getTypedRuleContext(RULEMLParser.HexdigContext,i)


        def getRuleIndex(self):
            return RULEMLParser.RULE_pct_encoded

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPct_encoded" ):
                listener.enterPct_encoded(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPct_encoded" ):
                listener.exitPct_encoded(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPct_encoded" ):
                return visitor.visitPct_encoded(self)
            else:
                return visitor.visitChildren(self)




    def pct_encoded(self):

        localctx = RULEMLParser.Pct_encodedContext(self, self._ctx, self.state)
        self.enterRule(localctx, 290, self.RULE_pct_encoded)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1250
            self.match(RULEMLParser.PERCENT)
            self.state = 1251
            self.hexdig()
            self.state = 1252
            self.hexdig()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnreservedContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def alpha(self):
            return self.getTypedRuleContext(RULEMLParser.AlphaContext,0)


        def digit(self):
            return self.getTypedRuleContext(RULEMLParser.DigitContext,0)


        def HYPHEN(self):
            return self.getToken(RULEMLParser.HYPHEN, 0)

        def DOT(self):
            return self.getToken(RULEMLParser.DOT, 0)

        def USCORE(self):
            return self.getToken(RULEMLParser.USCORE, 0)

        def TILDE(self):
            return self.getToken(RULEMLParser.TILDE, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_unreserved

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnreserved" ):
                listener.enterUnreserved(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnreserved" ):
                listener.exitUnreserved(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnreserved" ):
                return visitor.visitUnreserved(self)
            else:
                return visitor.visitChildren(self)




    def unreserved(self):

        localctx = RULEMLParser.UnreservedContext(self, self._ctx, self.state)
        self.enterRule(localctx, 292, self.RULE_unreserved)
        self._la = 0 # Token type
        try:
            self.state = 1257
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [RULEMLParser.A, RULEMLParser.B, RULEMLParser.C, RULEMLParser.D, RULEMLParser.E, RULEMLParser.F, RULEMLParser.G, RULEMLParser.H, RULEMLParser.I, RULEMLParser.J, RULEMLParser.K, RULEMLParser.L, RULEMLParser.M, RULEMLParser.N, RULEMLParser.O, RULEMLParser.P, RULEMLParser.Q, RULEMLParser.R, RULEMLParser.S, RULEMLParser.T, RULEMLParser.U, RULEMLParser.V, RULEMLParser.W, RULEMLParser.X, RULEMLParser.Y, RULEMLParser.Z]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1254
                self.alpha()
                pass
            elif token in [RULEMLParser.D0, RULEMLParser.D1, RULEMLParser.D2, RULEMLParser.D3, RULEMLParser.D4, RULEMLParser.D5, RULEMLParser.D6, RULEMLParser.D7, RULEMLParser.D8, RULEMLParser.D9]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1255
                self.digit()
                pass
            elif token in [RULEMLParser.DOT, RULEMLParser.HYPHEN, RULEMLParser.TILDE, RULEMLParser.USCORE]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1256
                _la = self._input.LA(1)
                if not(((((_la - 149)) & ~0x3f) == 0 and ((1 << (_la - 149)) & ((1 << (RULEMLParser.DOT - 149)) | (1 << (RULEMLParser.HYPHEN - 149)) | (1 << (RULEMLParser.TILDE - 149)) | (1 << (RULEMLParser.USCORE - 149)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReservedContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def gen_delims(self):
            return self.getTypedRuleContext(RULEMLParser.Gen_delimsContext,0)


        def sub_delims(self):
            return self.getTypedRuleContext(RULEMLParser.Sub_delimsContext,0)


        def getRuleIndex(self):
            return RULEMLParser.RULE_reserved

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReserved" ):
                listener.enterReserved(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReserved" ):
                listener.exitReserved(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReserved" ):
                return visitor.visitReserved(self)
            else:
                return visitor.visitChildren(self)




    def reserved(self):

        localctx = RULEMLParser.ReservedContext(self, self._ctx, self.state)
        self.enterRule(localctx, 294, self.RULE_reserved)
        try:
            self.state = 1261
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [RULEMLParser.COL, RULEMLParser.FSLASH, RULEMLParser.QMARK, RULEMLParser.HASH, RULEMLParser.OBRACK, RULEMLParser.CBRACK, RULEMLParser.AT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1259
                self.gen_delims()
                pass
            elif token in [RULEMLParser.EXCL, RULEMLParser.DOLLAR, RULEMLParser.AMP, RULEMLParser.SQUOTE, RULEMLParser.OPAREN, RULEMLParser.CPAREN, RULEMLParser.STAR, RULEMLParser.PLUS, RULEMLParser.COMMA, RULEMLParser.SCOL, RULEMLParser.EQUALS]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1260
                self.sub_delims()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Gen_delimsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COL(self):
            return self.getToken(RULEMLParser.COL, 0)

        def FSLASH(self):
            return self.getToken(RULEMLParser.FSLASH, 0)

        def QMARK(self):
            return self.getToken(RULEMLParser.QMARK, 0)

        def HASH(self):
            return self.getToken(RULEMLParser.HASH, 0)

        def OBRACK(self):
            return self.getToken(RULEMLParser.OBRACK, 0)

        def CBRACK(self):
            return self.getToken(RULEMLParser.CBRACK, 0)

        def AT(self):
            return self.getToken(RULEMLParser.AT, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_gen_delims

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGen_delims" ):
                listener.enterGen_delims(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGen_delims" ):
                listener.exitGen_delims(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGen_delims" ):
                return visitor.visitGen_delims(self)
            else:
                return visitor.visitChildren(self)




    def gen_delims(self):

        localctx = RULEMLParser.Gen_delimsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 296, self.RULE_gen_delims)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1263
            _la = self._input.LA(1)
            if not(((((_la - 148)) & ~0x3f) == 0 and ((1 << (_la - 148)) & ((1 << (RULEMLParser.COL - 148)) | (1 << (RULEMLParser.FSLASH - 148)) | (1 << (RULEMLParser.QMARK - 148)) | (1 << (RULEMLParser.HASH - 148)) | (1 << (RULEMLParser.OBRACK - 148)) | (1 << (RULEMLParser.CBRACK - 148)) | (1 << (RULEMLParser.AT - 148)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Sub_delimsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EXCL(self):
            return self.getToken(RULEMLParser.EXCL, 0)

        def DOLLAR(self):
            return self.getToken(RULEMLParser.DOLLAR, 0)

        def AMP(self):
            return self.getToken(RULEMLParser.AMP, 0)

        def SQUOTE(self):
            return self.getToken(RULEMLParser.SQUOTE, 0)

        def OPAREN(self):
            return self.getToken(RULEMLParser.OPAREN, 0)

        def CPAREN(self):
            return self.getToken(RULEMLParser.CPAREN, 0)

        def STAR(self):
            return self.getToken(RULEMLParser.STAR, 0)

        def PLUS(self):
            return self.getToken(RULEMLParser.PLUS, 0)

        def COMMA(self):
            return self.getToken(RULEMLParser.COMMA, 0)

        def SCOL(self):
            return self.getToken(RULEMLParser.SCOL, 0)

        def EQUALS(self):
            return self.getToken(RULEMLParser.EQUALS, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_sub_delims

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSub_delims" ):
                listener.enterSub_delims(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSub_delims" ):
                listener.exitSub_delims(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSub_delims" ):
                return visitor.visitSub_delims(self)
            else:
                return visitor.visitChildren(self)




    def sub_delims(self):

        localctx = RULEMLParser.Sub_delimsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 298, self.RULE_sub_delims)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1265
            _la = self._input.LA(1)
            if not(((((_la - 154)) & ~0x3f) == 0 and ((1 << (_la - 154)) & ((1 << (RULEMLParser.EXCL - 154)) | (1 << (RULEMLParser.DOLLAR - 154)) | (1 << (RULEMLParser.AMP - 154)) | (1 << (RULEMLParser.SQUOTE - 154)) | (1 << (RULEMLParser.OPAREN - 154)) | (1 << (RULEMLParser.CPAREN - 154)) | (1 << (RULEMLParser.STAR - 154)) | (1 << (RULEMLParser.PLUS - 154)) | (1 << (RULEMLParser.COMMA - 154)) | (1 << (RULEMLParser.SCOL - 154)) | (1 << (RULEMLParser.EQUALS - 154)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AlphaContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def A(self):
            return self.getToken(RULEMLParser.A, 0)

        def B(self):
            return self.getToken(RULEMLParser.B, 0)

        def C(self):
            return self.getToken(RULEMLParser.C, 0)

        def D(self):
            return self.getToken(RULEMLParser.D, 0)

        def E(self):
            return self.getToken(RULEMLParser.E, 0)

        def F(self):
            return self.getToken(RULEMLParser.F, 0)

        def G(self):
            return self.getToken(RULEMLParser.G, 0)

        def H(self):
            return self.getToken(RULEMLParser.H, 0)

        def I(self):
            return self.getToken(RULEMLParser.I, 0)

        def J(self):
            return self.getToken(RULEMLParser.J, 0)

        def K(self):
            return self.getToken(RULEMLParser.K, 0)

        def L(self):
            return self.getToken(RULEMLParser.L, 0)

        def M(self):
            return self.getToken(RULEMLParser.M, 0)

        def N(self):
            return self.getToken(RULEMLParser.N, 0)

        def O(self):
            return self.getToken(RULEMLParser.O, 0)

        def P(self):
            return self.getToken(RULEMLParser.P, 0)

        def Q(self):
            return self.getToken(RULEMLParser.Q, 0)

        def R(self):
            return self.getToken(RULEMLParser.R, 0)

        def S(self):
            return self.getToken(RULEMLParser.S, 0)

        def T(self):
            return self.getToken(RULEMLParser.T, 0)

        def U(self):
            return self.getToken(RULEMLParser.U, 0)

        def V(self):
            return self.getToken(RULEMLParser.V, 0)

        def W(self):
            return self.getToken(RULEMLParser.W, 0)

        def X(self):
            return self.getToken(RULEMLParser.X, 0)

        def Y(self):
            return self.getToken(RULEMLParser.Y, 0)

        def Z(self):
            return self.getToken(RULEMLParser.Z, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_alpha

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlpha" ):
                listener.enterAlpha(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlpha" ):
                listener.exitAlpha(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlpha" ):
                return visitor.visitAlpha(self)
            else:
                return visitor.visitChildren(self)




    def alpha(self):

        localctx = RULEMLParser.AlphaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 300, self.RULE_alpha)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1267
            _la = self._input.LA(1)
            if not(((((_la - 121)) & ~0x3f) == 0 and ((1 << (_la - 121)) & ((1 << (RULEMLParser.A - 121)) | (1 << (RULEMLParser.B - 121)) | (1 << (RULEMLParser.C - 121)) | (1 << (RULEMLParser.D - 121)) | (1 << (RULEMLParser.E - 121)) | (1 << (RULEMLParser.F - 121)) | (1 << (RULEMLParser.G - 121)) | (1 << (RULEMLParser.H - 121)) | (1 << (RULEMLParser.I - 121)) | (1 << (RULEMLParser.J - 121)) | (1 << (RULEMLParser.K - 121)) | (1 << (RULEMLParser.L - 121)) | (1 << (RULEMLParser.M - 121)) | (1 << (RULEMLParser.N - 121)) | (1 << (RULEMLParser.O - 121)) | (1 << (RULEMLParser.P - 121)) | (1 << (RULEMLParser.Q - 121)) | (1 << (RULEMLParser.R - 121)) | (1 << (RULEMLParser.S - 121)) | (1 << (RULEMLParser.T - 121)) | (1 << (RULEMLParser.U - 121)) | (1 << (RULEMLParser.V - 121)) | (1 << (RULEMLParser.W - 121)) | (1 << (RULEMLParser.X - 121)) | (1 << (RULEMLParser.Y - 121)) | (1 << (RULEMLParser.Z - 121)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HexdigContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def digit(self):
            return self.getTypedRuleContext(RULEMLParser.DigitContext,0)


        def A(self):
            return self.getToken(RULEMLParser.A, 0)

        def B(self):
            return self.getToken(RULEMLParser.B, 0)

        def C(self):
            return self.getToken(RULEMLParser.C, 0)

        def D(self):
            return self.getToken(RULEMLParser.D, 0)

        def E(self):
            return self.getToken(RULEMLParser.E, 0)

        def F(self):
            return self.getToken(RULEMLParser.F, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_hexdig

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHexdig" ):
                listener.enterHexdig(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHexdig" ):
                listener.exitHexdig(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHexdig" ):
                return visitor.visitHexdig(self)
            else:
                return visitor.visitChildren(self)




    def hexdig(self):

        localctx = RULEMLParser.HexdigContext(self, self._ctx, self.state)
        self.enterRule(localctx, 302, self.RULE_hexdig)
        self._la = 0 # Token type
        try:
            self.state = 1271
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [RULEMLParser.D0, RULEMLParser.D1, RULEMLParser.D2, RULEMLParser.D3, RULEMLParser.D4, RULEMLParser.D5, RULEMLParser.D6, RULEMLParser.D7, RULEMLParser.D8, RULEMLParser.D9]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1269
                self.digit()
                pass
            elif token in [RULEMLParser.A, RULEMLParser.B, RULEMLParser.C, RULEMLParser.D, RULEMLParser.E, RULEMLParser.F]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1270
                _la = self._input.LA(1)
                if not(((((_la - 121)) & ~0x3f) == 0 and ((1 << (_la - 121)) & ((1 << (RULEMLParser.A - 121)) | (1 << (RULEMLParser.B - 121)) | (1 << (RULEMLParser.C - 121)) | (1 << (RULEMLParser.D - 121)) | (1 << (RULEMLParser.E - 121)) | (1 << (RULEMLParser.F - 121)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DigitContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def D0(self):
            return self.getToken(RULEMLParser.D0, 0)

        def non_zero_digit(self):
            return self.getTypedRuleContext(RULEMLParser.Non_zero_digitContext,0)


        def getRuleIndex(self):
            return RULEMLParser.RULE_digit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDigit" ):
                listener.enterDigit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDigit" ):
                listener.exitDigit(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDigit" ):
                return visitor.visitDigit(self)
            else:
                return visitor.visitChildren(self)




    def digit(self):

        localctx = RULEMLParser.DigitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 304, self.RULE_digit)
        try:
            self.state = 1275
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [RULEMLParser.D0]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1273
                self.match(RULEMLParser.D0)
                pass
            elif token in [RULEMLParser.D1, RULEMLParser.D2, RULEMLParser.D3, RULEMLParser.D4, RULEMLParser.D5, RULEMLParser.D6, RULEMLParser.D7, RULEMLParser.D8, RULEMLParser.D9]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1274
                self.non_zero_digit()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Non_zero_digitContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def D1(self):
            return self.getToken(RULEMLParser.D1, 0)

        def D2(self):
            return self.getToken(RULEMLParser.D2, 0)

        def D3(self):
            return self.getToken(RULEMLParser.D3, 0)

        def D4(self):
            return self.getToken(RULEMLParser.D4, 0)

        def D5(self):
            return self.getToken(RULEMLParser.D5, 0)

        def D6(self):
            return self.getToken(RULEMLParser.D6, 0)

        def D7(self):
            return self.getToken(RULEMLParser.D7, 0)

        def D8(self):
            return self.getToken(RULEMLParser.D8, 0)

        def D9(self):
            return self.getToken(RULEMLParser.D9, 0)

        def getRuleIndex(self):
            return RULEMLParser.RULE_non_zero_digit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNon_zero_digit" ):
                listener.enterNon_zero_digit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNon_zero_digit" ):
                listener.exitNon_zero_digit(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNon_zero_digit" ):
                return visitor.visitNon_zero_digit(self)
            else:
                return visitor.visitChildren(self)




    def non_zero_digit(self):

        localctx = RULEMLParser.Non_zero_digitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 306, self.RULE_non_zero_digit)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1277
            _la = self._input.LA(1)
            if not(((((_la - 112)) & ~0x3f) == 0 and ((1 << (_la - 112)) & ((1 << (RULEMLParser.D1 - 112)) | (1 << (RULEMLParser.D2 - 112)) | (1 << (RULEMLParser.D3 - 112)) | (1 << (RULEMLParser.D4 - 112)) | (1 << (RULEMLParser.D5 - 112)) | (1 << (RULEMLParser.D6 - 112)) | (1 << (RULEMLParser.D7 - 112)) | (1 << (RULEMLParser.D8 - 112)) | (1 << (RULEMLParser.D9 - 112)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





